FILE: .rustfmt.toml
#combine_control_expr = false
#condense_wildcard_suffixes = true
edition = "2018"
#fn_params_layout = "Compressed"
#format_strings = true
#indent_style = "Visual"
newline_style = "Unix"
max_width = 80
#reorder_impl_items = true
#group_imports = "StdExternalCrate"
#trailing_comma = "Never"
#trailing_semicolon = false
use_field_init_shorthand = true
use_try_shorthand = true

---
FILE: Cargo.toml
[workspace]
members = [
    "drmem-api",
    "drivers/*",
    "drmemd"
]
default-members = ["drmemd"]
resolver = "2"

[workspace.dependencies]
chrono = { version = "0.4", default-features = false }
futures = { version = "0.3", default-features = false, features = ["std"] }
toml = { version = "0.8", default-features = false }
tokio = { version = "1", default-features = false }
tokio-stream = { version = "0.1", default-features = false }
tracing = { version = "0.1", default-features = false, features = ["attributes"] }
tracing-subscriber = { version = "0.3", default-features = false }
serde = { version = "1", default-features = false, features = ["rc"] }
serde_json = { version = "1", default-features = false }
palette = { version = "0.7", default-features = false }

# Profiles used by all binaries and packages.

[profile.dev.build-override]
opt-level = 3
incremental = false

[profile.dev]
opt-level = 'z'
debug = false
lto = false
codegen-units = 4
incremental = false

[profile.dev.package."*"]
opt-level = 'z'
debug = false
incremental = false

[profile.release.build-override]
opt-level = 3
incremental = false

[profile.release]
opt-level = 3
debug = false
lto = "thin"
codegen-units = 1
debug-assertions = false
strip = "symbols"
incremental = false

[profile.release.package."*"]
opt-level = 3
debug = false
incremental = false

---
FILE: config-example.toml
# Sets the default log level. Can be 'warn', 'info', 'debug', or
# 'trace'.

log_level = "warn"

# This table configures the connection to the Redis service. All
# drivers will use this information to make their connection. Client
# accounts and passwords (if any) are specified in each driver's
# config.

[redis]

addr = "127.0.0.1"
port = 6379
dbn = 0

# This section is temporary. Philips Hue devices will eventually have
# their own general purpose driver so this information will be
# specified in the driver's config.

[hue_bridge]

addr = "192.168.1.1"
key = "client_key_from_philips_hue"

# This section starts the driver configuration. Since this section is
# an array of tables, these drivers will be initialized in order of
# definition. If there are dependencies between drivers, make sure
# they're properly ordered.

[[drivers]]

driver = "driver-1-name"
prefix = "driver-1-name-space"

    [[drivers.addr]]

    # Not sure how to express this in Rust's TOML library. Each driver
    # has its own set of addressing parameters so it needs to be
    # flexible enough to handle that.

[[drivers]]

driver = "driver-2-name"
prefix = "driver-2-name-space"

    [[drivers.addr]]

# Emacs mode settings.
#
# Local Variables
# mode:toml
# End:

---
FILE: doc/book/book.toml
[book]
title = "DrMem -- A Small-Scale Control System"
description = "Documentation for DrMem, a small control system written in Rust"
src = "content"


---
FILE: drivers/drmem-drv-ntp/Cargo.toml
[package]
name = "drmem-drv-ntp"
version = "0.7.1"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
homepage = "https://github.com/DrMemCS/drmem"
description = "DrMem driver which monitors ntpd daemons"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded"]
keywords = ["control-system", "automation"]

[lib]
doctest = false

[dependencies]
serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

toml.workspace = true
toml.default-features = false

tokio.workspace = true
tokio.default-features = false
tokio.features = ["net", "time", "macros"]

tracing.workspace = true
tracing.default-features = false

tracing-subscriber.workspace = true
tracing-subscriber.default-features = false

drmem-api = { path = "../../drmem-api", version = "0.7" }

---
FILE: drivers/drmem-drv-ntp/src/config.rs
use drmem_api::{driver::DriverConfig, Error};
use std::net::SocketAddrV4;

#[derive(serde::Deserialize)]
pub struct Params {
    pub addr: SocketAddrV4,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

#[cfg(test)]
mod tests {
    use super::Params;
    use drmem_api::{driver::DriverConfig, Error, Result};
    use std::net::SocketAddrV4;

    // Helper function to build a config from a string view.

    fn mk_cfg(text: &str) -> Result<Params> {
        Into::<DriverConfig>::into(
            toml::from_str::<toml::value::Table>(text)
                .map_err(|e| Error::ConfigError(format!("{}", e)))?,
        )
        .parse_into()
    }

    #[test]
    fn test_config() {
        assert!(mk_cfg("addr = 5").is_err());
        assert!(mk_cfg("addr = true").is_err());
        assert!(mk_cfg("addr = \"hello\"").is_err());

        let cfg = mk_cfg("addr = \"192.168.1.100:50\"").unwrap();

        assert_eq!(cfg.addr, SocketAddrV4::new([192, 168, 1, 100].into(), 50));
    }
}

---
FILE: drivers/drmem-drv-ntp/src/device.rs
use super::config;
use drmem_api::{
    driver::{self, Reporter, ResettableState},
    Result,
};

pub struct Set<R: Reporter> {
    pub d_state: driver::ReadOnlyDevice<bool, R>,
    pub d_source: driver::ReadOnlyDevice<String, R>,
    pub d_offset: driver::ReadOnlyDevice<f64, R>,
    pub d_delay: driver::ReadOnlyDevice<f64, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.

        let d_state = core.add_ro_device("state", None, max_history).await?;
        let d_source = core.add_ro_device("source", None, max_history).await?;
        let d_offset = core
            .add_ro_device("offset", Some("ms"), max_history)
            .await?;
        let d_delay =
            core.add_ro_device("delay", Some("ms"), max_history).await?;

        Ok(Set {
            d_state,
            d_source,
            d_offset,
            d_delay,
        })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drivers/drmem-drv-ntp/src/driver.rs
use drmem_api::{
    driver::{self, Reporter},
    Error, Result,
};
use std::convert::Infallible;
use std::{net::SocketAddr, str};
use tokio::net::UdpSocket;
use tokio::time::{self, Duration};
use tracing::{debug, error, trace, warn, Span};

use super::{config, device};

// This module defines the server task that retrieves the NTP information.

mod server {
    #[derive(Debug, PartialEq)]
    pub struct Info(String, f64, f64);

    impl Info {
        // Creates a new, initialized `Info` type.

        pub fn new(host: String, offset: f64, delay: f64) -> Info {
            Info(host, offset, delay)
        }

        // Creates a value which will never match any value returned
        // by an NTP server (because the host will never be blank.)

        pub fn bad_value() -> Info {
            Info(String::from(""), 0.0, 0.0)
        }

        // Returns the IP address of the NTP server.

        pub fn get_host(&self) -> &String {
            &self.0
        }

        // Returns the estimated offset (in milliseconds) of the
        // system time compared to the NTP server.

        pub fn get_offset(&self) -> f64 {
            self.1
        }

        // Returns the estimated time-of-flight delay (in
        // milliseconds) to the NTP server.

        pub fn get_delay(&self) -> f64 {
            self.2
        }
    }

    // Updates the `Info` object using up to three "interesting"
    // parameters from text consisting of comma-separated,
    // key/value pairs. The original `Info` is consumed by this
    // method.

    fn update_host_info(
        mut state: (Option<String>, Option<f64>, Option<f64>),
        item: &str,
    ) -> (Option<String>, Option<f64>, Option<f64>) {
        match item.split('=').collect::<Vec<&str>>()[..] {
            ["srcadr", adr] => state.0 = Some(String::from(adr)),
            ["offset", offset] => {
                if let Ok(o) = offset.parse::<f64>() {
                    state.1 = Some(o)
                }
            }
            ["delay", delay] => {
                if let Ok(d) = delay.parse::<f64>() {
                    state.2 = Some(d)
                }
            }
            _ => (),
        }
        state
    }

    // Returns an `Info` type that has been initialized with the
    // parameters defined in `input`.

    pub fn decode_info(input: &str) -> Option<Info> {
        let result = input
            .split(',')
            .filter(|v| !v.is_empty())
            .map(|v| v.trim_start())
            .fold((None, None, None), update_host_info);

        if let (Some(a), Some(o), Some(d)) = result {
            Some(Info::new(a, o, d))
        } else {
            None
        }
    }
}

pub struct Instance {
    sock: UdpSocket,
    seq: u16,
}

impl Instance {
    pub const NAME: &'static str = "ntp";

    pub const SUMMARY: &'static str =
        "monitors an NTP server and reports its state";

    pub const DESCRIPTION: &'static str = include_str!("../README.md");

    // Combines and returns the first two bytes from a buffer as a
    // big-endian, 16-bit value.

    fn read_u16(buf: &[u8]) -> u16 {
        (buf[0] as u16) * 256 + (buf[1] as u16)
    }

    async fn get_synced_host(&mut self) -> Option<u16> {
        let req: [u8; 12] = [
            0x26,
            0x01,
            (self.seq / 256) as u8,
            (self.seq % 256) as u8,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
        ];

        self.seq += 1;

        // Try to send the request. If there's a failure with the
        // socket, report the error and return `None`.

        if let Err(e) = self.sock.send(&req).await {
            error!("couldn't send \"synced hosts\" request -> {}", e);
            return None;
        }

        let mut buf = [0u8; 500];

        #[rustfmt::skip]
	tokio::select! {
	    result = self.sock.recv(&mut buf) => {
		match result {
		    // The packet has to be at least 12 bytes so we
		    // can use all parts of the header without
		    // worrying about panicking.

		    Ok(len) if len < 12 => {
			warn!(
			    "response from ntpd < 12 bytes -> only {} bytes",
			    len
			)
		    }

		    Ok(len) => {
			let total = Instance::read_u16(&buf[10..=11]) as usize;
			let expected_len = total + 12 + (4 - total % 4) % 4;

			// Make sure the incoming buffer is as large
			// as the length field says it is (so we can
			// safely access the entire payload.)

			if expected_len == len {
			    for ii in buf[12..len].chunks_exact(4) {
				if (ii[2] & 0x7) == 6 {
				    return Some(Instance::read_u16(
					&ii[0..=1],
				    ));
				}
			    }
			} else {
			    warn!(
				"bad packet length -> expected {}, got {}",
				expected_len, len
			    );
			}
		    }
		    Err(e) => error!("couldn't receive data -> {}", e),
		}
	    },
	    _ = tokio::time::sleep(Duration::from_millis(1_000)) => {
		warn!("timed-out waiting for reply to \"get synced host\" request")
	    }
	}

        None
    }

    // Requests information about a given association ID. An `Info`
    // type is returned containing the parameters we find interesting.

    pub async fn get_host_info(&mut self, id: u16) -> Option<server::Info> {
        let req = &[
            0x26,
            0x02,
            (self.seq / 256) as u8,
            (self.seq % 256) as u8,
            0x00,
            0x00,
            (id / 256) as u8,
            (id % 256) as u8,
            0x00,
            0x00,
            0x00,
            0x00,
        ];

        self.seq += 1;

        if let Err(e) = self.sock.send(req).await {
            error!("couldn't send \"host info\" request -> {}", e);
            return None;
        }

        let mut buf = [0u8; 500];
        let mut payload = [0u8; 2048];
        let mut next_offset = 0;

        loop {
            #[rustfmt::skip]
	    tokio::select! {
		result = self.sock.recv(&mut buf) => {
		    match result {
			// The packet has to be at least 12 bytes so
			// we can use all parts of the header without
			// worrying about panicking.

			Ok(len) if len < 12 => {
			    warn!("response from ntpd < 12 bytes -> {}", len);
			    break;
			}

			Ok(len) => {
			    let offset = Instance::read_u16(&buf[8..=9]) as usize;

			    // We don't keep track of which of the
			    // multiple packets we've already
			    // received. Instead, we require the
			    // packets are sent in order. This warning
			    // has never been emitted.

			    if offset != next_offset {
				warn!("dropped packet (incorrect offset)");
				break;
			    }

			    let total = Instance::read_u16(&buf[10..=11]) as usize;
			    let expected_len = total + 12 + (4 - total % 4) % 4;

			    // Make sure the incoming buffer is as
			    // large as the length field says it is
			    // (so we can safely access the entire
			    // payload.)

			    if expected_len != len {
				warn!(
				    "bad packet length -> expected {}, got {}",
				    expected_len, len
				);
				break;
			    }

			    // Make sure the reply's offset and total
			    // won't push us past the end of our
			    // buffer.

			    if offset + total > payload.len() {
				warn!(
				    "payload too big (offset {}, total {}, target buf: {})",
				    offset,
				    total,
				    payload.len()
				);
				break;
			    }

			    // Update the next, expected offset.

			    next_offset += total;

			    // Copy the fragment into the final buffer.

			    let dst_range = offset..offset + total;
			    let src_range = 12..12 + total;

			    trace!(
				"copying {} bytes into {} through {}",
				dst_range.len(),
				dst_range.start,
				dst_range.end - 1
			    );

			    payload[dst_range].clone_from_slice(&buf[src_range]);

			    // If this is the last packet, we can
			    // process it. Convert the byte buffer to
			    // text and decode it.

			    if (buf[1] & 0x20) == 0 {
				let payload = &payload[..next_offset];

				return str::from_utf8(payload)
				    .ok()
				    .and_then(server::decode_info)
			    }
			}
			Err(e) => {
			    error!("couldn't receive data -> {}", e);
			    break;
			}
		    }
		},
		_ = tokio::time::sleep(Duration::from_millis(1_000)) => {
		    warn!("timed-out waiting for reply to \"get host info\" request")
		}
	    }
        }
        None
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        let loc_if = "0.0.0.0:0".parse::<SocketAddr>().unwrap();

        Span::current().record("cfg", cfg.addr.to_string());

        if let Ok(sock) = UdpSocket::bind(loc_if).await {
            if sock.connect(cfg.addr).await.is_ok() {
                return Ok(Box::new(Instance { sock, seq: 1 }));
            }
        }
        Err(Error::OperationError("couldn't create socket".to_owned()))
    }

    async fn run<'a>(
        &'a mut self,
        devices: &'a mut Self::HardwareType,
    ) -> Infallible {
        // Record the peer's address in the "cfg" field of the span.

        {
            let addr = self
                .sock
                .peer_addr()
                .map(|v| format!("{v}"))
                .unwrap_or_else(|_| String::from("**unknown**"));

            Span::current().record("cfg", addr.as_str());
        }

        // Set `info` to an initial, unmatchable value. `None` would
        // be preferrable here but, if DrMem had a problem at startup
        // getting the NTP state, it wouldn't print the warning(s).

        let mut info = Some(server::Info::bad_value());
        let mut interval = time::interval(Duration::from_millis(20_000));

        loop {
            interval.tick().await;

            if let Some(id) = self.get_synced_host().await {
                debug!("synced to host ID: {:#04x}", id);

                let host_info = self.get_host_info(id).await;

                match host_info {
                    Some(ref tmp) => {
                        if info != host_info {
                            debug!(
                                "host: {}, offset: {} ms, delay: {} ms",
                                tmp.get_host(),
                                tmp.get_offset(),
                                tmp.get_delay()
                            );
                            devices
                                .d_source
                                .report_update(tmp.get_host().clone())
                                .await;
                            devices
                                .d_offset
                                .report_update(tmp.get_offset())
                                .await;
                            devices
                                .d_delay
                                .report_update(tmp.get_delay())
                                .await;
                            devices.d_state.report_update(true).await;
                            info = host_info;
                        }
                        continue;
                    }
                    None => {
                        if info.is_some() {
                            warn!("no synced host information found");
                            info = None;
                            devices.d_state.report_update(false).await;
                        }
                    }
                }
            } else if info.is_some() {
                warn!("we're not synced to any host");
                info = None;
                devices.d_state.report_update(false).await;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::server;

    #[test]
    fn test_decoding() {
        assert_eq!(
            server::decode_info("srcadr=192.168.1.1,offset=0.0,delay=0.0"),
            Some(server::Info::new(String::from("192.168.1.1"), 0.0, 0.0))
        );
        assert_eq!(
            server::decode_info(" srcadr=192.168.1.1, offset=0.0, delay=0.0"),
            Some(server::Info::new(String::from("192.168.1.1"), 0.0, 0.0))
        );

        // Should return `None` if fields are missing.

        assert_eq!(server::decode_info(" offset=0.0, delay=0.0"), None);
        assert_eq!(server::decode_info(" srcadr=192.168.1.1, delay=0.0"), None);
        assert_eq!(
            server::decode_info(" srcadr=192.168.1.1, offset=0.0"),
            None
        );

        // Test badly formed input.

        assert!(server::decode_info("srcadr=192.168.1.1,offset=b,delay=0.0")
            .is_none());
        assert!(server::decode_info("srcadr=192.168.1.1,offset=0.0,delay=b")
            .is_none());
    }
}

---
FILE: drivers/drmem-drv-ntp/src/lib.rs
// Defines the configuration parameters for the driver.
mod config;

// Defines the device set that each instance of the driver manages.
mod device;

// The actual driver code.
mod driver;

pub use driver::Instance;

---
FILE: drivers/drmem-drv-sump/Cargo.toml
[package]
name = "drmem-drv-sump"
version = "0.7.1"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
homepage = "https://github.com/DrMemCS/drmem"
description = "DrMem driver which monitors a sump pump"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded"]
keywords = ["control-system", "automation"]

[lib]
doctest = false

[dependencies]
serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

socket2.version = "0.5"
socket2.default-features = false

toml.workspace = true
toml.default-features = false

tokio.workspace = true
tokio.default-features = false
tokio.features = ["net", "io-util", "time"]

tracing.workspace = true
tracing.default-features = false

tracing-subscriber.workspace = true
tracing-subscriber.default-features = false

drmem-api = { path = "../../drmem-api", version = "0.7" }

---
FILE: drivers/drmem-drv-sump/src/config.rs
use drmem_api::{driver::DriverConfig, Error};
use std::net::SocketAddrV4;

#[derive(serde::Deserialize)]
pub struct Params {
    pub addr: SocketAddrV4,
    pub gpm: f64,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

---
FILE: drivers/drmem-drv-sump/src/device.rs
use super::config;
use drmem_api::{
    driver::{self, Reporter, ResettableState},
    Result,
};

pub struct Set<R: Reporter> {
    pub d_service: driver::ReadOnlyDevice<bool, R>,
    pub d_state: driver::ReadOnlyDevice<bool, R>,
    pub d_duty: driver::ReadOnlyDevice<f64, R>,
    pub d_inflow: driver::ReadOnlyDevice<f64, R>,
    pub d_duration: driver::ReadOnlyDevice<f64, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.

        let d_service =
            core.add_ro_device("service", None, max_history).await?;
        let d_state = core.add_ro_device("state", None, max_history).await?;
        let d_duty = core.add_ro_device("duty", Some("%"), max_history).await?;
        let d_inflow = core
            .add_ro_device("in-flow", Some("gpm"), max_history)
            .await?;
        let d_duration = core
            .add_ro_device("duration", Some("min"), max_history)
            .await?;

        Ok(Set {
            d_service,
            d_state,
            d_duty,
            d_inflow,
            d_duration,
        })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drivers/drmem-drv-sump/src/driver.rs
use drmem_api::{
    driver::{self, Reporter},
    Error, Result,
};
use std::convert::Infallible;
use std::net::SocketAddrV4;
use tokio::{
    io::{self, AsyncReadExt},
    net::{
        tcp::{OwnedReadHalf, OwnedWriteHalf},
        TcpStream,
    },
    time::Duration,
};
use tracing::{debug, error, info, warn, Span};

use crate::{config, device};

// The sump pump monitor uses a state machine to decide when to
// calculate the duty cycle and in-flow.

#[cfg_attr(test, derive(Debug, PartialEq))]
enum State {
    Unknown,
    Off { off_time: u64 },
    On { off_time: u64, on_time: u64 },
}

// This interface allows a State value to update itself when an event
// occurs.

impl State {
    // This method is called when an off event occurs. The timestamp
    // of the off event needs to be provided. If the state machine has
    // enough information of the previous pump cycle, it will return
    // the duty cycle and in-flow rate. If the state machine is still
    // sync-ing with the state, the state will get updated, but `None`
    // will be returned.

    pub fn off_event(
        &mut self,
        stamp: u64,
        gpm: f64,
    ) -> Option<(u64, f64, f64)> {
        match *self {
            State::Unknown => {
                info!("sync-ed with OFF state");
                *self = State::Off { off_time: stamp };
                None
            }

            State::Off { .. } => {
                warn!("ignoring duplicate OFF event");
                None
            }

            State::On { off_time, on_time } => {
                // The time stamp of the OFF time should come after
                // the ON time. If it isn't, the sump pump task has a
                // problem (i.e. system time was adjusted.) We can't
                // give a decent computation, so just go into the DOWN
                // state.

                if on_time >= stamp {
                    warn!(
                        "timestamp for OFF event is {} ms ahead of ON event",
                        on_time - stamp
                    );
                    *self = State::Off { off_time: stamp };
                    return None;
                }

                let on_time = (stamp - on_time) as f64;

                // After the first storm, there was one entry that
                // glitched. The state of the motor registered "ON"
                // for 50 ms, turned off, turned on 400ms later, and
                // then stayed on for the rest of the normal,
                // six-second cycle.
                //
                // I'm going under the assumption that the pump wasn't
                // drawing enough current at the start of the cycle so
                // the current switch's detection "faded" in and out.
                // This could be due to not setting the sensitivity of
                // the switch high enough or, possibly, the pump
                // failing (once in a great while, we hear the pump go
                // through a strange-sounding cycle.)
                //
                // If the ON cycle is less than a half second, we'll
                // ignore it and stay in the ON state.

                if on_time > 500.0 {
                    let off_time = stamp - off_time;
                    let duty = on_time * 1000.0 / (off_time as f64);
                    let in_flow = (gpm * duty / 10.0).round() / 100.0;

                    *self = State::Off { off_time: stamp };
                    Some((off_time, duty.round() / 10.0, in_flow))
                } else {
                    warn!("ignoring short ON time -- {:.0} ms", on_time);
                    None
                }
            }
        }
    }

    // This method is called when updating the state with an on
    // event. The timestamp of the on event needs to be provided. If
    // the on event actually caused a state change, `true` is
    // returned.

    pub fn on_event(&mut self, stamp: u64) -> bool {
        match *self {
            State::Unknown => false,

            State::Off { off_time } => {
                // Make sure the ON time occurred *after* the OFF
                // time. This is necessary for the computations to
                // yield valid results.

                if stamp > off_time {
                    *self = State::On {
                        off_time,
                        on_time: stamp,
                    };
                    true
                } else {
                    warn!(
                        "timestamp for ON event is {} ms ahead of OFF event",
                        off_time - stamp
                    );
                    false
                }
            }

            State::On { .. } => {
                warn!("ignoring duplicate ON event");
                false
            }
        }
    }
}

pub struct Instance {
    state: State,
    gpm: f64,
    rx: OwnedReadHalf,
    _tx: OwnedWriteHalf,
}

impl Instance {
    pub const NAME: &'static str = "sump-gpio";

    pub const SUMMARY: &'static str =
        "monitors and computes parameters for a sump pump";

    pub const DESCRIPTION: &'static str = include_str!("../README.md");

    fn elapsed(millis: u64) -> String {
        match (millis + 500) / 1000 {
            dur if dur >= 3600 * 24 - 30 => {
                let dur = dur + 30;

                format!(
                    "{}d{}h{}m",
                    dur / (3600 * 24),
                    (dur / 3600) % 24,
                    (dur / 60) % 60
                )
            }
            dur if dur >= 3570 => {
                let dur = dur + 30;

                format!("{}h{}m", dur / 3600, (dur / 60) % 60)
            }
            dur if dur >= 60 => {
                format!("{}m{}s", dur / 60, dur % 60)
            }
            dur => {
                format!("{dur}s")
            }
        }
    }

    fn connect(addr: &SocketAddrV4) -> Result<TcpStream> {
        use socket2::{Domain, Socket, TcpKeepalive, Type};

        let keepalive = TcpKeepalive::new()
            .with_time(Duration::from_secs(5))
            .with_interval(Duration::from_secs(5));
        let socket = Socket::new(Domain::IPV4, Type::STREAM, None)
            .expect("couldn't create socket");

        socket
            .set_tcp_keepalive(&keepalive)
            .expect("couldn't enable keep-alive on sump socket");

        match socket.connect_timeout(
            &<SocketAddrV4 as Into<socket2::SockAddr>>::into(*addr),
            Duration::from_millis(100),
        ) {
            Ok(()) => {
                info!("connected");

                // Before we move the socket into `tokio`'s control,
                // it must be placed in non-blocking mode.

                socket
                    .set_nonblocking(true)
                    .expect("couldn't make socket nonblocking");

                TcpStream::from_std(socket.into()).map_err(|_| {
                    error!("couldn't convert to tokio::TcpStream");
                    Error::MissingPeer(String::from("sump pump"))
                })
            }
            Err(_) => {
                error!("couldn't connect to {}", addr);
                Err(Error::MissingPeer(String::from("sump pump")))
            }
        }
    }

    // This function reads the next frame from the sump pump process.
    // It either returns `Ok()` with the two fields' values or `Err()`
    // if a socket error occurred.

    async fn get_reading(&mut self) -> io::Result<(u64, bool)> {
        let stamp = self.rx.read_u64().await?;
        let value = self.rx.read_u32().await?;

        Ok((stamp, value != 0))
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        Span::current().record("cfg", cfg.addr.to_string());

        // Connect with the remote process that is connected to the
        // sump pump.

        let (rx, _tx) = Instance::connect(&cfg.addr)?.into_split();

        Ok(Box::new(Instance {
            state: State::Unknown,
            gpm: cfg.gpm,
            rx,
            _tx,
        }))
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        // Record the peer's address in the "cfg" field of the span.

        {
            let addr = self
                .rx
                .peer_addr()
                .map(|v| format!("{v}"))
                .unwrap_or_else(|_| String::from("**unknown**"));

            Span::current().record("cfg", addr.as_str());
        }

        // Set initial, default values for the devices. Pick values
        // that would make sense.

        devices.d_state.report_update(false).await;
        devices.d_duty.report_update(0.0).await;
        devices.d_inflow.report_update(0.0).await;
        devices.d_service.report_update(true).await;

        loop {
            match self.get_reading().await {
                Ok((stamp, true)) => {
                    if self.state.on_event(stamp) {
                        devices.d_state.report_update(true).await;
                    }
                }

                Ok((stamp, false)) => {
                    let gpm = self.gpm;

                    if let Some((cycle, duty, in_flow)) =
                        self.state.off_event(stamp, gpm)
                    {
                        debug!(
                            "cycle: {}, duty: {:.1}%, inflow: {:.2} gpm",
                            Instance::elapsed(cycle),
                            duty,
                            in_flow
                        );

                        devices.d_state.report_update(false).await;
                        devices.d_duty.report_update(duty).await;
                        devices.d_inflow.report_update(in_flow).await;
                        devices
                            .d_duration
                            .report_update(
                                ((cycle as f64) / 600.0).round() / 100.0,
                            )
                            .await;
                    }
                }

                Err(e) => {
                    devices.d_state.report_update(false).await;
                    devices.d_service.report_update(false).await;
                    panic!("couldn't read sump state -- {e:?}");
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_states() {
        let mut state = State::Unknown;

        assert_eq!(state.on_event(0), false);
        assert_eq!(state, State::Unknown);

        state = State::Off { off_time: 100 };

        assert_eq!(state.on_event(0), false);
        assert_eq!(state, State::Off { off_time: 100 });
        assert_eq!(state.on_event(200), true);
        assert_eq!(
            state,
            State::On {
                off_time: 100,
                on_time: 200
            }
        );

        assert_eq!(state.on_event(200), false);
        assert_eq!(
            state,
            State::On {
                off_time: 100,
                on_time: 200
            }
        );

        state = State::Unknown;

        assert_eq!(state.off_event(1000, 50.0), None);
        assert_eq!(state, State::Off { off_time: 1000 });
        assert_eq!(state.off_event(1100, 50.0), None);
        assert_eq!(state, State::Off { off_time: 1000 });

        state = State::On {
            off_time: 1000,
            on_time: 101000,
        };

        assert_eq!(state.off_event(1000, 50.0), None);
        assert_eq!(state, State::Off { off_time: 1000 });

        state = State::On {
            off_time: 1000,
            on_time: 101000,
        };

        assert_eq!(state.off_event(101500, 50.0), None);
        assert_eq!(
            state,
            State::On {
                off_time: 1000,
                on_time: 101000
            }
        );

        assert!(state.off_event(101501, 50.0).is_some());
        assert_eq!(state, State::Off { off_time: 101501 });

        state = State::On {
            off_time: 0,
            on_time: 540000,
        };

        assert_eq!(state.off_event(600000, 50.0), Some((600000, 10.0, 5.0)));
        assert_eq!(state, State::Off { off_time: 600000 });

        state = State::On {
            off_time: 0,
            on_time: 54000,
        };

        assert_eq!(state.off_event(60000, 60.0), Some((60000, 10.0, 6.0)));
        assert_eq!(state, State::Off { off_time: 60000 });
    }

    #[test]
    fn test_elapsed() {
        assert_eq!(Instance::elapsed(0), "0s");
        assert_eq!(Instance::elapsed(1000), "1s");
        assert_eq!(Instance::elapsed(59000), "59s");
        assert_eq!(Instance::elapsed(60000), "1m0s");

        assert_eq!(Instance::elapsed(3569000), "59m29s");
        assert_eq!(Instance::elapsed(3570000), "1h0m");
        assert_eq!(Instance::elapsed(3599000), "1h0m");
        assert_eq!(Instance::elapsed(3600000), "1h0m");

        assert_eq!(Instance::elapsed(3600000 * 24 - 31000), "23h59m");
        assert_eq!(Instance::elapsed(3600000 * 24 - 30000), "1d0h0m");
        assert_eq!(Instance::elapsed(3600000 * 24 - 1000), "1d0h0m");
        assert_eq!(Instance::elapsed(3600000 * 24), "1d0h0m");
    }
}

---
FILE: drivers/drmem-drv-sump/src/lib.rs
// Defines the configuration parameters for the driver.
mod config;

// Defines the device set that each instance of the driver manages.
mod device;

// The actual driver code.
mod driver;

pub use driver::Instance;

---
FILE: drivers/drmem-drv-tplink/Cargo.toml
[package]
name = "drmem-drv-tplink"
version = "0.7.1"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
homepage = "https://github.com/DrMemCS/drmem"
description = "DrMem driver for TP-Link devices"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded"]
keywords = ["control-system", "automation"]

[lib]
doctest = false

[dependencies]
toml.workspace = true
toml.default-features = false

futures.workspace = true
futures.default-features = false

tokio.workspace = true
tokio.default-features = false
tokio.features = ["net", "time", "macros", "io-util"]

tracing.workspace = true
tracing.default-features = false

tracing-subscriber.workspace = true
tracing-subscriber.default-features = false

serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

serde_json.workspace = true
serde_json.default-features = false
serde_json.features = ["std"]

drmem-api = { path = "../../drmem-api", version = "0.7" }

[dev-dependencies]
tokio.workspace = true
tokio.features = ["rt"]

---
FILE: drivers/drmem-drv-tplink/src/config.rs
use drmem_api::{driver::DriverConfig, Error};
use std::net::SocketAddrV4;

#[derive(serde::Deserialize)]
pub enum DevCfgType {
    Switch,
    Outlet,
    Dimmer,
}

#[derive(serde::Deserialize)]
pub struct Params {
    pub addr: SocketAddrV4,
    pub r#type: DevCfgType,
    pub override_timeout: Option<u64>,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

---
FILE: drivers/drmem-drv-tplink/src/device.rs
use drmem_api::{
    driver::{classes, Registrator, Reporter, RequestChan, ResettableState},
    Result,
};
use tokio::time::Duration;

use crate::config;

// An instance of a driver can be a switch, dimmer, or outlet device.
// This type specifies the device channels for the given types. The
// driver instance will have one of these variants for its device set.
pub enum Set<R: Reporter> {
    Switch(classes::Switch<R>),
    Dimmer(classes::Dimmer<R>),
}

// A set of devices must be resettable (in case the device gets
// rebooted.) This implementation simply resets the devices in the set
// used by the driver instance.
impl<R: Reporter> ResettableState for Set<R> {
    fn reset_state(&mut self) {
        match self {
            Set::Switch(dev) => {
                dev.state.reset_state();
                dev.indicator.reset_state();
            }
            Set::Dimmer(dev) => {
                dev.brightness.reset_state();
                dev.indicator.reset_state();
            }
        }
    }
}

impl<R: Reporter> Registrator<R> for Set<R> {
    type Config = config::Params;

    // Defines the registration interface for the device set.
    async fn register_devices<'a>(
        drc: &'a mut RequestChan<R>,
        cfg: &'a Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        match cfg.r#type {
            config::DevCfgType::Switch | config::DevCfgType::Outlet => {
                Ok(Set::Switch(
                    classes::Switch::register_devices(
                        drc,
                        &cfg.override_timeout
                            .map(|v| Duration::from_secs(60 * v)),
                        max_history,
                    )
                    .await?,
                ))
            }
            config::DevCfgType::Dimmer => Ok(Set::Dimmer(
                classes::Dimmer::register_devices(
                    drc,
                    &cfg.override_timeout.map(|v| Duration::from_secs(60 * v)),
                    max_history,
                )
                .await?,
            )),
        }
    }
}

---
FILE: drivers/drmem-drv-tplink/src/driver/mod.rs
// A driver to manage devices that use the TP-Link protocol. This
// protocol sends and receives JSON data over a TCP connection. Some
// sample exchanges for the HS220 dimmer:
//
//  Get status:
//
//   Sent:      {"system":{"get_sysinfo":{}}}
//   Received:  ???
//
//  Turning it on/off:
//
//   Turn on:   {"system":{"set_relay_state":{"state":1}}}
//   Turn off:  {"system":{"set_relay_state":{"state":0}}}
//   Received:  {"system":{"set_relay_state":{"err_code":0}}}
//
//  Setting the brightness to 75%:
//
//   Sent:      {"smartlife.iot.dimmer":{"set_brightness":{"brightness":75}}}
//   Received:  {"smartlife.iot.dimmer":{"set_brightness":{"err_code":0}}}
//
//  Controlling LED indicator:
//
//   Turn on:   {"system":{"set_led_off":{"off":0}}}
//   Turn off:  {"system":{"set_led_off":{"off":1}}}
//   Received:  {"system":{"set_led_off":{"err_code":0}}}
//
//  Error reply (example):
//
//   Sent:      {"system":{"set_bright":{"bright":75}}}
//   Received:  {"system":{"set_bright":{"err_code":-2,"err_msg":"member not support"}}}

use drmem_api::{
    driver::{self, classes, Reporter},
    Error, Result,
};
use futures::FutureExt;
use std::convert::Infallible;
use std::net::SocketAddrV4;
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
    task::JoinHandle,
    time::{self, Duration},
};
use tracing::{debug, error, info, Span};

use crate::{config, device};

mod tplink;

const BUF_TOTAL: usize = 4_096;

// Holds the state of the device received by an info request. Switch
// and outlet devices will always return None for the brightness.
struct DeviceState {
    indicator: Option<bool>,
    brightness: Option<f64>,
    relay: Option<bool>,
}

pub struct Instance {
    addr: SocketAddrV4,
    reported_error: Option<bool>,
    buf: [u8; BUF_TOTAL],
    poll_timeout: Duration,
}

impl Instance {
    pub const NAME: &'static str = "tplink";

    pub const SUMMARY: &'static str = "monitors and controls TP-Link devices";

    pub const DESCRIPTION: &'static str = include_str!("../../README.md");

    // Attempts to read a `tplink::Reply` type from the socket.
    // All replies have a 4-byte length header so we know how much
    // data to read.

    async fn read_reply<Rpy>(&mut self, s: &mut Rpy) -> Result<tplink::Reply>
    where
        Rpy: AsyncReadExt + std::marker::Unpin,
    {
        if let Ok(sz) = s.read_u32().await {
            let sz = sz as usize;

            if sz <= BUF_TOTAL {
                let filled = &mut self.buf[0..sz];

                if let Err(e) = s.read_exact(filled).await {
                    Err(Error::MissingPeer(e.to_string()))
                } else {
                    tplink::Reply::decode(filled).ok_or_else(|| {
                        Error::ParseError(format!(
                            "bad reply : {}",
                            String::from_utf8_lossy(filled)
                        ))
                    })
                }
            } else {
                Err(Error::ParseError(format!(
                    "reply size ({sz}) is greater than {BUF_TOTAL}"
                )))
            }
        } else {
            Err(Error::MissingPeer("error reading header".into()))
        }
    }

    // Attempts to send a command to the socket.

    async fn send_cmd<S>(s: &mut S, cmd: tplink::Cmd) -> Result<()>
    where
        S: AsyncWriteExt + std::marker::Unpin,
    {
        const ERR_F: fn(std::io::Error) -> Error =
            |e| Error::MissingPeer(e.to_string());
        let out_buf = cmd.encode();

        #[rustfmt::skip]
	tokio::select! {
	    result = s.write_all(&out_buf[..]) => {
		match result {
		    Ok(_) => s.flush().await.map_err(ERR_F),
		    Err(e) => Err(ERR_F(e))
		}
	    }
	    _ = time::sleep(Duration::from_millis(500)) =>
		Err(Error::TimeoutError)
	}
    }

    // Performs an "RPC" call to the device; it sends the command and
    // returns the reply.

    async fn rpc<R, S>(
        &mut self,
        rx: &mut R,
        tx: &mut S,
        cmd: tplink::Cmd,
    ) -> Result<tplink::Reply>
    where
        R: AsyncReadExt + std::marker::Unpin,
        S: AsyncWriteExt + std::marker::Unpin,
    {
        Instance::send_cmd(tx, cmd)
            .then(|res| async {
                match res {
                    Ok(()) => {
                        #[rustfmt::skip]
			tokio::select! {
			    result = self.read_reply(rx) => result,
			    _ = time::sleep(Duration::from_millis(500)) =>
				Err(Error::TimeoutError)
			}
                    }
                    Err(e) => Err(e),
                }
            })
            .await
    }

    // Sets the relay state on or off, depending on the argument.

    async fn relay_state_rpc(
        &mut self,
        s: &mut TcpStream,
        v: bool,
    ) -> Result<()> {
        use tplink::{Cmd, ErrorStatus, Reply};

        let (mut rx, mut tx) = s.split();

        match self
            .rpc(&mut rx, &mut tx, Cmd::mk_active_cmd(v as u8))
            .await?
        {
            Reply::System {
                set_relay_state: Some(ErrorStatus { err_code: 0, .. }),
                ..
            } => Ok(()),

            Reply::System {
                set_relay_state:
                    Some(ErrorStatus {
                        err_msg: Some(em), ..
                    }),
                ..
            } => Err(Error::ProtocolError(em)),

            reply => Err(Error::ProtocolError(format!(
                "unexpected reply : {:?}",
                &reply
            ))),
        }
    }

    // Sets the LED state on or off, depending on the argument.

    async fn led_state_rpc(
        &mut self,
        s: &mut TcpStream,
        v: bool,
    ) -> Result<()> {
        use tplink::{Cmd, ErrorStatus, Reply};

        let (mut rx, mut tx) = s.split();

        // Send the request and receive the reply. Use pattern
        // matching to determine the return value of the function.

        match self.rpc(&mut rx, &mut tx, Cmd::mk_led_cmd(v)).await? {
            Reply::System {
                set_led_off: Some(ErrorStatus { err_code: 0, .. }),
                ..
            } => Ok(()),

            Reply::System {
                set_led_off:
                    Some(ErrorStatus {
                        err_msg: Some(em), ..
                    }),
                ..
            } => Err(Error::ProtocolError(em)),

            reply => Err(Error::ProtocolError(format!(
                "unexpected reply : {:?}",
                &reply
            ))),
        }
    }

    // Retrieves info.

    async fn info_rpc(&mut self, s: &mut TcpStream) -> Result<DeviceState> {
        use tplink::{Cmd, Reply};

        let (mut rx, mut tx) = s.split();

        // Send the request and receive the reply. Use pattern
        // matching to determine the return value of the function.

        match self.rpc(&mut rx, &mut tx, Cmd::mk_info_cmd()).await? {
            Reply::System {
                get_sysinfo: Some(info),
                ..
            } => {
                let indicator = info.led_off.unwrap_or(1) == 0;

                match (info.relay_state.map(|v| v != 0), info.brightness) {
                    (None, None) => Ok(DeviceState {
                        indicator: Some(indicator),
                        relay: None,
                        brightness: Some(0.0),
                    }),
                    (None, Some(_)) => Ok(DeviceState {
                        indicator: Some(indicator),
                        relay: None,
                        brightness: Some(0.0),
                    }),
                    (rs @ Some(false), _) => Ok(DeviceState {
                        indicator: Some(indicator),
                        relay: rs,
                        brightness: Some(0.0),
                    }),
                    (rs @ Some(true), br) => Ok(DeviceState {
                        indicator: Some(indicator),
                        relay: rs,
                        brightness: Some(br.unwrap_or(100).into()),
                    }),
                }
            }

            reply => Err(Error::ProtocolError(format!(
                "unexpected reply : {:?}",
                &reply
            ))),
        }
    }

    // Sets the brightness between 0 and 100, depending on the
    // argument.

    async fn brightness_rpc(&mut self, s: &mut TcpStream, v: u8) -> Result<()> {
        use tplink::{Cmd, ErrorStatus, Reply};

        let (mut rx, mut tx) = s.split();

        match self
            .rpc(&mut rx, &mut tx, Cmd::mk_brightness_cmd(v))
            .await?
        {
            Reply::Dimmer {
                set_brightness: Some(ErrorStatus { err_code: 0, .. }),
                ..
            } => Ok(()),

            Reply::Dimmer {
                set_brightness:
                    Some(ErrorStatus {
                        err_msg: Some(em), ..
                    }),
                ..
            } => Err(Error::ProtocolError(em)),

            reply => Err(Error::ProtocolError(format!(
                "unexpected reply : {:?}",
                &reply
            ))),
        }
    }

    // Sends commands to change the brightness. NOTE: This function
    // assumes `v` is in the range 0.0..=100.0.

    async fn set_brightness(
        &mut self,
        s: &mut TcpStream,
        v: f64,
    ) -> Result<()> {
        // If the brightness is zero, we turn off the dimmer instead
        // of setting the brightness to 0.0. If it's greater than 0.0,
        // set the brightness and then turn on the dimmer.

        if v > 0.0 {
            self.brightness_rpc(s, v as u8).await?;
            self.relay_state_rpc(s, true).await
        } else {
            self.relay_state_rpc(s, false).await
        }
    }

    // Connects to the address. Sets a timeout of 1 second for the
    // connection.

    async fn connect(addr: SocketAddrV4) -> Result<TcpStream> {
        use tokio::{net::TcpSocket, time};

        loop {
            match TcpSocket::new_v4() {
                Ok(s) => {
                    s.set_recv_buffer_size((BUF_TOTAL * 2) as u32).map_err(
                        |e| {
                            Error::OperationError(format!(
                                "couldn't set socket's buffer size -- {}",
                                e
                            ))
                        },
                    )?;
                    s.set_nodelay(true).map_err(|e| {
                        Error::OperationError(format!(
                            "couldn't set NO DELAY on socket -- {}",
                            e
                        ))
                    })?;

                    if let Ok(Ok(s)) = time::timeout(
                        Duration::from_secs(2),
                        s.connect(addr.into()),
                    )
                    .await
                    {
                        return Ok(s);
                    }
                    time::sleep(time::Duration::from_secs(60)).await
                }
                Err(e) => {
                    return Err(Error::OperationError(format!(
                        "couldn't create socket -- {}",
                        e
                    )))
                }
            }
        }
    }

    // Handles incoming settings for brightness.

    async fn handle_brightness_setting(
        &mut self,
        s: &mut TcpStream,
        v: f64,
        reply: Option<driver::SettingResponder<f64>>,
    ) -> Result<()> {
        if !v.is_nan() {
            // Clip incoming settings to the range 0.0..=100.0. Handle
            // infinities, too.

            let v = match v {
                v if v == f64::INFINITY => 100.0,
                v if v == f64::NEG_INFINITY => 0.0,
                v if v < 0.0 => 0.0,
                v if v > 100.0 => 100.0,
                v => v,
            };

            // Send an OK reply to the client with the updated value.

            if let Some(reply) = reply {
                reply.ok(v);
            }

            // Always log incoming settings. Let the client know there
            // was a successful setting, and include the value that
            // was used.

            self.set_brightness(s, v).await
        } else {
            if let Some(reply) = reply {
                reply.err(Error::InvArgument(
                    "device doesn't accept NaN".into(),
                ));
            }
            Ok(())
        }
    }

    // Handles incoming settings for controlling the LED indicator.

    async fn handle_led_setting(
        &mut self,
        s: &mut TcpStream,
        v: bool,
        reply: Option<driver::SettingResponder<bool>>,
    ) -> Result<()> {
        if let Some(reply) = reply {
            reply.ok(v);
        }
        self.led_state_rpc(s, v).await
    }

    // Checks to see if the current error state ('value') matches the
    // previosuly reported error state. If not, it saves the current
    // state and sends the updated value to the backend.

    async fn sync_error_state<R: Reporter>(
        &mut self,
        dev: &mut device::Set<R>,
        value: bool,
    ) {
        if self.reported_error != Some(value) {
            self.reported_error = Some(value);
            match dev {
                device::Set::Switch(classes::Switch { error, .. }) => {
                    error.report_update(value).await
                }
                device::Set::Dimmer(classes::Dimmer { error, .. }) => {
                    error.report_update(value).await
                }
            }
        }
    }

    async fn pause_as_dimmer<R: Reporter>(
        &mut self,
        dev: &mut classes::Dimmer<R>,
    ) {
        let classes::Dimmer {
            brightness: ref mut d_b,
            indicator: ref mut d_i,
            ..
        } = dev;

        let timeout = time::sleep(Duration::from_secs(60));
        tokio::pin!(timeout);

        loop {
            #[rustfmt::skip]
            tokio::select! {
                _ = &mut timeout => {
                    break;
                }
                Some((v, reply)) = d_b.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
                Some((v, reply)) = d_i.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
            }
        }
    }

    async fn pause_as_switch<R: Reporter>(
        &mut self,
        dev: &mut classes::Switch<R>,
    ) {
        let classes::Switch {
            state: ref mut d_r,
            indicator: ref mut d_i,
            ..
        } = dev;

        let timeout = time::sleep(Duration::from_secs(60));
        tokio::pin!(timeout);

        loop {
            #[rustfmt::skip]
            tokio::select! {
                _ = &mut timeout => {
                    break;
                }
                Some((v, reply)) = d_r.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
                Some((v, reply)) = d_i.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
            }
        }
    }

    async fn manage_connect_as_switch<R: Reporter>(
        &mut self,
        task: JoinHandle<Result<TcpStream>>,
        dev: &mut classes::Switch<R>,
    ) -> Result<TcpStream> {
        let classes::Switch {
            state: ref mut d_r,
            indicator: ref mut d_i,
            ..
        } = dev;

        tokio::pin!(task);

        loop {
            #[rustfmt::skip]
            tokio::select! {
                task_result = &mut task => {
                    match task_result {
                        Ok(result) => return result,
                        Err(e) => {
                            return Err(Error::OperationError(format!(
                                "driver panicked while connecting -- {}",
                                e
                            )))
                        }
                    }
                }
                Some((v, reply)) = d_r.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
                Some((v, reply)) = d_i.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
            }
        }
    }

    async fn manage_connect_as_dimmer<R: Reporter>(
        &mut self,
        task: JoinHandle<Result<TcpStream>>,
        dev: &mut classes::Dimmer<R>,
    ) -> Result<TcpStream> {
        let classes::Dimmer {
            brightness: ref mut d_b,
            indicator: ref mut d_i,
            ..
        } = dev;

        tokio::pin!(task);

        loop {
            #[rustfmt::skip]
            tokio::select! {
                task_result = &mut task => {
                    match task_result {
                        Ok(result) => return result,
                        Err(e) => {
                            return Err(Error::OperationError(format!(
                                "driver panicked while connecting -- {}",
                                e
                            )))
                        }
                    }
                }
                Some((v, reply)) = d_b.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
                Some((v, reply)) = d_i.next_setting() => {
                    if let Some(reply) = reply {
                        reply.ok(v);
                    }
                }
            }
        }
    }

    async fn manage_switch<R: Reporter>(
        &mut self,
        s: &mut TcpStream,
        dev: &mut classes::Switch<R>,
    ) -> bool {
        // Get mutable references to the setting channels.

        let classes::Switch {
            state: ref mut d_r,
            indicator: ref mut d_i,
            ..
        } = dev;

        // Now wait for one of three events to occur.

        #[rustfmt::skip]
        tokio::select! {
            // If our poll timeout expires, we need to request the
            // current state of the hardware (because it could be
            // changed by external apps or a person using the manual
            // switch.)

            _ = tokio::time::sleep(self.poll_timeout) => {

                // Reset the next timeout to be 5 seconds.

                self.poll_timeout = Duration::from_secs(5);

                // Request the hardware state.

                match self.info_rpc(s).await {
                    Ok(info) => {
                        if let Some(indicator) = info.indicator {
                            d_i.report_update(indicator).await
                        }

                        if let Some(relay) = info.relay {
                            d_r.report_update(relay).await
                        }
                    }
                    Err(e) => {
                        error!("error getting state -- {e}");
                        return false
                    }
                }
            }

	    // Handle settings to the brightness device.

            Some((v, reply)) = d_r.next_setting() => {
                if let Some(reply) = reply {
                    reply.ok(v);
                }
                if let Err(e) = self.relay_state_rpc(s, v).await {
                    error!("couldn't set relay state -- {e}");
		    return false
		};
                self.poll_timeout = Duration::from_secs(0);
            }

	    // Handle settings to the LED indicator device.

            Some((v, reply)) = d_i.next_setting() => {
		debug!("led setting -> {}", &v);
                if let Err(e) = self.handle_led_setting(s, v, reply).await {
                    error!("couldn't set indicator -- {e}");
		    return false
		}
                self.poll_timeout = Duration::from_secs(0);
            }
        }
        true
    }

    async fn manage_dimmer<R: Reporter>(
        &mut self,
        s: &mut TcpStream,
        dev: &mut classes::Dimmer<R>,
    ) -> bool {
        // Get mutable references to the setting channels.

        let classes::Dimmer {
            brightness: ref mut d_b,
            indicator: ref mut d_i,
            ..
        } = dev;

        // Now wait for one of three events to occur.

        #[rustfmt::skip]
        tokio::select! {
            // If our poll timeout expires, we need to request the
            // current state of the hardware (because it could be
            // changed by external apps or a person using the manual
            // switch.)

            _ = tokio::time::sleep(self.poll_timeout) => {

                // Reset the next timeout to be 5 seconds.

                self.poll_timeout = Duration::from_secs(5);

                // Request the hardware state.

                match self.info_rpc(s).await {
                    Ok(info) => {
                        if let Some(indicator) = info.indicator {
                            d_i.report_update(indicator).await
                        }

                        if let Some(brightness) = info.brightness {
                            d_b.report_update(brightness).await
                        }
                    }
                    Err(e) => {
                        error!("error getting state -- {e}");
                        return false
                    }
                }
            }

	    // Handle settings to the brightness device.

            Some((v, reply)) = d_b.next_setting() => {
                if let Err(e) = self.handle_brightness_setting(s, v, reply).await {
                    error!("couldn't set brightness -- {e}");
		    return false
		};
                self.poll_timeout = Duration::from_secs(0);
            }

	    // Handle settings to the LED indicator device.

            Some((v, reply)) = d_i.next_setting() => {
		debug!("led setting -> {}", &v);
                if let Err(e) = self.handle_led_setting(s, v, reply).await {
                    error!("couldn't set indicator -- {e}");
		    return false
		}
                self.poll_timeout = Duration::from_secs(0);
            }
        }
        true
    }

    async fn main_loop<R: Reporter>(
        &mut self,
        mut s: TcpStream,
        devices: &mut <Instance as driver::API<R>>::HardwareType,
    ) {
        self.sync_error_state(&mut *devices, false).await;
        loop {
            if !match &mut *devices {
                device::Set::Switch(dev) => {
                    self.manage_switch(&mut s, dev).await
                }
                device::Set::Dimmer(dev) => {
                    self.manage_dimmer(&mut s, dev).await
                }
            } {
                break;
            }
        }
        self.sync_error_state(&mut *devices, true).await;
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    // This driver doesn't store any data in its instance; it's all
    // stored in local variables in the `.run()` method.

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        Ok(Box::new(Instance {
            addr: cfg.addr,
            reported_error: None,
            buf: [0; BUF_TOTAL],
            poll_timeout: Duration::from_secs(0),
        }))
    }

    // Main run loop for the driver.

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        // Record the devices's address in the "cfg" field of the
        // span.

        Span::current().record("cfg", self.addr.to_string());
        self.sync_error_state(&mut *devices, true).await;
        loop {
            info!("connecting to hardware at {}", &self.addr);

            let conn_task = tokio::spawn(Instance::connect(self.addr));
            let conn_result = match &mut *devices {
                device::Set::Switch(ref mut dev) => {
                    self.manage_connect_as_switch(conn_task, dev).await
                }
                device::Set::Dimmer(ref mut dev) => {
                    self.manage_connect_as_dimmer(conn_task, dev).await
                }
            };

            match conn_result {
                Ok(s) => self.main_loop(s, devices).await,
                Err(e) => error!("connection failed -- {}", e),
            }

            // Log the error and then sleep for 60 seconds. Hopefully
            // the device will be available then.

            match &mut *devices {
                device::Set::Switch(ref mut dev) => {
                    self.pause_as_switch(dev).await
                }
                device::Set::Dimmer(ref mut dev) => {
                    self.pause_as_dimmer(dev).await
                }
            };
        }
    }
}

#[cfg(test)]
mod test {
    use super::{tplink, Instance};
    use crate::driver::BUF_TOTAL;
    use std::net::{Ipv4Addr, SocketAddrV4};
    use tokio::time::Duration;

    #[tokio::test]
    async fn test_read_reply() {
        // Make sure packets with less than 4 bytes causes an error.

        {
            let buf: &[u8] = &[0, 0, 0];
            let mut inst = Instance {
                addr: SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0),
                reported_error: None,
                buf: [0u8; BUF_TOTAL],
                poll_timeout: Duration::from_secs(5),
            };

            assert!(inst.read_reply(&mut &buf[0..=0]).await.is_err());
            assert!(inst.read_reply(&mut &buf[0..1]).await.is_err());
            assert!(inst.read_reply(&mut &buf[0..2]).await.is_err());
            assert!(inst.read_reply(&mut &buf[0..3]).await.is_err());
        }

        {
            const REPLY: &[u8] =
                b"{\"system\":{\"set_led_off\":{\"err_code\":0}}}";

            let mut buf = vec![0, 0, 0, REPLY.len() as u8];

            buf.extend_from_slice(&REPLY[..]);
            tplink::crypt::encode(&mut buf[4..]);

            assert!(buf.len() == 45);
            assert!(buf.as_slice().len() == 45);

            let mut inst = Instance {
                addr: SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0),
                reported_error: None,
                buf: [0u8; BUF_TOTAL],
                poll_timeout: Duration::from_secs(5),
            };

            assert!(inst.read_reply(&mut &buf[0..4]).await.is_err());
            assert!(inst.read_reply(&mut &buf[0..5]).await.is_err());
            assert!(inst.read_reply(&mut buf.as_slice()).await.is_ok());
        }
    }
}

---
FILE: drivers/drmem-drv-tplink/src/driver/tplink/cmd.rs
use super::crypt;
use serde::Serialize;

// This module holds the types that represent values used in the
// request fields.

pub mod value {
    use serde::Serialize;

    // Defines the internal value used by the `set_relay_state`
    // command. Needs to convert to `{"state":value}`.

    #[derive(Serialize, PartialEq, Debug)]
    pub struct Active {
        pub state: u8,
    }

    // Defines the internal value used by the `set_led_off`
    // command. Needs to convert to `{"off":value}`.

    #[derive(Serialize, PartialEq, Debug)]
    pub struct Led {
        pub off: u8,
    }

    // Defines the internal value used by the `get_sysinfo`
    // command. Needs to convert to `{}`.

    #[derive(Serialize, PartialEq, Debug)]
    pub struct Info {}

    // Defines the internal value used by the `Brightness`
    // command. Needs to convert to `{"brightness":value}`.

    #[derive(Serialize, PartialEq, Debug)]
    pub struct Brightness {
        pub brightness: u8,
    }
}

#[derive(Serialize, PartialEq, Debug)]
pub enum Cmd {
    #[serde(rename = "system")]
    System {
        #[serde(skip_serializing_if = "Option::is_none")]
        set_relay_state: Option<value::Active>,
        #[serde(skip_serializing_if = "Option::is_none")]
        get_sysinfo: Option<value::Info>,
        #[serde(skip_serializing_if = "Option::is_none")]
        set_led_off: Option<value::Led>,
    },

    #[serde(rename = "smartlife.iot.dimmer")]
    Dimmer { set_brightness: value::Brightness },
}

impl Cmd {
    pub fn encode(&self) -> Vec<u8> {
        let mut buf = Vec::with_capacity(100);

        buf.push(0u8);
        buf.push(0u8);
        buf.push(0u8);
        buf.push(0u8);

        serde_json::to_writer(&mut buf, &self).unwrap();

        let sz = buf.len() - 4;

        buf[0] = (sz >> 24) as u8;
        buf[1] = (sz >> 16) as u8;
        buf[2] = (sz >> 8) as u8;
        buf[3] = sz as u8;

        crypt::encode(&mut buf[4..]);

        buf
    }

    pub fn mk_active_cmd(v: u8) -> Self {
        Self::System {
            set_relay_state: Some(value::Active { state: v }),
            get_sysinfo: None,
            set_led_off: None,
        }
    }

    pub fn mk_brightness_cmd(v: u8) -> Self {
        Self::Dimmer {
            set_brightness: value::Brightness { brightness: v },
        }
    }

    pub fn mk_info_cmd() -> Self {
        Self::System {
            set_relay_state: None,
            get_sysinfo: Some(value::Info {}),
            set_led_off: None,
        }
    }

    pub fn mk_led_cmd(v: bool) -> Self {
        Self::System {
            set_relay_state: None,
            get_sysinfo: None,
            set_led_off: Some(value::Led { off: (!v) as u8 }),
        }
    }
}

---
FILE: drivers/drmem-drv-tplink/src/driver/tplink/crypt.rs
// This is the decryption algorithm used by TP-Link.

pub fn decode(buf: &mut [u8]) {
    let mut key = 171u8;

    for b in buf.iter_mut() {
        let tmp = *b;

        *b ^= key;
        key = tmp;
    }
}

// This is the encryption algorithm used by TP-Link.

pub fn encode(buf: &mut [u8]) {
    let mut key = 171u8;

    for b in buf.iter_mut() {
        key ^= *b;
        *b = key;
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_crypt() {
        let buf = [1u8, 2u8, 3u8, 4u8, 5u8];
        let mut enc = vec![];

        enc.extend_from_slice(&buf);
        encode(&mut enc);
        decode(&mut enc);
        assert_eq!(&buf, &enc[..]);
    }
}

---
FILE: drivers/drmem-drv-tplink/src/driver/tplink/mod.rs
// This module defines the commands that can be sent to the TP-Link
// device. It also configures the `serde` crate so these commands are
// converted to the expected JSON layout.

use serde::Deserialize;

mod cmd;
pub mod crypt;

pub use cmd::Cmd;

#[derive(Deserialize, PartialEq, Debug)]
pub struct ErrorStatus {
    pub err_code: i32,
    pub err_msg: Option<String>,
}

#[derive(Deserialize, PartialEq, Debug)]
pub struct InfoReply {
    pub sw_ver: String,
    pub hw_ver: String,
    pub model: String,
    #[serde(rename = "deviceId")]
    pub device_id: String,
    #[serde(rename = "oemId")]
    pub oem_id: String,
    #[serde(rename = "hwId")]
    pub hw_id: String,
    pub updating: Option<u8>,
    pub led_off: Option<u8>,
    pub relay_state: Option<u8>,
    pub brightness: Option<u8>,
    pub err_code: i32,
}

// This type models a subset of the replies that are returned by the
// device (only define the replies that come from commands we send.)

#[derive(Deserialize, PartialEq, Debug)]
pub enum Reply {
    #[serde(rename = "system")]
    System {
        set_relay_state: Option<ErrorStatus>,
        set_led_off: Option<ErrorStatus>,
        get_sysinfo: Option<InfoReply>,
    },

    #[serde(rename = "smartlife.iot.dimmer")]
    Dimmer { set_brightness: Option<ErrorStatus> },
}

impl Reply {
    pub fn decode(buf: &mut [u8]) -> Option<Reply> {
        crypt::decode(buf);
        serde_json::from_slice(buf).ok()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_cmds() {
        assert_eq!(
            serde_json::to_string(&Cmd::mk_active_cmd(1)).unwrap(),
            "{\"system\":{\"set_relay_state\":{\"state\":1}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_led_cmd(false)).unwrap(),
            "{\"system\":{\"set_led_off\":{\"off\":1}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_led_cmd(true)).unwrap(),
            "{\"system\":{\"set_led_off\":{\"off\":0}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_info_cmd()).unwrap(),
            "{\"system\":{\"get_sysinfo\":{}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_brightness_cmd(0)).unwrap(),
            "{\"smartlife.iot.dimmer\":{\"set_brightness\":{\"brightness\":0}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_brightness_cmd(50)).unwrap(),
            "{\"smartlife.iot.dimmer\":{\"set_brightness\":{\"brightness\":50}}}"
        );
        assert_eq!(
            serde_json::to_string(&Cmd::mk_brightness_cmd(100)).unwrap(),
            "{\"smartlife.iot.dimmer\":{\"set_brightness\":{\"brightness\":100}}}"
        );
    }

    #[test]
    fn test_replies() {
        assert!(serde_json::from_str::<Reply>("").is_err());

        assert_eq!(
            serde_json::from_str::<Reply>(
                r#"{"system":{"set_relay_state":{"err_code":0}}}"#
            )
            .unwrap(),
            Reply::System {
                set_relay_state: Some(ErrorStatus {
                    err_code: 0,
                    err_msg: None
                }),
                set_led_off: None,
                get_sysinfo: None
            }
        );
        assert_eq!(
            serde_json::from_str::<Reply>(
                r#"{"system":{"set_led_off":{"err_code":0}}}"#
            )
            .unwrap(),
            Reply::System {
                set_relay_state: None,
                set_led_off: Some(ErrorStatus {
                    err_code: 0,
                    err_msg: None
                }),
                get_sysinfo: None
            }
        );
        assert_eq!(
            serde_json::from_str::<Reply>(
                r#"{"smartlife.iot.dimmer":{"set_brightness":{"err_code":0}}}"#
            )
            .unwrap(),
            Reply::Dimmer {
                set_brightness: Some(ErrorStatus {
                    err_code: 0,
                    err_msg: None
                }),
            }
        );
        assert_eq!(
            serde_json::from_str::<Reply>(
                r#"{"system":{"get_sysinfo":{"sw_ver":"1.0.3 Build 210202 Rel.190636","hw_ver":"3.0","model":"HS220(US)","deviceId":"1234","oemId":"5678","hwId":"9999","rssi":-32,"latitude_i":90,"longitude_i":0,"alias":"Front Porch","status":"new","mic_type":"IOT.SMARTPLUGSWITCH","feature":"TIM","mac":"AA:AA:AA:AA:AA:AA","updating":0,"led_off":0,"relay_state":0,"brightness":50,"on_time":0,"icon_hash":"","dev_name":"Wi-Fi Smart Dimmer","active_mode":"none","next_action":{"type":-1},"preferred_state":[{"index":0,"brightness":100},{"index":1,"brightness":75},{"index":2,"brightness":50},{"index":3,"brightness":25}],"ntc_state":0,"err_code":0}}}"#
            )
            .unwrap(),
            Reply::System {
                set_relay_state: None,
                set_led_off: None,
                get_sysinfo: Some(InfoReply {
		    sw_ver: "1.0.3 Build 210202 Rel.190636".into(),
		    hw_ver: "3.0".into(),
		    model: "HS220(US)".into(),
		    device_id: "1234".into(),
		    oem_id: "5678".into(),
		    hw_id: "9999".into(),
		    updating: Some(0),
		    led_off: Some(0),
		    relay_state: Some(0),
		    brightness: Some(50),
		    err_code: 0,
		})
            }
        );
    }
}

---
FILE: drivers/drmem-drv-tplink/src/lib.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drivers/drmem-drv-weather-wu/Cargo.toml
[package]
name = "drmem-drv-weather-wu"
version = "0.7.1"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
homepage = "https://github.com/DrMemCS/drmem"
description = "DrMem driver which gets Weather Underground data"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded"]
keywords = ["control-system", "automation"]

[lib]
doctest = false

[dependencies]
serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

toml.workspace = true
toml.default-features = false

tokio.workspace = true
tokio.default-features = false

tracing.workspace = true
tracing.default-features = false

tracing-subscriber.workspace = true
tracing-subscriber.default-features = false

reqwest.version = "0.11"
reqwest.default-features = false

weather-underground.version = "0.1"
weather-underground.default-features = false

drmem-api = { path = "../../drmem-api", version = "0.7" }

---
FILE: drivers/drmem-drv-weather-wu/src/config.rs
use drmem_api::{
    driver::{classes, DriverConfig},
    Error,
};
use std::convert::TryFrom;

#[derive(serde::Deserialize)]
pub struct Params {
    pub api_key: Option<String>,
    pub station: String,
    pub interval: Option<u64>,
    pub units: classes::WeatherUnits,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

---
FILE: drivers/drmem-drv-weather-wu/src/device.rs
use drmem_api::{
    driver::{classes, Registrator, Reporter, RequestChan, ResettableState},
    Result,
};

use crate::config;

pub struct Set<R: Reporter>(pub classes::Weather<R>);

impl<R: Reporter> Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        drc: &mut RequestChan<R>,
        cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        Ok(Set(classes::Weather::register_devices(
            drc,
            &classes::WeatherConfig {
                units: cfg.units.clone(),
            },
            max_history,
        )
        .await?))
    }
}

impl<R: Reporter> ResettableState for Set<R> {
    fn reset_state(&mut self) {
        self.0.reset_state()
    }
}

---
FILE: drivers/drmem-drv-weather-wu/src/driver.rs
use drmem_api::{
    driver::{self, classes, Reporter},
    Error, Result,
};
use std::convert::{Infallible, TryFrom};
use std::time::SystemTime;
use tokio::time::{interval_at, Duration, Instant};
use tracing::{debug, error, warn, Span};
use weather_underground as wu;

use crate::{config, device};

const DEFAULT_INTERVAL: u64 = 10;
const MIN_PUBLIC_INTERVAL: u64 = 10;

// This type defines a mini state machine to help us accumulate
// rainfall. Some weather stations reset their rainfall total at
// midnight -- even if it's still raining! This state machine tries to
// recognize those resets to properly maintain its local precip
// totals.

enum PrecipState {
    NoRain,
    Rain {
        prev: f64,
        running: f64,
        time: SystemTime,
    },
    Pause {
        prev: f64,
    },
}

impl PrecipState {
    fn new() -> Self {
        PrecipState::NoRain
    }

    // This method updates the state of the data based on new
    // readings. It returns values to be reported by the driver for
    // the three precip devices.

    fn update(
        &mut self,
        p_rate: f64,
        p_total: f64,
        now: SystemTime,
    ) -> (f64, f64, Option<f64>) {
        match self {
            // This state models when it isn't raining. It's the
            // initial state and it will be re-entered when the
            // weather station reports no rain.
            Self::NoRain => {
                // If there's a non-zero total, we need to switch to
                // the rain state.

                if p_total > 0.0 {
                    *self = Self::Rain {
                        prev: p_total,
                        running: p_total,
                        time: now,
                    };
                }
                (p_rate, p_total, None)
            }

            // This state is active after the 10 hour time between
            // rainfall has occurred, but the weather station is still
            // reporting a non-zero precip total.
            Self::Pause { prev } => {
                (
                    p_rate,
                    // If the weather station resets its total, we can
                    // go back to the `NoRain` state.
                    if p_total == 0.0 {
                        if p_rate == 0.0 {
                            *self = Self::NoRain;
                        }
                        0.0
                    }
                    // If more rain is reported, then a new system has
                    // rolled in. Go back to the `Rain` state, but set
                    // the currently reported total as the baseline
                    // with which to subtract future readings.
                    else if p_total > *prev {
                        let total = p_total - *prev;

                        *self = Self::Rain {
                            prev: p_total,
                            running: total,
                            time: now,
                        };
                        total
                    }
                    // The total is less than the previous, but not
                    // 0. This means we crossed midnight -- resetting
                    // the total -- but more rain occurred before we
                    // sampled the data. Go into the `Rain` state.
                    else if p_total < *prev {
                        *self = Self::Rain {
                            prev: p_total,
                            running: p_total,
                            time: now,
                        };
                        p_total
                    } else {
                        0.0
                    },
                    None,
                )
            }

            // This state is active while it is raining.
            Self::Rain {
                prev,
                running,
                time,
            } => {
                const TIMEOUT: Duration = Duration::from_secs(36_000);
                let delta = now
                    .duration_since(*time)
                    .unwrap_or_else(|_| Duration::from_secs(0));

                // If the weather station reports no rainfall and
                // reset its total, we emit the total as the value of
                // the last rainfall.

                if p_rate == 0.0 && delta >= TIMEOUT {
                    let last_total = *running;

                    *self = Self::Pause { prev: *prev };
                    (0.0, 0.0, Some(last_total))
                } else {
                    // If the total is less than the previous value,
                    // then we crossed midnight. Just use the reset
                    // value as the delta.

                    *running += if *prev > p_total {
                        p_total
                    } else {
                        p_total - *prev
                    };

                    // If the rainfall rate is 0, don't update the
                    // timeout value.

                    if p_rate > 0.0 {
                        *time = now;
                    }

                    // Update the totals in the state.

                    *prev = p_total;
                    (p_rate, *running, None)
                }
            }
        }
    }
}

pub struct Instance {
    con: reqwest::Client,
    api_key: String,
    interval: Duration,
    station: String,

    precip: PrecipState,
}

impl Instance {
    pub const NAME: &'static str = "weather-wu";

    pub const SUMMARY: &'static str =
        "obtains weather data from Weather Underground";

    pub const DESCRIPTION: &'static str = include_str!("../README.md");

    async fn get_cfg_key_and_interval(
        con: &mut reqwest::Client,
        key: Option<String>,
        interval: u64,
    ) -> Result<(String, Duration)> {
        match key {
            Some(val) => Ok((val, Duration::from_secs(interval * 60))),
            None => {
                if let Ok(api_key) = wu::fetch_api_key(con).await {
                    Ok((
                        api_key,
                        Duration::from_secs(
                            std::cmp::max(interval, MIN_PUBLIC_INTERVAL) * 60,
                        ),
                    ))
                } else {
                    error!("couldn't determine public API key");
                    Err(Error::NotFound)
                }
            }
        }
    }

    // Processes an observation by sending each parameter to the
    // correct device channel. It also does some sanity checks on the
    // values.

    async fn handle<R: Reporter>(
        &mut self,
        obs: &wu::Observation,
        devices: &mut <Self as driver::API<R>>::HardwareType,
    ) {
        // Retreive all the parameters whose units can change between
        // English and Metric.

        let (dewpt, htidx, prate, ptotal, press, temp, wndchl, wndgst, wndspd) =
            if let classes::WeatherUnits::Metric = devices.0.units {
                if let Some(params) = &obs.metric {
                    (
                        params.dewpt,
                        params.heat_index,
                        params.precip_rate,
                        params.precip_total,
                        params.pressure,
                        params.temp,
                        params.wind_chill,
                        params.wind_gust,
                        params.wind_speed,
                    )
                } else {
                    panic!("weather data didn't return any metric data")
                }
            } else if let Some(params) = &obs.imperial {
                (
                    params.dewpt,
                    params.heat_index,
                    params.precip_rate,
                    params.precip_total,
                    params.pressure,
                    params.temp,
                    params.wind_chill,
                    params.wind_gust,
                    params.wind_speed,
                )
            } else {
                panic!("weather data didn't return any imperial data")
            };

        if let Some(dewpt) = dewpt {
            devices.0.dewpt.report_update(dewpt).await
        }

        if let Some(htidx) = htidx {
            devices.0.htidx.report_update(htidx).await
        }

        if let (Some(prate), Some(ptotal)) = (prate, ptotal) {
            let (nrate, ntotal, nlast) =
                self.precip.update(prate, ptotal, SystemTime::now());

            devices.0.prec_rate.report_update(nrate).await;
            devices.0.prec_total.report_update(ntotal).await;

            if let Some(last) = nlast {
                devices.0.prec_last_total.report_update(last).await;
            }
        } else {
            warn!("need both precip fields to update precip calculations")
        }

        if let Some(press) = press {
            devices.0.pressure.report_update(press).await
        }

        if let Some(temp) = temp {
            devices.0.temp.report_update(temp).await
        }

        if let Some(wndchl) = wndchl {
            devices.0.wndchl.report_update(wndchl).await
        }

        if let Some(wndgst) = wndgst {
            devices.0.wndgst.report_update(wndgst).await
        }

        if let Some(wndspd) = wndspd {
            devices.0.wndspd.report_update(wndspd).await
        }

        // If solar radiation readings are provided, report them.

        if let Some(sol_rad) = obs.solar_radiation {
            // On Earth, solar radiation varies between 0 and 1361
            // W/m^2. (https://en.wikipedia.org/wiki/Solar_irradiance)
            // We'll round up to 1400 so weather stations with
            // slightly inaccurate sensors won't be ignored.

            if (0.0..=1400.0).contains(&sol_rad) {
                devices.0.solrad.report_update(sol_rad).await
            } else {
                warn!("ignoring bad solar radiation value: {:.1}", sol_rad)
            }
        }

        // If humidity readings are provided, report them.

        if let Some(humidity) = obs.humidity {
            // Technically the humidity could get to 0%, but it's
            // doubtful there's a place on earth that gets that low.

            if (0.0..=100.0).contains(&humidity) {
                devices.0.humidity.report_update(humidity).await
            } else {
                warn!("ignoring bad humidity value: {:.1}", humidity)
            }
        }

        // If UV readings are provided, report them.

        if let Some(uv) = obs.uv {
            devices.0.uv.report_update(uv).await
        }

        // If wind direction readings are provided, report them.

        if let Some(winddir) = obs.winddir {
            // Make sure the reading is in range.

            if (0.0..=360.0).contains(&winddir) {
                devices.0.wnddir.report_update(winddir).await
            } else {
                warn!("ignoring bad wind direction value: {:.1}", winddir)
            }
        }
    }
}

fn xlat_units(u: &classes::WeatherUnits) -> wu::Unit {
    match u {
        classes::WeatherUnits::English => wu::Unit::English,
        classes::WeatherUnits::Metric => wu::Unit::Metric,
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        match wu::create_client(Duration::from_secs(5)) {
            Ok(mut con) => {
                // Validate the driver parameters.

                let (api_key, interval) = Instance::get_cfg_key_and_interval(
                    &mut con,
                    cfg.api_key.clone(),
                    cfg.interval.unwrap_or(DEFAULT_INTERVAL),
                )
                .await?;

                // Assemble and return the state of the driver.

                debug!("instance successfully created");

                Ok(Box::new(Instance {
                    con,
                    api_key,
                    interval,
                    station: cfg.station.clone(),
                    precip: PrecipState::new(),
                }))
            }
            Err(e) => Err(Error::ConfigError(format!(
                "couldn't build client connection -- {}",
                &e
            ))),
        }
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        Span::current().record("cfg", self.station.as_str());

        devices.0.error.report_update(false).await;

        let mut timer = interval_at(Instant::now(), self.interval);

        // Loop forever.

        loop {
            debug!("waiting for next poll time");

            // Wait for the next sample time.

            timer.tick().await;

            debug!("fetching next observation");

            let result = wu::fetch_observation(
                &self.con,
                &self.api_key,
                &self.station,
                &xlat_units(&devices.0.units),
            )
            .await;

            match result {
                Ok(Some(response)) => {
                    match wu::ObservationResponse::try_from(response) {
                        Ok(resp) => {
                            if let Some(obs) = resp.observations {
                                if !obs.is_empty() {
                                    // The API we're using should only
                                    // return 1 set of observations.
                                    // If it, for some reason, changes
                                    // and returns more, log it.

                                    if obs.len() > 1 {
                                        warn!("ignoring {} extra weather observations", obs.len() - 1);
                                    }
                                    devices.0.error.report_update(false).await;
                                    self.handle(&obs[0], devices).await;
                                    continue;
                                }
                            }
                            warn!("no weather data received")
                        }

                        Err(e) => {
                            devices.0.error.report_update(true).await;
                            panic!("error response from Weather Underground -- {:?}", &e)
                        }
                    }
                }

                Ok(None) => {
                    devices.0.error.report_update(true).await;
                    panic!("no response from Weather Underground")
                }

                Err(e) => {
                    devices.0.error.report_update(true).await;
                    panic!("error accessing Weather Underground -- {:?}", &e)
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::PrecipState;
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    fn mk_time(secs: u64) -> SystemTime {
        UNIX_EPOCH.checked_add(Duration::from_secs(secs)).unwrap()
    }

    #[test]
    fn test_precip() {
        // This tests for normal rainfall. It also makes sure the
        // totals get adjusted after the long enough delay of no rain.

        {
            let mut s = PrecipState::new();

            // Should start as `NoRain` and, as long as we have no
            // precip, it should stay that way.

            assert_eq!(s.update(0.0, 0.0, mk_time(0)), (0.0, 0.0, None));
            assert_eq!(s.update(0.0, 0.0, mk_time(600)), (0.0, 0.0, None));

            // Even if the rainfall rate is non zero, we don't go into
            // the rain state until the total is nonzero.

            assert_eq!(s.update(0.1, 0.0, mk_time(1200)), (0.1, 0.0, None));

            // With both inputs 0.0, we shouldn't trigger a "last
            // rainfall" total.

            assert_eq!(s.update(0.0, 0.0, mk_time(1800)), (0.0, 0.0, None));

            // As rain occurs, we should track the total.

            assert_eq!(s.update(0.1, 0.125, mk_time(2400)), (0.1, 0.125, None));
            assert_eq!(s.update(0.05, 0.25, mk_time(3000)), (0.05, 0.25, None));
            assert_eq!(s.update(0.7, 0.375, mk_time(3600)), (0.7, 0.375, None));

            // Zero rate shouldn't reset by itself.

            assert_eq!(s.update(0.0, 0.375, mk_time(4200)), (0.0, 0.375, None));

            // Even if both are zeroed, we don't reset the count if
            // the time from the last rain was less than our timeout.

            assert_eq!(s.update(0.0, 0.0, mk_time(4800)), (0.0, 0.375, None));

            // Now add more and then simulate 10 hours of nothing.

            assert_eq!(s.update(0.1, 0.125, mk_time(5400)), (0.1, 0.5, None));
            assert_eq!(s.update(0.0, 0.125, mk_time(6000)), (0.0, 0.5, None));
            assert_eq!(s.update(0.0, 0.125, mk_time(41_399)), (0.0, 0.5, None));
            assert_eq!(
                s.update(0.0, 0.125, mk_time(41_400)),
                (0.0, 0.0, Some(0.5))
            );
            assert_eq!(s.update(0.0, 0.125, mk_time(42_001)), (0.0, 0.0, None));

            // Now any new rainfall start new accumulation.

            assert_eq!(s.update(0.1, 0.125, mk_time(40_800)), (0.1, 0.0, None));
            assert_eq!(
                s.update(0.1, 0.25, mk_time(41_400)),
                (0.1, 0.125, None)
            );
        }

        // This tests for a possible weird occurrance at midnight.

        {
            let mut s = PrecipState::new();

            // Reproduce the previous rain, but we'll add a midnight
            // crossing (which resets the total).

            assert_eq!(s.update(0.1, 0.125, mk_time(0)), (0.1, 0.125, None));
            assert_eq!(s.update(0.05, 0.25, mk_time(600)), (0.05, 0.25, None));
            assert_eq!(s.update(0.7, 0.375, mk_time(1200)), (0.7, 0.375, None));
            assert_eq!(s.update(0.3, 0.125, mk_time(1800)), (0.3, 0.5, None));
            assert_eq!(s.update(0.3, 0.25, mk_time(2400)), (0.3, 0.625, None));

            // Let's assume that the total got reset just before
            // reporting it to Weather Underground. In that case, the
            // total would be zero but the rate would be non-zero.

            assert_eq!(s.update(0.1, 0.0, mk_time(3000)), (0.1, 0.625, None));
            assert_eq!(s.update(0.0, 0.0, mk_time(3600)), (0.0, 0.625, None));
            assert_eq!(s.update(0.3, 0.125, mk_time(4200)), (0.3, 0.75, None));
        }
    }
}

---
FILE: drivers/drmem-drv-weather-wu/src/lib.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmem-api/Cargo.toml
[package]
name = "drmem-api"
version = "0.7.0"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
description = "Traits and types used internally by the DrMem control system"
homepage = "https://github.com/DrMemCS/drmem"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded"]
keywords = ["control-system", "automation"]

[lib]
doctest = false

[badges]
maintenance = { status = "actively-developed" }

[dependencies]
chrono.workspace = true
chrono.default-features = false

toml.workspace = true
toml.default-features = false
toml.features = ["parse"]

tokio.workspace = true
tokio.default-features = false
tokio.features = ["time", "macros"]

tokio-stream.workspace = true
tokio-stream.default-features = false

tracing.workspace = true
tracing.default-features = false

serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

palette.workspace = true
palette.default-features = false
palette.features = ["libm"]

[dev-dependencies]
tokio.workspace = true
tokio.features = ["rt"]

noop-waker = "0.1"

---
FILE: drmem-api/src/client.rs
//! Defines types and interfaces that internal clients use to interact
//! with the core of DrMem. The primary, internal client is the
//! GraphQL interface, but asks in logic blocks also use this module.
//!
//! Any new, internal tasks that need access to device readings or
//! wish to set the value of the device need to have a
//! `client::RequestChan` handle. As DrMem starts, it should
//! `.clone()` the `RequestChan` used to communicate with the
//! back-end.
//!
//! # Example
//!
//! ```ignore
//! async fn some_new_task(handle: client::RequestChan) {
//!    // Initialize and enter loop.
//!
//!    let device = "some:device".parse::<device::Name>().unwrap();
//!
//!    loop {
//!        // Set a device value.
//!
//!        if some_condition {
//!            handle.set_device(&device, true.into())
//!        }
//!    }
//! }
//!
//! // Somewhere in DrMem start-up.
//!
//! let task = some_new_task(backend_chan.clone());
//!
//! // Add the task to the set of tasks to be awaited.
//! ```

use crate::{
    driver,
    types::{device, Error},
    Result,
};
use chrono::*;
use tokio::sync::{mpsc, oneshot};

/// Holds information about a device. A back-end is free to store this
/// information in any way it sees fit. However, it is returned for
/// GraphQL queries, so it should be reasonably efficient to assemble
/// this reply.
#[derive(Debug, PartialEq)]
pub struct DevInfoReply {
    /// The full name of the device.
    pub name: device::Name,
    /// The device's engineering units. Some devices don't use units
    /// (boolean devices are an example.)
    pub units: Option<String>,
    /// Indicates whether the device is settable.
    pub settable: bool,
    pub total_points: u32,
    pub first_point: Option<device::Reading>,
    pub last_point: Option<device::Reading>,
    /// The name of the driver that supports this device.
    pub driver: driver::Name,
}

// Defines the requests that can be sent to core.
#[doc(hidden)]
pub enum Request {
    QueryDeviceInfo {
        pattern: Option<String>,
        rpy_chan: oneshot::Sender<Result<Vec<DevInfoReply>>>,
    },

    SetDevice {
        name: device::Name,
        value: device::Value,
        rpy_chan: oneshot::Sender<Result<device::Value>>,
    },

    GetSettingChan {
        name: device::Name,
        _own: bool,
        rpy_chan: oneshot::Sender<Result<driver::TxDeviceSetting>>,
    },

    MonitorDevice {
        name: device::Name,
        start: Option<DateTime<Utc>>,
        end: Option<DateTime<Utc>>,
        rpy_chan: oneshot::Sender<Result<device::DataStream<device::Reading>>>,
    },
}

/// A handle which is used to communicate with the core of DrMem.
/// Clients will be given a handle to be used throughout its life.
///
/// This type wraps the `mpsc::Sender<>` and defines a set of helper
/// methods to send requests and receive replies with the core.
#[derive(Clone)]
pub struct RequestChan {
    req_chan: mpsc::Sender<Request>,
}

impl RequestChan {
    pub fn new(req_chan: mpsc::Sender<Request>) -> Self {
        RequestChan { req_chan }
    }

    /// Makes a request to monitor the device, `name`.
    ///
    /// If sucessful, a stream is returned which yields device
    /// readings as the device is updated.
    pub async fn monitor_device(
        &self,
        name: device::Name,
        start: Option<DateTime<Utc>>,
        end: Option<DateTime<Utc>>,
    ) -> Result<device::DataStream<device::Reading>> {
        // Create our reply channel and build the request message.

        let (tx, rx) = oneshot::channel();
        let msg = Request::MonitorDevice {
            name,
            rpy_chan: tx,
            start,
            end,
        };

        // Send the message.

        self.req_chan.send(msg).await?;

        // Wait for a reply.

        rx.await?
    }

    /// Requests that a device be set to a provided value.
    ///
    /// - `name` is the name of the device
    /// - `value` is the value to be set. This value can be a
    ///   `device::Value` value or can be any type that can be coerced
    ///   into one.
    ///
    /// Returns the value the driver actually used to set the device.
    /// Some drivers do sanity checks on the set value and, if the
    /// value is unusable, the driver may return an error or clip the
    /// value to something valid. The driver's documentation should
    /// indicate how it handles invalid settings.
    pub async fn set_device<
        T: Into<device::Value> + TryFrom<device::Value, Error = Error>,
    >(
        &self,
        name: device::Name,
        value: T,
    ) -> Result<T> {
        // Create the reply channel and the request message that will
        // be sent.

        let (tx, rx) = oneshot::channel();
        let msg = Request::SetDevice {
            name,
            value: value.into(),
            rpy_chan: tx,
        };

        // Send the request to the driver.

        self.req_chan.send(msg).await?;

        // Wait for the reply and try to convert the set value back
        // into the type that was used.

        rx.await?.and_then(T::try_from)
    }

    pub async fn get_setting_chan(
        &self,
        name: device::Name,
        own: bool,
    ) -> Result<driver::TxDeviceSetting> {
        // Create the reply channel and the request message that will
        // be sent.

        let (tx, rx) = oneshot::channel();
        let msg = Request::GetSettingChan {
            name,
            _own: own,
            rpy_chan: tx,
        };

        // Send the request to the driver.

        self.req_chan.send(msg).await?;

        // Wait for the reply and try to convert the set value back
        // into the type that was used.

        rx.await?
    }

    /// Requests device information for devices whose name matches the
    /// provided pattern.
    pub async fn get_device_info(
        &self,
        pattern: Option<String>,
    ) -> Result<Vec<DevInfoReply>> {
        let (rpy_chan, rx) = oneshot::channel();

        // Send the request to the service (i.e. the backend) that has
        // the device information.

        self.req_chan
            .send(Request::QueryDeviceInfo { pattern, rpy_chan })
            .await?;

        // Return the reply from the request.

        rx.await.map_err(|e| e.into()).and_then(|v| v)
    }
}

---
FILE: drmem-api/src/driver/classes/dimmer_type.rs
//! Define device representation of wall dimmer switches.
//!
//! Defines a `Registrator` that registers device names and typed
//! channels to control it. A driver which controls a switch should
//! use this instead of registering their own device channels:
//!
//! ```rust,ignore
//! use drmem_api::driver::{self, classes};
//!
//! struct MyDimmerDriver { ... };
//!
//! impl driver::API for MyDimmerDriver {
//!     type HardwareType = classes::Dimmer;
//!
//!     ...
//! }
//! ```

use crate::driver::{
    overridable_device::OverridableDevice, ro_device::ReadOnlyDevice,
    Registrator, Reporter, RequestChan, Result,
};
use tokio::time::Duration;

/// Defines the common API used by Dimmers.
pub struct Dimmer<R: Reporter> {
    /// This device returns `true` when the driver has a problem
    /// communicating with the hardware.
    pub error: ReadOnlyDevice<bool, R>,
    /// Controls the brightness setting of the dimmer. Off is 0.0 and
    /// full-on is 100.0.
    pub brightness: OverridableDevice<f64, R>,
    /// A product might include an indicator. If the hardware does,
    /// this device can turn it on and off.
    pub indicator: OverridableDevice<bool, R>,
}

impl<R: Reporter> Registrator<R> for Dimmer<R> {
    type Config = Option<Duration>;

    async fn register_devices(
        drc: &mut RequestChan<R>,
        cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        Ok(Dimmer {
            error: drc.add_ro_device("error", None, max_history).await?,
            brightness: drc
                .add_overridable_device(
                    "brightness",
                    Some("%"),
                    *cfg,
                    max_history,
                )
                .await?,
            indicator: drc
                .add_overridable_device("indicator", None, *cfg, max_history)
                .await?,
        })
    }
}

impl<R: Reporter> crate::driver::ResettableState for Dimmer<R> {}

---
FILE: drmem-api/src/driver/classes/mod.rs
//! Define classes of devices.
//!
//! This module provides a set of types that define a consistent set
//! of device names and channels for classes of hardware devices. For
//! instance, drivers should use the `ColorLight` type if it controls
//! color, LED bulbs. This type will define the set of DrMem devices
//! that are expected from every color LED bulb.

// Pull in the modules that define each hardware type.

mod dimmer_type;
mod switch_type;
mod weather_type;

// Make top-level types available to driver writers.

pub use dimmer_type::Dimmer;
pub use switch_type::Switch;
pub use weather_type::{Weather, WeatherConfig, WeatherUnits};

---
FILE: drmem-api/src/driver/classes/switch_type.rs
//! Define device representation of wall switches.
//!
//! Defines a `Registrator` that registers a device name and typed
//! channel to control it. A driver which controls a switch should use
//! this instead of registering their own device channels:
//!
//! ```rust,ignore
//! use drmem_api::driver::{self, classes};
//!
//! struct MySwitchDriver { ... };
//!
//! impl driver::API for MySwitchDriver {
//!     type HardwareType = classes::Switch;
//!
//!     ...
//! }
//! ```

use crate::driver::{
    overridable_device::OverridableDevice, ro_device::ReadOnlyDevice,
    Registrator, Reporter, RequestChan, Result,
};
use tokio::time::Duration;

/// Defines the common API used by Switches.
pub struct Switch<R: Reporter> {
    /// This device returns `true` when the driver has a problem
    /// communicating with the hardware.
    pub error: ReadOnlyDevice<bool, R>,
    /// Indicates the state of the switch. Writing `true` or `false`
    /// turns the switch on and off, respectively.
    pub state: OverridableDevice<bool, R>,
    /// A product might include an indicator. If the hardware does,
    /// this device can turn it on and off.
    pub indicator: OverridableDevice<bool, R>,
}

impl<R: Reporter> Registrator<R> for Switch<R> {
    type Config = Option<Duration>;

    async fn register_devices(
        drc: &mut RequestChan<R>,
        cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        Ok(Switch {
            error: drc.add_ro_device("error", None, max_history).await?,
            state: drc
                .add_overridable_device("state", None, *cfg, max_history)
                .await?,
            indicator: drc
                .add_overridable_device("indicator", None, *cfg, max_history)
                .await?,
        })
    }
}

impl<R: Reporter> crate::driver::ResettableState for Switch<R> {}

---
FILE: drmem-api/src/driver/classes/weather_type.rs
use crate::driver::{self, Registrator, Reporter, RequestChan, Result};

#[derive(serde::Deserialize, Clone)]
pub enum WeatherUnits {
    English,
    Metric,
}

#[derive(serde::Deserialize)]
pub struct WeatherConfig {
    pub units: WeatherUnits,
}

pub struct Weather<R: Reporter> {
    pub units: WeatherUnits,

    pub dewpt: driver::ReadOnlyDevice<f64, R>,
    pub htidx: driver::ReadOnlyDevice<f64, R>,
    pub humidity: driver::ReadOnlyDevice<f64, R>,
    pub prec_rate: driver::ReadOnlyDevice<f64, R>,
    pub prec_total: driver::ReadOnlyDevice<f64, R>,
    pub prec_last_total: driver::ReadOnlyDevice<f64, R>,
    pub pressure: driver::ReadOnlyDevice<f64, R>,
    pub solrad: driver::ReadOnlyDevice<f64, R>,
    pub error: driver::ReadOnlyDevice<bool, R>,
    pub temp: driver::ReadOnlyDevice<f64, R>,
    pub uv: driver::ReadOnlyDevice<f64, R>,
    pub wndchl: driver::ReadOnlyDevice<f64, R>,
    pub wnddir: driver::ReadOnlyDevice<f64, R>,
    pub wndgst: driver::ReadOnlyDevice<f64, R>,
    pub wndspd: driver::ReadOnlyDevice<f64, R>,
}

impl<R: Reporter> Registrator<R> for Weather<R> {
    type Config = WeatherConfig;

    async fn register_devices(
        drc: &mut RequestChan<R>,
        cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        let temp_unit = Some(if let WeatherUnits::English = cfg.units {
            "F"
        } else {
            "C"
        });
        let speed_unit = Some(if let WeatherUnits::English = cfg.units {
            "mph"
        } else {
            "km/h"
        });

        let dewpt = drc
            .add_ro_device("dewpoint", temp_unit, max_history)
            .await?;
        let htidx = drc
            .add_ro_device("heat-index", temp_unit, max_history)
            .await?;
        let humidity = drc
            .add_ro_device("humidity", Some("%"), max_history)
            .await?;
        let prec_rate = drc
            .add_ro_device(
                "precip-rate",
                Some(if let WeatherUnits::English = cfg.units {
                    "in/hr"
                } else {
                    "mm/hr"
                }),
                max_history,
            )
            .await?;

        let prec_total = drc
            .add_ro_device(
                "precip-total",
                Some(if let WeatherUnits::English = cfg.units {
                    "in"
                } else {
                    "mm"
                }),
                max_history,
            )
            .await?;

        let prec_last_total = drc
            .add_ro_device(
                "precip-last-total",
                Some(if let WeatherUnits::English = cfg.units {
                    "in"
                } else {
                    "mm"
                }),
                max_history,
            )
            .await?;

        let pressure = drc
            .add_ro_device(
                "pressure",
                Some(if let WeatherUnits::English = cfg.units {
                    "inHg"
                } else {
                    "hPa"
                }),
                max_history,
            )
            .await?;

        let solrad = drc
            .add_ro_device("solar-rad", Some("W/m"), max_history)
            .await?;
        let error = drc.add_ro_device("error", None, max_history).await?;
        let temp = drc
            .add_ro_device("temperature", temp_unit, max_history)
            .await?;
        let uv = drc.add_ro_device("uv", None, max_history).await?;
        let wndchl = drc
            .add_ro_device("wind-chill", temp_unit, max_history)
            .await?;
        let wnddir = drc
            .add_ro_device("wind-dir", Some(""), max_history)
            .await?;
        let wndgst = drc
            .add_ro_device("wind-gust", speed_unit, max_history)
            .await?;
        let wndspd = drc
            .add_ro_device("wind-speed", speed_unit, max_history)
            .await?;

        Ok(Weather {
            units: cfg.units.clone(),
            dewpt,
            htidx,
            humidity,
            prec_rate,
            prec_total,
            prec_last_total,
            pressure,
            solrad,
            error,
            temp,
            uv,
            wndchl,
            wnddir,
            wndgst,
            wndspd,
        })
    }
}

impl<R: Reporter> crate::driver::ResettableState for Weather<R> {}

---
FILE: drmem-api/src/driver/config.rs
/// Represents how configuration information is given to a driver.
/// Since each driver can have vastly different requirements, the
/// config structure needs to be as general as possible. A
/// `DriverConfig` type is a map with `String` keys and `toml::Value`
/// values.
use crate::{types::Error, Result};
use serde::de::DeserializeOwned;
use std::ops::Deref;
use toml::value::{Table, Value};

#[derive(Clone, Debug, Default)]
pub struct DriverConfig(Table);

impl DriverConfig {
    /// Return a reference to the underlying toml::Value for a key.
    pub fn get(&self, key: &str) -> Option<&Value> {
        self.0.get(key)
    }

    pub fn get_str(&self, key: &str) -> Result<String> {
        match self.0.get(key) {
            Some(Value::String(s)) => Ok(s.clone()),
            Some(_) => {
                Err(Error::ConfigError(format!("'{}' must be a string", key)))
            }
            None => Err(Error::ConfigError(format!(
                "missing {} config paramater",
                key
            ))),
        }
    }

    pub fn parse_into<T>(&self) -> Result<T>
    where
        T: DeserializeOwned,
    {
        Value::Table(self.0.clone()).try_into().map_err(|e| {
            Error::ConfigError(format!("config parse error: {}", e))
        })
    }
}

impl From<Table> for DriverConfig {
    fn from(t: Table) -> Self {
        DriverConfig(t)
    }
}

impl From<DriverConfig> for Table {
    fn from(dc: DriverConfig) -> Self {
        dc.0
    }
}

impl std::convert::TryFrom<DriverConfig> for () {
    type Error = std::convert::Infallible;

    fn try_from(_cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        Ok(())
    }
}

impl Deref for DriverConfig {
    type Target = Table;

    fn deref(&self) -> &Table {
        &self.0
    }
}

---
FILE: drmem-api/src/driver/mod.rs
//! Defines types and interfaces that drivers use to interact with the
//! core of DrMem.

use crate::types::{
    device::{self, Base},
    Error,
};
use std::{
    convert::{Infallible, TryFrom},
    future::Future,
    sync::Arc,
};
use tokio::{
    sync::{mpsc, oneshot},
    time::Duration,
};

use super::Result;

/// Represents the type used to specify the name of a driver.

pub type Name = Arc<str>;

pub mod classes;
mod config;
mod overridable_device;
mod ro_device;
mod rw_device;

pub use config::DriverConfig;
pub use overridable_device::OverridableDevice;
pub use ro_device::ReadOnlyDevice;
pub use rw_device::{
    ReadWriteDevice, RxDeviceSetting, SettingRequest, SettingResponder,
    TxDeviceSetting,
};

pub trait Reporter: Send + Sync + 'static {
    fn report_value(
        &mut self,
        value: device::Value,
    ) -> impl Future<Output = ()> + Send;
}

/// Defines the requests that can be sent to core. Drivers don't use
/// this type directly. They are indirectly used by `RequestChan`.
pub enum Request<R: Reporter> {
    /// Registers a read-only device with core.
    ///
    /// The reply is a pair where the first element is a channel to
    /// report updated values of the device. The second element, if
    /// not `None`, is the last saved value of the device.
    AddReadonlyDevice {
        driver_name: Name,
        dev_name: device::Name,
        dev_units: Option<String>,
        max_history: Option<usize>,
        rpy_chan: oneshot::Sender<Result<R>>,
    },

    /// Registers a writable device with core.
    ///
    /// The reply is a 3-tuple where the first element is a channel to
    /// report updated values of the device. The second element is a
    /// stream that yileds incoming settings to the device. The last
    /// element, if not `None`, is the last saved value of the device.
    AddReadWriteDevice {
        driver_name: Name,
        dev_name: device::Name,
        dev_units: Option<String>,
        max_history: Option<usize>,
        rpy_chan: oneshot::Sender<
            Result<(R, RxDeviceSetting, Option<device::Value>)>,
        >,
    },
}

/// A handle which is used to communicate with the core of DrMem.
/// When a driver is created, it will be given a handle to be used
/// throughout its life.
///
/// This type wraps the `mpsc::Sender<>` and defines a set of helper
/// methods to send requests and receive replies with the core.
pub struct RequestChan<R: Reporter> {
    driver_name: Name,
    prefix: device::Path,
    req_chan: mpsc::Sender<Request<R>>,
}

impl<R: Reporter> RequestChan<R> {
    pub fn new(
        driver_name: Name,
        prefix: &device::Path,
        req_chan: &mpsc::Sender<Request<R>>,
    ) -> Self {
        RequestChan {
            driver_name,
            prefix: prefix.clone(),
            req_chan: req_chan.clone(),
        }
    }

    /// Registers a read-only device with the framework. `name` is the
    /// last section of the full device name. Typically a driver will
    /// register several devices, each representing a portion of the
    /// hardware being controlled. All devices for a given driver
    /// instance will have the same prefix; the `name` parameter is
    /// appended to it.
    ///
    /// If it returns `Ok()`, the value is a broadcast channel that
    /// the driver uses to announce new values of the associated
    /// hardware.
    ///
    /// If it returns `Err()`, the underlying value could be `InUse`,
    /// meaning the device name is already registered. If the error is
    /// `InternalError`, then the core has exited and the
    /// `RequestChan` has been closed. Since the driver can't report
    /// any more updates, it may as well shutdown.
    pub async fn add_ro_device<T, N>(
        &self,
        name: N,
        units: Option<&str>,
        max_history: Option<usize>,
    ) -> Result<ReadOnlyDevice<T, R>>
    where
        T: device::ReadCompat,
        N: TryInto<Base>,
        Error: From<<N as TryInto<Base>>::Error>,
    {
        let name = match name.try_into() {
            Ok(name) => name,
            Err(e) => return Err(e.into()),
        };

        // Create a location for the reply.

        let (tx, rx) = oneshot::channel();

        // Send a request to Core to register the given name.

        let result = self
            .req_chan
            .send(Request::AddReadonlyDevice {
                driver_name: self.driver_name.clone(),
                dev_name: device::Name::build(self.prefix.clone(), name),
                dev_units: units.map(String::from),
                max_history,
                rpy_chan: tx,
            })
            .await;

        // If the request was sent successfully and we successfully
        // received a reply, process the payload.

        if result.is_ok() {
            if let Ok(v) = rx.await {
                return v.map(ReadOnlyDevice::new);
            }
        }

        Err(Error::MissingPeer(String::from(
            "can't communicate with core",
        )))
    }

    /// Registers a read-write device with the framework. `name` is the
    /// last section of the full device name. Typically a driver will
    /// register several devices, each representing a portion of the
    /// hardware being controlled. All devices for a given driver
    /// instance will have the same prefix; the `name` parameter is
    /// appended to it.
    ///
    /// If it returns `Ok()`, the value is a pair containing a
    /// broadcast channel that the driver uses to announce new values
    /// of the associated hardware and a receive channel for incoming
    /// settings to be applied to the hardware.
    ///
    /// If it returns `Err()`, the underlying value could be `InUse`,
    /// meaning the device name is already registered. If the error is
    /// `InternalError`, then the core has exited and the
    /// `RequestChan` has been closed. Since the driver can't report
    /// any more updates or accept new settings, it may as well shutdown.
    pub async fn add_rw_device<T, N>(
        &self,
        name: N,
        units: Option<&str>,
        max_history: Option<usize>,
    ) -> Result<ReadWriteDevice<T, R>>
    where
        T: device::ReadWriteCompat,
        N: TryInto<Base>,
        Error: From<<N as TryInto<Base>>::Error>,
    {
        let (tx, rx) = oneshot::channel();
        let result = self
            .req_chan
            .send(Request::AddReadWriteDevice {
                driver_name: self.driver_name.clone(),
                dev_name: device::Name::build(
                    self.prefix.clone(),
                    name.try_into()?,
                ),
                dev_units: units.map(String::from),
                max_history,
                rpy_chan: tx,
            })
            .await;

        if result.is_ok() {
            if let Ok(v) = rx.await {
                return v.map(|(rr, rs, prev)| {
                    ReadWriteDevice::new(
                        rr,
                        rs,
                        prev.and_then(|v| T::try_from(v).ok()),
                    )
                });
            }
        }

        Err(Error::MissingPeer(String::from(
            "can't communicate with core",
        )))
    }

    /// Registers a device, with the framework, that is read-write but
    /// which can also change state via external means. WiFi LED
    /// bulbs, for instance, can be controlled by DrMem but can also
    /// be adjusted by a person in the room or an app or another
    /// automation agent, like Google Home.
    ///
    /// `name` is the last section of the full device name. Typically
    /// a driver will register several devices, each representing a
    /// portion of the hardware being controlled. All devices for a
    /// given driver instance will have the same prefix; the `name`
    /// parameter is appended to it.
    ///
    /// If it returns `Ok()`, the value is a pair containing a
    /// broadcast channel that the driver uses to announce new values
    /// of the associated hardware and a receive channel for incoming
    /// settings to be applied to the hardware.
    ///
    /// If it returns `Err()`, the underlying value could be `InUse`,
    /// meaning the device name is already registered. If the error is
    /// `InternalError`, then the core has exited and the
    /// `RequestChan` has been closed. Since the driver can't report
    /// any more updates or accept new settings, it may as well shutdown.
    pub async fn add_overridable_device<T, N>(
        &self,
        name: N,
        units: Option<&str>,
        override_duration: Option<Duration>,
        max_history: Option<usize>,
    ) -> Result<OverridableDevice<T, R>>
    where
        T: device::ReadWriteCompat,
        N: TryInto<Base>,
        Error: From<<N as TryInto<Base>>::Error>,
    {
        let (tx, rx) = oneshot::channel();
        let result = self
            .req_chan
            .send(Request::AddReadWriteDevice {
                driver_name: self.driver_name.clone(),
                dev_name: device::Name::build(
                    self.prefix.clone(),
                    name.try_into()?,
                ),
                dev_units: units.map(String::from),
                max_history,
                rpy_chan: tx,
            })
            .await;

        if result.is_ok() {
            if let Ok(v) = rx.await {
                return v.map(|(rr, rs, prev)| {
                    OverridableDevice::new(
                        rr,
                        rs,
                        prev.and_then(|v| T::try_from(v).ok()),
                        override_duration,
                    )
                });
            }
        }

        Err(Error::MissingPeer(String::from(
            "can't communicate with core",
        )))
    }
}

pub trait ResettableState {
    fn reset_state(&mut self) {}
}

/// A trait which manages details about driver registration.
///
/// All drivers will implement a type, or use one of the predefined
/// types, that registers the set of needed devices.
///
/// The only function in this trait is one to register the device(s)
/// with core and return the set of handles.
pub trait Registrator<R: Reporter>: ResettableState + Sized + Send {
    type Config: Send + Sync;

    /// Before a driver is run, the set of devices it uses needs to be
    /// registered. The structure that holds the registered device
    /// channels should implement this trait.
    ///
    /// `drc` is a communication channel with which the driver makes
    /// requests to the core. Its typical use is to register devices
    /// with the framework, which is usually done in this method. As
    /// other request types are added, they can be used while the
    /// driver is running.
    ///
    /// `cfg` holds the configuration parameters for the instance of
    /// the driver. This parameter is also passed to the driver's
    /// `create_instance` method where it is more useful. Since the
    /// purpose of this trait is to register devices, the other useful
    /// configuration paramters would be ones that manipulate the
    /// names of devices. This method should not use this parameter to
    /// set up resouces (like sockets) for the driver instance.
    ///
    /// `max_history` is specified in the configuration file. It is a
    /// hint as to the maximum number of data point to save for each
    /// of the devices created by this driver. A backend can choose to
    /// interpret this in its own way. For instance, the simple
    /// backend can only ever save one data point. Redis will take
    /// this as a hint and will choose the most efficient way to prune
    /// the history. That means, if more than the limit is present,
    /// redis won't prune the history to less than the limit. However
    /// there may be more than the limit -- it just won't grow without
    /// bound.
    fn register_devices<'a>(
        drc: &'a mut RequestChan<R>,
        cfg: &'a Self::Config,
        max_history: Option<usize>,
    ) -> impl Future<Output = Result<Self>> + Send;
}

/// All drivers implement the `driver::API` trait.
///
/// The `API` trait defines methods that are expected to be available
/// from a driver instance. By supporting this API, the framework can
/// create driver instances and monitor them as they run.
pub trait API<R: Reporter>: Send + Sync {
    type Config: TryFrom<DriverConfig> + Send + Sync;
    type HardwareType: Registrator<R, Config = Self::Config>;

    /// Creates an instance of the driver.
    ///
    /// `cfg` contains the driver parameters, as specified in the
    /// `drmem.toml` configuration file. It is a `toml::Table` type so
    /// the keys for the parameter names are strings and the
    /// associated data are `toml::Value` types. This method should
    /// validate the parameters and convert them into forms useful to
    /// the driver. By convention, if any errors are found in the
    /// configuration, this method should return `Error::BadConfig`.
    fn create_instance(
        cfg: &Self::Config,
    ) -> impl Future<Output = Result<Box<Self>>> + Send;

    /// Runs the instance of the driver.
    ///
    /// Since drivers provide access to hardware, this method should
    /// never return unless something severe occurs and, in that case,
    /// it should use `panic!()`. All drivers are monitored by a task
    /// and if a driver panics or returns an error from this method,
    /// it gets reported in the log and then, after a short delay, the
    /// driver is restarted.
    fn run<'a>(
        &'a mut self,
        devices: &'a mut Self::HardwareType,
    ) -> impl Future<Output = Infallible> + Send;
}

---
FILE: drmem-api/src/driver/overridable_device.rs
/// Defines a settable device that is "shared" with the outside world.
///
/// Some devices are purely controlled by DrMem. However, there are
/// many commercial devices that are intended to be controlled by
/// users outside of DrMem. LED WiFi light bulbs are one, obvious
/// example. For devices that can be controlled outside of DrMem, we
/// need a way to cooperatively control them. That's what
/// `OverridableDevice`s do.
///
/// A driver that uses this type of device must do these steps in
/// their main loop:
///
/// - periodically poll the hardware and report the value using
///   `.report_update()`
/// - call `.next_setting()` to get the next incoming setting
/// - after setting the hardware to a new value, a poll should
///   immediately be done followed by a `.report_update()`
///
/// `OverridableDevice`s implement a simple state machine to know how
/// to handle incoming incoming settings.
use crate::{
    device,
    driver::{rw_device, Reporter, RxDeviceSetting, SettingResponder},
};
use tokio_stream::StreamExt;
use tracing::info;

pub type SettingTransaction<T> = (T, Option<SettingResponder<T>>);

// Describes the states that the device goes through as it receives
// settings and polled readings.

//#[derive(PartialEq)]
enum State<T: device::ReadWriteCompat> {
    Unknown,
    UnknownTrans {
        value: T,
        report: SettingResponder<T>,
    },
    Synced {
        value: T,
    },
    SyncedTrans {
        value: T,
    },
    UnreportedSetting {
        value: T,
    },
    Setting {
        value: T,
    },
    SettingTrans {
        value: (T, Option<SettingResponder<T>>),
    },
    ReassertSetting {
        value: T,
    },
    Overridden {
        setting: T,
        r#override: T,
        tmo: tokio::time::Instant,
    },
}

pub struct OverridableDevice<T: device::ReadWriteCompat, R: Reporter> {
    state: State<T>,
    override_duration: Option<tokio::time::Duration>,
    reporter: R,
    set_stream: rw_device::SettingStream<T>,
}

impl<T, R> OverridableDevice<T, R>
where
    T: device::ReadWriteCompat,
    R: Reporter,
{
    pub fn new(
        reporter: R,
        setting_chan: RxDeviceSetting,
        desired_value: Option<T>,
        override_duration: Option<tokio::time::Duration>,
    ) -> Self {
        OverridableDevice {
            state: desired_value
                .map(|value| State::SettingTrans {
                    value: (value, None),
                })
                .unwrap_or(State::Unknown),
            reporter,
            set_stream: rw_device::create_setting_stream(setting_chan),
            override_duration,
        }
    }

    /// Saves a new value, returned by the device, to the backend
    /// storage. This only writes values that have changed.
    ///
    /// This method is not cancel-safe.
    pub async fn report_update(&mut self, new_value: T) {
        match &mut self.state {
            State::Unknown => {
                self.reporter.report_value(new_value.clone().into()).await;

                // If we are in the unknown state and we get a polled
                // reading, we switch to the synced state. If a
                // setting comes it, it can further modify the state.

                self.state = State::Synced { value: new_value }
            }

            // If we're in this state, then we are in the process of
            // applying a setting from the Unknown state. We ignore
            // this spurious polled value so we can complete the
            // setting.
            //
            // This situation will probably never happen.
            State::UnknownTrans { .. } => {}

            State::Overridden {
                r#override: value,
                setting,
                ..
            } => {
                // The settings are currently overridden. If the value
                // is the same as the saved setting, we're back in
                // sync. If it's different than the last overridden
                // value, report it, reset the timer, and save the new
                // reading.

                if setting == &new_value {
                    self.reporter.report_value(new_value.clone().into()).await;
                    self.state = State::Synced {
                        value: setting.clone(),
                    };
                    info!("value matches setting ... exiting override mode")
                } else if value != &new_value {
                    self.reporter.report_value(new_value.clone().into()).await;
                    self.state = State::Overridden {
                        tmo: tokio::time::Instant::now(),
                        setting: value.clone(),
                        r#override: new_value,
                    };
                    info!("override timer reset")
                }
            }

            State::Synced { value } => {
                // If the value is different from the previously
                // polled value, then we go into the overridden state.

                if value != &new_value {
                    self.reporter.report_value(new_value.clone().into()).await;
                    self.state = State::Overridden {
                        tmo: tokio::time::Instant::now(),
                        setting: value.clone(),
                        r#override: new_value,
                    };
                    info!("device in override mode")
                }
            }

            State::Setting { value } => {
                // When we're handling a setting, we enter the
                // `Synced` state if the polled value matches. If not,
                // then we have to reassert the setting.

                self.state = if value == &new_value {
                    State::Synced { value: new_value }
                } else {
                    State::ReassertSetting {
                        value: value.clone(),
                    }
                }
            }

            State::ReassertSetting { value }
            | State::UnreportedSetting { value } => {
                // When we're handling a setting, we enter the
                // `Synced` state if the polled value matches.

                if value == &new_value {
                    self.state = State::Synced { value: new_value }
                }
            }

            State::SettingTrans {
                value: (value, resp_ref),
            } => {
                // If the polled value happens to equal the incoming
                // setting that's still being processed, we should go
                // into the `Synced` state.

                if value == &new_value {
                    let value = value.clone();

                    // If there was a function to reply to the client,
                    // we need to perform the reply.

                    if let Some(resp) = resp_ref.take() {
                        resp.ok(value.clone());
                    }

                    // Go to the `SyncedTrans` state, which will
                    // report the new value to the backend.

                    self.state = State::SyncedTrans { value };
                }
            }

            State::SyncedTrans { value } => {
                if value != &new_value {
                    // These two statements are the reason this method
                    // isn't cancel-safe. We could try to add an
                    // `OverriddenTrans` state, but then we have to
                    // figure out what to do when settings or new
                    // polled values arrive.
                    //
                    // The sad part is that this state and the
                    // previous `SettingTrans` state are probably
                    // never going to be active when a new value is
                    // reported with this method.

                    self.reporter.report_value(value.clone().into()).await;
                    self.reporter.report_value(new_value.clone().into()).await;
                    self.state = State::Overridden {
                        tmo: tokio::time::Instant::now(),
                        setting: value.clone(),
                        r#override: new_value,
                    }
                }
            }
        }
    }

    /// Gets the last value of the device. If DrMem is built with
    /// persistent storage, this value will be initialized with the
    /// last value saved to storage.
    pub fn get_last(&self) -> Option<&T> {
        match &self.state {
            State::Unknown => None,
            State::UnknownTrans { value, .. }
            | State::Synced { value }
            | State::SyncedTrans { value }
            | State::Setting { value }
            | State::SettingTrans { value: (value, _) }
            | State::ReassertSetting { value }
            | State::UnreportedSetting { value } => Some(value),
            State::Overridden { r#override, .. } => Some(r#override),
        }
    }

    /// Waits for the next setting to arrive.
    ///
    /// This method is cancel-safe.
    pub async fn next_setting(&mut self) -> Option<SettingTransaction<T>> {
        loop {
            match &mut self.state {
                State::Unknown =>
                // At this point, we have no known state. If a
                // setting comes in, we're going to assume it's
                // different from the hardware's state so we
                // switch to Setting.
                {
                    match self.set_stream.next().await {
                        Some(reply) => {
                            self.state = State::UnknownTrans {
                                value: reply.0.clone(),
                                report: reply.1,
                            };
                        }
                        None => return None,
                    }
                }

                // This is a transition state between Unknown and
                // Setting. This was needed to break up the Unknown
                // state so that each state has one future to
                // await. This makes the function "cancel safe".
                State::UnknownTrans { value, .. } => {
                    self.reporter.report_value(value.clone().into()).await;

                    let value = value.clone();

                    if let State::UnknownTrans { value, report } =
                        std::mem::replace(
                            &mut self.state,
                            State::Setting {
                                value: value.clone(),
                            },
                        )
                    {
                        return Some((value, Some(report)));
                    } else {
                        unreachable!()
                    }
                }

                State::UnreportedSetting { value } =>
                // If we have an unreported setting, re-report it and
                // switch to the "reported" setting state.
                {
                    self.reporter.report_value(value.clone().into()).await;
                    self.state = State::Setting {
                        value: value.clone(),
                    };
                }

                State::ReassertSetting { value } =>
                // We need to reassert the setting. Immediately return
                // it and switch to the "reported" setting state.
                {
                    let result = (value.clone(), None);

                    self.state = State::Setting {
                        value: value.clone(),
                    };
                    return Some(result);
                }

                State::Setting { value } => {
                    match self.set_stream.next().await {
                        Some(reply) => {
                            if reply.0 != *value {
                                self.state = State::SettingTrans {
                                    value: (reply.0, Some(reply.1)),
                                };
                            } else {
                                reply.1.ok(reply.0.clone());
                                self.state =
                                    State::UnreportedSetting { value: reply.0 };
                            }
                        }
                        None => return None,
                    }
                }

                State::Synced { value } => match self.set_stream.next().await {
                    Some(reply) => {
                        self.state = if reply.0 != *value {
                            State::SettingTrans {
                                value: (reply.0, Some(reply.1)),
                            }
                        } else {
                            reply.1.ok(reply.0.clone());
                            State::SyncedTrans { value: reply.0 }
                        };
                    }
                    None => return None,
                },

                State::SettingTrans { value: (val, _) } => {
                    self.reporter.report_value(val.clone().into()).await;

                    let val = val.clone();

                    if let State::SettingTrans { value: reply } =
                        std::mem::replace(
                            &mut self.state,
                            State::Setting { value: val.clone() },
                        )
                    {
                        return Some(reply);
                    } else {
                        unreachable!()
                    }
                }

                State::SyncedTrans { value } => {
                    self.reporter.report_value(value.clone().into()).await;
                    self.state = State::Synced {
                        value: value.clone(),
                    };
                }

                State::Overridden {
                    tmo,
                    setting,
                    r#override,
                } =>
                // Being in the overridden state is a little more
                // complicated. It has an optional timeout for when
                // the override should switch back to the last
                // setting.
                {
                    if let Some(duration) = self.override_duration {
                        let delay = duration
                            .checked_sub(tmo.elapsed())
                            .unwrap_or(tokio::time::Duration::new(0, 0));

                        // Wait for a setting or for when the override
                        // timeout occurs.

                        #[rustfmt::skip]
                        tokio::select! {
                            reply = self.set_stream.next() => {
                                match reply {
                                    Some(r) => {
                                        // Save the new setting. It
                                        // doesn't get forwarded to
                                        // the driver because we don't
                                        // want the hardware state to
                                        // be changed. Instead it gets
                                        // stored.
                                        //
                                        // XXX: There is an issue here
                                        // in that, if a driver can
                                        // reject a setting's value,
                                        // we're not allowing that to
                                        // happen until when the
                                        // setting is applied later.
                                        // At that time, any error is
                                        // simply dropped.

                                        *setting = r.0.clone();
                                        r.1.ok(r.0);
                                    }
                                    None => return None
                                }
                            }
                            _ = tokio::time::sleep(delay) => {
                                // The timeout has occurred so we have
                                // to cancel the override. If the
                                // setting is the same as the
                                // override, we go into the `Synced`
                                // state. If they're different, then
                                // treat it as a new setting and
                                // return it to the driver so the
                                // hardware can be adjusted.

                                self.state = if setting != r#override {
                                    info!("timer expired ... restoring setting");
                                    State::SettingTrans {
                                        value: (setting.clone(), None)
                                    }
                                } else {
                                    State::Synced {
                                        value: r#override.clone()
                                    }
                                }
                            }
                        }
                    } else {
                        match self.set_stream.next().await {
                            Some(reply) => {
                                *setting = reply.0.clone();
                                reply.1.ok(reply.0);
                            }
                            None => return None,
                        }
                    }
                }
            }
        }
    }
}

impl<T, R> super::ResettableState for OverridableDevice<T, R>
where
    T: device::ReadWriteCompat,
    R: Reporter,
{
    fn reset_state(&mut self) {
        self.state = State::Unknown
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{device, driver::TxDeviceSetting};
    use noop_waker::noop_waker;
    use std::{
        future::Future,
        task::{Context, Poll},
    };
    use tokio::{
        sync::{mpsc, oneshot},
        time::{timeout, Duration},
    };

    struct MockReporter(mpsc::Sender<device::Value>);

    impl Reporter for MockReporter {
        async fn report_value(&mut self, v: device::Value) {
            self.0.send(v).await.unwrap()
        }
    }

    // Helper function that creates a `OverridableDevice`.

    fn mk_device<T: device::ReadWriteCompat>(
        init: Option<T>,
        tmo: Option<Duration>,
    ) -> (
        TxDeviceSetting,
        mpsc::Receiver<device::Value>,
        OverridableDevice<T, MockReporter>,
    ) {
        let (rrtx, rrrx) = mpsc::channel(20);
        let (srtx, srrx) = mpsc::channel(20);

        (
            srtx,
            rrrx,
            OverridableDevice::new(MockReporter(rrtx), srrx, init, tmo),
        )
    }

    #[tokio::test]
    async fn test_initialized_shared_device() {
        let (tx_set, mut rx_rdg, mut sh_dev) = mk_device::<i32>(Some(1), None);

        // A initialized shared device should assert the initial value.

        {
            // Nothing should be in the queue of messages going to the
            // backend.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());

            // Asking for the next setting should return the initial
            // value, but no acknowledgement function.

            assert!(matches!(
                timeout(Duration::from_secs(0), sh_dev.next_setting()).await,
                Ok(Some((1, None)))
            ));

            // The value should also go to the backend so it looks
            // like a setting.

            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Int(1)))
            ));
        }

        // Set the reading as 1 to close out the setting transaction.

        {
            // Simulate that polling the hardware returned the setting
            // that we want.

            assert!(matches!(sh_dev.report_update(1).await, ()));

            // The hardware state matches the software state. But no
            // new messages should go to the backend since we already
            // reported the value.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());

            // Nothing new is coming in, so we should see a `Pending`
            // (since we're in an async function, we test for
            // `Pending` by setting a 0 duration timeout.)

            assert!(timeout(Duration::from_secs(0), sh_dev.next_setting())
                .await
                .is_err());

            // And, still, nothing should have been reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Set the "polled" reading to 2, which puts us in override
        // mode.

        {
            assert!(matches!(sh_dev.report_update(2).await, ()));

            // Since we're in override mode, the value needs to be
            // automatically reported.

            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Int(2)))
            ));

            // Looking for a setting should result in Pending.

            assert!(timeout(Duration::from_secs(0), sh_dev.next_setting())
                .await
                .is_err());

            // Nothing further should have been reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Send a setting of 1. Since we're in override mode, it is
        // simply saved until we leave override mode.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.send((1.into(), os_tx)).await, Ok(())));

            // Looking for a setting should result in Pending.

            assert!(timeout(Duration::from_secs(0), sh_dev.next_setting())
                .await
                .is_err());

            // Client should get a reply.

            assert_eq!(os_rx.try_recv(), Ok(Ok(device::Value::Int(1))));

            // Nothing further should have been reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Now force a timeout to see if the new setting is reasserted.

        {
            // Adjust the timeout so that we guarantee it times out
            // right away.

            if let State::Overridden { tmo, .. } = &sh_dev.state {
                sh_dev.override_duration = Some(tmo.elapsed())
            } else {
                panic!(
                    "in wrong state: {:?}",
                    std::mem::discriminant(&sh_dev.state)
                );
            }

            // The previous setting (true) should be returned.

            assert!(matches!(
                timeout(Duration::from_secs(0), sh_dev.next_setting()).await,
                Ok(Some((1, None)))
            ));

            // The backend should receive the new setting, too.

            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Int(1)))
            ));
        }

        std::mem::drop(tx_set)
    }

    #[test]
    fn test_uninitialized_shared_device() {
        let (tx_set, mut rx_rdg, mut sh_dev) = mk_device::<i32>(None, None);
        let waker = noop_waker();
        let mut context = Context::from_waker(&waker);

        {
            let fut = sh_dev.next_setting();

            tokio::pin!(fut);
            assert!(fut.poll(&mut context).is_pending());
        }

        // Send a setting of 1.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.blocking_send((1.into(), os_tx)), Ok(_)));

            // `.next_setting()` should announce the new setting and
            // provide a function to send the reply.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Ready(Some((1, Some(_))))
            ));

            // The client shouldn't get a reply from the call. It
            // *should* return an Empty error, but due to lifetimes in
            // these unit tests, it returns Closed. Both errors
            // indicate the function didn't send a reply.

            assert!(os_rx.try_recv().is_err());

            // Since we have a new setting, it should have been
            // reported to the backend.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(1)));
        }

        // Send another setting of 1. The client will get a reply, but
        // the function should return `Pending`.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.blocking_send((1.into(), os_tx)), Ok(_)));

            // Client won't see another setting.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Pending
            ));

            // Client sees a setting.

            assert_eq!(os_rx.try_recv(), Ok(Ok(device::Value::Int(1))));

            // The backend should see the setting attempt.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(1)));
        }

        // Send a setting of 2. The function will return the new
        // setting.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.blocking_send((2.into(), os_tx)), Ok(_)));

            // Driver should see the setting and have a function to
            // reply to the client.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Ready(Some((2, Some(_))))
            ));

            // Client shouldn't get a reply from the shared
            // device. It's up to the driver to do that.

            assert!(os_rx.try_recv().is_err());

            // Since we have a new setting, it should have been
            // reported.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(2)));
        }

        // Register the current value as 3. Since this isn't the
        // setting value, the next setting should be reported as 2.

        {
            {
                let fut = sh_dev.report_update(3);

                tokio::pin!(fut);
                assert!(matches!(fut.poll(&mut context), Poll::Ready(_)));
            }

            // Make sure `.report_update()` didn't report a new value
            // which didn't match the setting.

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Ready(Some((2, None)))
            ));

            // Even though we're re-reporting the setting, it
            // shouldn't be forwarded to the backend storage -- we
            // still need to sync the hardware with the setting.

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );
        }

        // Register the current value as 2. Since this matches the
        // setting, this closes out the setting transaction.

        {
            {
                let fut = sh_dev.report_update(2);

                tokio::pin!(fut);
                assert!(matches!(fut.poll(&mut context), Poll::Ready(_)));
            }

            // The value was already reported.

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );

            // Nothing new is coming in, so we should see a `Pending`.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Pending
            ));

            // And nothing should have been reported.

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );
        }

        // Now register the polled reading as 3. Since this is
        // different from the setting, we should go into override
        // mode.

        {
            {
                let fut = sh_dev.report_update(3);

                tokio::pin!(fut);
                assert!(matches!(fut.poll(&mut context), Poll::Ready(_)));
            }

            // Since we're in override mode, the value needs to be
            // automatically reported.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(3)));

            // Looking for a setting should result in Pending.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Pending
            ));

            // Nothing further should have been reported.

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );
        }

        // Now it reads the hardware as 2, which matches the current
        // setting. It should be reported but no new setting should
        // appear.

        {
            {
                let fut = sh_dev.report_update(2);

                tokio::pin!(fut);
                assert!(matches!(fut.poll(&mut context), Poll::Ready(_)));
            }

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(2)));

            // Looking for a setting should result in a Pending.

            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Pending
            ));

            assert_eq!(
                rx_rdg.try_recv(),
                Err(mpsc::error::TryRecvError::Empty)
            );
        }

        // Now a new setting (2). It matches the synced state so it
        // should get reported to the backend and the client should
        // get a reply. The driver should get a pending.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.blocking_send((2.into(), os_tx)), Ok(_)));
            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Pending
            ));

            // Client should get a success reply.

            assert!(matches!(os_rx.try_recv(), Ok(Ok(device::Value::Int(2)))));

            // Since we have a new setting, it should have been
            // reported.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(2)));
        }

        // Now a new setting (7) will get reported and returned, etc.

        {
            let (os_tx, mut os_rx) = oneshot::channel();

            assert!(matches!(tx_set.blocking_send((7.into(), os_tx)), Ok(_)));
            assert!(matches!(
                {
                    let fut = sh_dev.next_setting();

                    tokio::pin!(fut);
                    fut.poll(&mut context)
                },
                Poll::Ready(Some((7, Some(_))))
            ));

            // Client shouldn't get a reply from the shared
            // device. It's up to the driver to do that.

            assert!(os_rx.try_recv().is_err());

            // Since we have a new setting, it should have been
            // reported.

            assert_eq!(rx_rdg.try_recv(), Ok(device::Value::Int(7)));
        }
    }

    #[tokio::test]
    async fn test_timed_overrides() {
        let (tx_set, mut rx_rdg, mut sh_dev) =
            mk_device::<bool>(Some(true), Some(Duration::from_secs(60)));

        // Was created with an initial value, so that should be
        // presented as the first setting.

        {
            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
            assert!(matches!(
                timeout(Duration::from_secs(0), sh_dev.next_setting()).await,
                Ok(Some((true, None)))
            ));
            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Bool(true)))
            ));
        }

        // Report the hardware as false. Since that's not the desired
        // setting, it should reassert the setting.

        {
            assert!(matches!(sh_dev.report_update(false).await, ()));

            // Make sure `.report_update()` didn't report a new value
            // which didn't match the setting.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());

            assert!(matches!(
                timeout(Duration::from_secs(0), sh_dev.next_setting()).await,
                Ok(Some((true, None)))
            ));

            // Even though we're re-reporting the setting, it
            // shouldn't be forwarded to the backend storage -- we
            // still need to sync the hardware with the setting.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Now report the hardware as 'true', which will close-out the
        // setting "transaction".

        {
            assert!(matches!(sh_dev.report_update(true).await, ()));

            // The value was already reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());

            // Nothing new is coming in, so we should see a `Pending`.

            assert!(timeout(Duration::from_secs(0), sh_dev.next_setting())
                .await
                .is_err());

            // And nothing should have been reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Now the reading is 'false' which should put us in override
        // mode.

        {
            assert!(matches!(sh_dev.report_update(false).await, ()));

            // Since we're in override mode, the value needs to be
            // automatically reported.

            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Bool(false)))
            ));

            // Looking for a setting should result in Pending.

            assert!(timeout(Duration::from_secs(0), sh_dev.next_setting())
                .await
                .is_err());

            // Nothing further should have been reported.

            assert!(timeout(Duration::from_secs(0), rx_rdg.recv())
                .await
                .is_err());
        }

        // Now force a timeout to see if the setting is reasserted.

        {
            // Adjust the timeout so that we guarantee it times out
            // right away.

            if let State::Overridden { tmo, .. } = &sh_dev.state {
                sh_dev.override_duration = Some(tmo.elapsed())
            } else {
                panic!(
                    "in wrong state: {:?}",
                    std::mem::discriminant(&sh_dev.state)
                );
            }

            // The previous setting (true) should be returned.

            assert!(matches!(
                timeout(Duration::from_secs(0), sh_dev.next_setting()).await,
                Ok(Some((true, None)))
            ));

            // The backend should receive the new setting, too.

            assert!(matches!(
                timeout(Duration::from_secs(0), rx_rdg.recv()).await,
                Ok(Some(device::Value::Bool(true)))
            ));
        }

        std::mem::drop(tx_set)
    }
}

---
FILE: drmem-api/src/driver/ro_device.rs
use crate::{device, driver::Reporter};
use std::future::Future;
use std::marker::PhantomData;

/// Represents a read-only device that uses a specified type for its
/// reading. Any type that can be converted to a `device::Value` is
/// acceptable.
pub struct ReadOnlyDevice<T: device::ReadCompat, R: Reporter> {
    reporter: R,
    phantom: PhantomData<T>,
}

impl<T, R> ReadOnlyDevice<T, R>
where
    T: device::ReadCompat,
    R: Reporter,
{
    /// Returns a new `ReadOnlyDevice` type.
    pub fn new(reporter: R) -> Self {
        ReadOnlyDevice {
            reporter,
            phantom: PhantomData,
        }
    }

    /// Saves a new value, returned by the device, to the backend
    /// storage.
    pub fn report_update(
        &mut self,
        value: T,
    ) -> impl Future<Output = ()> + use<'_, T, R> {
        self.reporter.report_value(value.into())
    }
}

---
FILE: drmem-api/src/driver/rw_device.rs
use crate::{device, driver::Reporter, Error, Result};
use std::{future::Future, marker::PhantomData, pin::Pin};
use tokio::sync::{mpsc, oneshot};
use tokio_stream::{wrappers::ReceiverStream, Stream, StreamExt};

/// This type represents the data that is transferred in the
/// communication channel. It simplifies the next two types.
pub type SettingRequest =
    (device::Value, oneshot::Sender<Result<device::Value>>);

/// Used by client APIs to send setting requests to a driver.
pub type TxDeviceSetting = mpsc::Sender<SettingRequest>;

/// Used by a driver to receive settings from a client.
pub type RxDeviceSetting = mpsc::Receiver<SettingRequest>;

/// Used by a driver to reply to a setting. The driver can indicate it
/// accepted the setting or return an error, if the setting was
/// invalid.
pub struct SettingResponder<T: device::ReadWriteCompat> {
    tx: oneshot::Sender<Result<device::Value>>,
    _marker: PhantomData<T>,
}

impl<T> SettingResponder<T>
where
    T: device::ReadWriteCompat,
{
    pub fn new(tx: oneshot::Sender<Result<device::Value>>) -> Self {
        SettingResponder {
            tx,
            _marker: PhantomData,
        }
    }

    pub fn ok(self, value: T) {
        let _ = self.tx.send(Ok(value.into()));
    }

    pub fn err(self, err: Error) {
        let _ = self.tx.send(Err(err));
    }
}

pub type SettingTransaction<T> = (T, SettingResponder<T>);

/// The driver is given a stream that yields setting requests. If the
/// driver uses a type that can be converted to and from a
/// `device::Value`, this stream will automatically reject settings
/// that aren't of the correct type and pass on converted values.
pub type SettingStream<T> =
    Pin<Box<dyn Stream<Item = SettingTransaction<T>> + Send + Sync>>;

// Creates a stream of incoming settings. Since settings are provided
// as `device::Value` types, we try to map them to the desired
// type. If the conversion can't be done, an error is automatically
// sent back to the client and the message isn't forwarded to the
// driver. Otherwise the converted value is yielded.

pub fn create_setting_stream<T>(rx: RxDeviceSetting) -> SettingStream<T>
where
    T: device::ReadWriteCompat,
{
    Box::pin(ReceiverStream::new(rx).filter_map(
        |(v, tx_rpy)| match T::try_from(v) {
            Ok(v) => Some((v, SettingResponder::new(tx_rpy))),
            Err(_) => {
                let _ = tx_rpy.send(Err(Error::TypeError));

                None
            }
        },
    ))
}

pub struct ReadWriteDevice<T: device::ReadWriteCompat, R: Reporter> {
    reporter: R,
    set_stream: SettingStream<T>,
    prev_val: Option<T>,
}

impl<T, R> ReadWriteDevice<T, R>
where
    T: device::ReadWriteCompat,
    R: Reporter,
{
    pub fn new(
        reporter: R,
        setting_chan: RxDeviceSetting,
        prev_val: Option<T>,
    ) -> Self {
        ReadWriteDevice {
            reporter,
            set_stream: create_setting_stream(setting_chan),
            prev_val,
        }
    }

    /// Saves a new value, returned by the device, to the backend
    /// storage.
    pub fn report_update(
        &mut self,
        value: T,
    ) -> impl Future<Output = ()> + use<'_, T, R> {
        self.prev_val = Some(value.clone());
        self.reporter.report_value(value.into())
    }

    /// Gets the last value of the device. If DrMem is built with
    /// persistent storage, this value will be initialized with the
    /// last value saved to storage.
    pub fn get_last(&self) -> Option<&T> {
        self.prev_val.as_ref()
    }

    pub fn next_setting(
        &mut self,
    ) -> impl Future<Output = Option<SettingTransaction<T>>> + use<'_, T, R>
    {
        self.set_stream.next()
    }
}

impl<T, R> super::ResettableState for ReadWriteDevice<T, R>
where
    T: device::ReadWriteCompat,
    R: Reporter,
{
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::sync::{mpsc, oneshot};

    #[tokio::test]
    async fn test_setting_stream() {
        // Build communication channels, including wrapping the
        // receive handle in a `SettingStream`.

        let (tx, rx) = mpsc::channel(20);
        let mut s: SettingStream<bool> = create_setting_stream(rx);
        let (os_tx, os_rx) = oneshot::channel();

        // Assert we can send to an active channel.

        assert_eq!(tx.send((true.into(), os_tx)).await.unwrap(), ());

        // Assert there's an item in the stream and that it's been
        // converted to a `bool` type.

        let (v, resp) = s.next().await.unwrap();

        assert_eq!(v, true);

        // Send back the reply -- changing it to `false`. Verify the
        // received reply is also `false`.

        resp.ok(false);

        assert_eq!(os_rx.await.unwrap().unwrap(), false.into());

        // Now try to send the wrong type to the channel. The stream
        // should reject the bad settings and return an error. This
        // means calling `.next()` will block. To avoid our tests from
        // blocking forever, we drop the `mpsc::Send` handle so the
        // stream reports end-of-stream. We can then check to see if
        // our reply was an error.

        let (os_tx, os_rx) = oneshot::channel();

        assert_eq!(tx.send(((1.0).into(), os_tx)).await.unwrap(), ());

        std::mem::drop(tx);

        assert!(s.next().await.is_none());
        assert!(os_rx.await.unwrap().is_err());
    }
}

---
FILE: drmem-api/src/lib.rs
//! Defines types and interfaces used by hardware drivers.
//!
//! The interfaces and types defined in this crate are useful for
//! those wishing to write a new driver for the `drmemd` executable.

mod types;

// Pull types down to the `drmem-api` namespace.

pub use types::device;
pub use types::Error;

/// A specialization of `std::result::Result<>` where the error value
/// is `types::Error`.
pub type Result<T> = std::result::Result<T, Error>;

pub mod client;
pub mod driver;

---
FILE: drmem-api/src/types/device/mod.rs
//! Defines types related to devices.

use std::{pin::Pin, time};
use tokio_stream::Stream;

mod value;
pub use value::{ReadCompat, ReadWriteCompat, Value};

/// Represents the value of a device at a specific moment.
///
/// When a client monitors a device, it receives a stream of readings
/// as the device gets updated. A reading consists of the value of the
/// device along with the timestamp. The set of types that a device
/// can return is defined in the `Value` type. The timestamp is given
/// in UTC.
#[derive(Debug, PartialEq, Clone)]
pub struct Reading {
    pub ts: time::SystemTime,
    pub value: Value,
}

/// Generic type describing a stream of types.
///
/// Specializations of this type are used in various layers of
/// `drmemd`. The drivers, for instance, provide a stream of `Reading`
/// types. The GraphQL layer converts it into a stream of replies.
pub type DataStream<T> = Pin<Box<dyn Stream<Item = T> + Send>>;

mod name;
pub use name::Base;
pub use name::Name;
pub use name::Path;

---
FILE: drmem-api/src/types/device/name.rs
//! Defines and enforces device name requirements.
//!
//! Every device in a running instance of `drmemd` needs to have a
//! unique name. A device name is made up of segments separated with
//! colons. The last segment is the base name of the device and all
//! previous segments are the "path" of the device. A segment consists
//! of one or more UTF-8 alphanumeric or dash characters.
//!
//! In a `[[driver]]` section of `drmemd`'s configuration file, a path
//! is specified for the driver instance and the driver provides the
//! base names for its set of devices.
use crate::{types::Error, Result};
use serde::Deserialize;
use std::fmt;

#[derive(Debug, Clone, PartialEq, Deserialize, Hash, Eq)]
struct Segment(String);

impl Segment {
    // Returns `true` if the character can be used in a segment of the
    // device name.

    fn is_valid_char((idx, ch): (usize, char), len: usize) -> bool {
        ch.is_alphanumeric() || (ch == '-' && idx != 0 && idx != len - 1)
    }

    // Creates a `Segment`, if the strings contains a well-formed
    // segment name.

    fn create(s: &str) -> Result<Self> {
        if !s.is_empty() {
            if s.chars()
                .enumerate()
                .all(|v| Segment::is_valid_char(v, s.len()))
            {
                Ok(Segment(String::from(s)))
            } else {
                Err(Error::InvArgument(String::from(
                    "segment contains invalid character",
                )))
            }
        } else {
            Err(Error::InvArgument(String::from(
                "contains zero-length segment",
            )))
        }
    }
}

impl TryFrom<String> for Segment {
    type Error = Error;

    fn try_from(s: String) -> Result<Self> {
        Segment::create(&s)
    }
}

impl TryFrom<&str> for Segment {
    type Error = Error;

    fn try_from(s: &str) -> Result<Self> {
        Segment::create(s)
    }
}

impl fmt::Display for Segment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

/// A type which models a device's path.
///
/// A path is a series of segments, where segments are made up of one
/// or more alphanumeric or dash characters.
#[derive(Debug, PartialEq, Clone, Deserialize, Hash, Eq)]
#[serde(try_from = "String")]
pub struct Path(Vec<Segment>);

impl Path {
    /// Creates a `Path` from a string slice. If any segment contains
    /// an invalid character, an `Err()` is returned.
    pub fn create(s: &str) -> Result<Self> {
        s.split(':')
            .map(Segment::create)
            .collect::<Result<Vec<Segment>>>()
            .map(Path)
    }
}

// This trait is defined so that the .TOML parser will use it to parse
// the device prefix field. Without this, the .TOML parser wants array
// notation for the path specification (because `Path` is a newtype
// that wraps a `Vec<>`.)

impl TryFrom<String> for Path {
    type Error = Error;

    fn try_from(s: String) -> Result<Self> {
        Path::create(&s)
    }
}

impl TryFrom<&str> for Path {
    type Error = Error;

    fn try_from(s: &str) -> Result<Self> {
        Path::create(s)
    }
}

impl fmt::Display for Path {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", &self.0[0])?;
        for ii in &self.0[1..] {
            write!(f, ":{}", &ii)?
        }
        Ok(())
    }
}

/// A type representing the base name of a device.
///
/// The base name consists of one or more alphanumeric or dash
/// characters.
#[derive(Debug, PartialEq, Clone, Deserialize, Hash, Eq)]
#[serde(try_from = "String")]
pub struct Base(Segment);

impl Base {
    /// Creates a `Base` from a string slice. If it contains an
    /// invalid character, `Err()` is returned.
    pub fn create(s: &str) -> Result<Self> {
        Segment::create(s).map(Base)
    }
}

impl TryFrom<String> for Base {
    type Error = Error;

    fn try_from(s: String) -> Result<Self> {
        Base::create(&s)
    }
}

impl TryFrom<&String> for Base {
    type Error = Error;

    fn try_from(s: &String) -> Result<Self> {
        Base::create(s)
    }
}

impl TryFrom<&str> for Base {
    type Error = Error;

    fn try_from(s: &str) -> Result<Self> {
        Base::create(s)
    }
}

impl fmt::Display for Base {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", &self.0)
    }
}

/// Holds a validated device name. A device name consists of a path
/// and a base name where each portion of the path is separated with a
/// colon. Each segment of the path or the name is composed of alpha-
/// numeric and the dash characters. The dash cannot be the first or
/// last character, however.
///
/// More formally:
///
/// ```ignore
/// DEVICE-NAME = PATH NAME
/// PATH = (SEGMENT ':')+
/// NAME = SEGMENT
/// SEGMENT = [0-9a-zA-Z] ( [0-9a-zA-Z-]* [0-9a-zA-Z] )?
/// ```
///
/// All device names will have a path and a name. Although
/// superficially similar, device names are not like file system
/// names. Specifically, there's no concept of moving up or down
/// paths. The paths provide a naming convention to organize devices.
/// The client API supports looking up device names using patterns, so
/// a logical path hierarchy can make those searches more productive.
#[derive(Debug, PartialEq, Hash, Eq, Clone, Deserialize)]
#[serde(try_from = "String")]
pub struct Name {
    path: Path,
    base: Base,
}

impl Name {
    /// Creates an instance of `Name`, if the provided string
    /// describes a well-formed device name.
    pub fn create(s: &str) -> Result<Name> {
        match s
            .split(':')
            .map(Segment::create)
            .collect::<Result<Vec<Segment>>>()
        {
            Ok(segments) if segments.len() < 2 => Err(Error::InvArgument(
                String::from("device name requires a path and base name"),
            )),
            Ok(segments) => Ok(Name {
                path: Path(segments[0..segments.len() - 1].to_vec()),
                base: Base(segments[segments.len() - 1].clone()),
            }),
            Err(e) => Err(e),
        }
    }

    /// Builds a device name from `Path` and `Base` components.
    pub fn build(path: Path, base: Base) -> Name {
        Name { path, base }
    }

    /// Returns the path of the device name without the trailing ':'.
    pub fn get_path(&self) -> Path {
        self.path.clone()
    }

    /// Returns the base name of the device.
    pub fn get_name(&self) -> Base {
        self.base.clone()
    }
}

impl fmt::Display for Name {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", &self.path, &self.base)
    }
}

impl TryFrom<String> for Name {
    type Error = Error;

    fn try_from(s: String) -> Result<Self> {
        Name::create(&s)
    }
}

impl TryFrom<&str> for Name {
    type Error = Error;

    fn try_from(s: &str) -> Result<Self> {
        Name::create(s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_segment() {
        assert!(TryInto::<Segment>::try_into("").is_err());
        assert!(TryInto::<Segment>::try_into(
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        )
        .is_ok());
        assert!(TryInto::<Segment>::try_into("a-b").is_ok());
        assert!(TryInto::<Segment>::try_into("a:b").is_err());
        assert!(TryInto::<Segment>::try_into("-a").is_err());
        assert!(TryInto::<Segment>::try_into("a-").is_err());
        assert!(TryInto::<Segment>::try_into(" ").is_err());
        assert_eq!(
            format!("{}", TryInto::<Segment>::try_into("a-b").unwrap()),
            "a-b"
        );

        // Check non-ASCII entries.

        assert!(TryInto::<Segment>::try_into("").is_ok());
        assert!(TryInto::<Segment>::try_into("").is_ok());
        assert!(TryInto::<Segment>::try_into("").is_err());
    }

    #[test]
    fn test_base() {
        assert_eq!(
            format!("{}", TryInto::<Base>::try_into("a-b").unwrap()),
            "a-b"
        );
        assert!(TryInto::<Base>::try_into("a:b").is_err());
    }

    #[test]
    fn test_path() {
        assert!(TryInto::<Path>::try_into("").is_err());
        assert!(TryInto::<Path>::try_into("basement:").is_err());

        assert_eq!(
            format!("{}", TryInto::<Path>::try_into("a-b").unwrap()),
            "a-b"
        );
        assert_eq!(
            format!("{}", TryInto::<Path>::try_into("a:b").unwrap()),
            "a:b"
        );
        assert_eq!(
            format!("{}", TryInto::<Path>::try_into("a:b:c").unwrap()),
            "a:b:c"
        );
        assert_eq!(
            format!("{}", TryInto::<Path>::try_into(":").unwrap()),
            ":"
        );
    }

    #[test]
    fn test_device_name() {
        assert!(TryInto::<Name>::try_into("").is_err());
        assert!(TryInto::<Name>::try_into(":").is_err());
        assert!(TryInto::<Name>::try_into("a").is_err());
        assert!(TryInto::<Name>::try_into(":a").is_err());
        assert!(TryInto::<Name>::try_into("a:").is_err());
        assert!(TryInto::<Name>::try_into("a::a").is_err());

        assert!(TryInto::<Name>::try_into("p:a.").is_err());
        assert!(TryInto::<Name>::try_into("p:a.a").is_err());
        assert!(TryInto::<Name>::try_into("p.a:a").is_err());
        assert!(TryInto::<Name>::try_into("p:a-").is_err());
        assert!(TryInto::<Name>::try_into("p:-a").is_err());
        assert!(TryInto::<Name>::try_into("p-:a").is_err());
        assert!(TryInto::<Name>::try_into("-p:a").is_err());

        assert_eq!(
            TryInto::<Name>::try_into("p:abc").unwrap(),
            Name {
                path: Path::create("p").unwrap(),
                base: Base::create("abc").unwrap(),
            }
        );
        assert_eq!(
            TryInto::<Name>::try_into("p:abc1").unwrap(),
            Name {
                path: Path::create("p").unwrap(),
                base: Base::create("abc1").unwrap(),
            }
        );
        assert_eq!(
            TryInto::<Name>::try_into("p:abc-1").unwrap(),
            Name {
                path: Path::create("p").unwrap(),
                base: Base::create("abc-1").unwrap(),
            }
        );
        assert_eq!(
            TryInto::<Name>::try_into("p-1:p-2:abc").unwrap(),
            Name {
                path: Path::create("p-1:p-2").unwrap(),
                base: Base::create("abc").unwrap(),
            }
        );

        let dn = TryInto::<Name>::try_into("p-1:p-2:abc").unwrap();

        assert_eq!(dn.get_path(), Path::create("p-1:p-2").unwrap());
        assert_eq!(dn.get_name(), Base::create("abc").unwrap());

        assert_eq!(format!("{}", dn), "p-1:p-2:abc");
    }
}

---
FILE: drmem-api/src/types/device/value.rs
use crate::types::Error;
use serde::{
    de::{self, Visitor},
    Deserialize, Deserializer,
};
use std::{convert::TryFrom, fmt, sync::Arc};

/// Defines fundamental types that can be associated with a device.
/// Drivers set the type for each device they manage and, for devices
/// that can be set, only accept values of the correct type.

#[derive(Clone, Debug, PartialEq)]
pub enum Value {
    /// For devices that return/accept a simple true/false, on/off,
    /// etc., state.
    Bool(bool),

    /// For devices that return/accept an integer value. It is stored
    /// as a signed, 32-bit. This type should primarily be used for
    /// digital inputs/outputs. There is no 64-bit version because
    /// Javascript doesn't support a 64-bit integer. For integer
    /// values greater than 32 bits, use a `Flt` since it can
    /// losslessly handle integers up to 52 bits.
    Int(i32),

    /// For devices that return/accept floating point numbers or
    /// integers up to 52 bits.
    Flt(f64),

    /// For devices that return/accept text. Since strings can greatly
    /// vary in size, care must be taken when returning this type. A
    /// driver that returns strings rapidly should keep them short.
    /// Longer strings should be returned at a slower rate. If the
    /// system takes too much time serializing string data, it could
    /// throw other portions of DrMem out of "soft real-time".
    Str(Arc<str>),

    /// For devices that render color values.
    Color(palette::LinSrgba<u8>),
}

impl Value {
    pub fn is_same_type(&self, o: &Value) -> bool {
        matches!(
            (self, o),
            (Value::Bool(_), Value::Bool(_))
                | (Value::Int(_), Value::Int(_))
                | (Value::Flt(_), Value::Flt(_))
                | (Value::Str(_), Value::Str(_))
                | (Value::Color(_), Value::Color(_))
        )
    }
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Bool(v) => write!(f, "{v}"),
            Value::Int(v) => write!(f, "{v}"),
            Value::Flt(v) => write!(f, "{v}"),
            Value::Str(v) => write!(f, "\"{v}\""),
            Value::Color(v) => {
                write!(f, "\"#{:02x}{:02x}{:02x}", v.red, v.green, v.blue)?;
                if v.alpha < 255 {
                    write!(f, "{:02x}", v.alpha)?;
                }
                write!(f, "\"")
            }
        }
    }
}

pub trait ReadCompat: Into<Value> + PartialEq + Clone + Send {}

pub trait ReadWriteCompat: ReadCompat + TryFrom<Value> {}

impl ReadCompat for Value {}

impl ReadWriteCompat for Value {}

impl TryFrom<Value> for bool {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Bool(v) = value {
            Ok(v)
        } else {
            Err(Error::TypeError)
        }
    }
}

impl From<bool> for Value {
    fn from(value: bool) -> Self {
        Value::Bool(value)
    }
}

impl ReadCompat for bool {}

impl ReadWriteCompat for bool {}

impl TryFrom<Value> for i32 {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Int(v) = value {
            return Ok(v);
        }
        Err(Error::TypeError)
    }
}

impl From<i32> for Value {
    fn from(value: i32) -> Self {
        Value::Int(value)
    }
}

impl ReadCompat for i32 {}

impl ReadWriteCompat for i32 {}

impl TryFrom<Value> for i16 {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Int(v) = value {
            if let Ok(v) = i16::try_from(v) {
                return Ok(v);
            }
        }
        Err(Error::TypeError)
    }
}

impl From<i16> for Value {
    fn from(value: i16) -> Self {
        Value::Int(i32::from(value))
    }
}

impl ReadCompat for i16 {}

impl ReadWriteCompat for i16 {}

impl TryFrom<Value> for u16 {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Int(v) = value {
            if let Ok(v) = u16::try_from(v) {
                return Ok(v);
            }
        }
        Err(Error::TypeError)
    }
}

impl From<u16> for Value {
    fn from(value: u16) -> Self {
        Value::Int(i32::from(value))
    }
}

impl ReadCompat for u16 {}

impl ReadWriteCompat for u16 {}

impl TryFrom<Value> for f64 {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Flt(v) = value {
            Ok(v)
        } else {
            Err(Error::TypeError)
        }
    }
}

impl From<f64> for Value {
    fn from(value: f64) -> Self {
        Value::Flt(value)
    }
}

impl ReadCompat for f64 {}

impl ReadWriteCompat for f64 {}

impl TryFrom<Value> for String {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Str(v) = value {
            Ok(v.to_string())
        } else {
            Err(Error::TypeError)
        }
    }
}

impl TryFrom<Value> for Arc<str> {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Str(v) = value {
            Ok(v)
        } else {
            Err(Error::TypeError)
        }
    }
}

impl From<String> for Value {
    fn from(value: String) -> Self {
        Value::Str(value.into())
    }
}

impl From<Arc<str>> for Value {
    fn from(value: Arc<str>) -> Self {
        Value::Str(value)
    }
}

impl From<&str> for Value {
    fn from(value: &str) -> Self {
        Value::Str(value.into())
    }
}

impl ReadCompat for String {}

impl ReadWriteCompat for String {}

impl ReadCompat for Arc<str> {}

impl ReadWriteCompat for Arc<str> {}

impl ReadCompat for &str {}

impl From<palette::LinSrgba<u8>> for Value {
    fn from(value: palette::LinSrgba<u8>) -> Self {
        Value::Color(value)
    }
}

impl TryFrom<Value> for palette::LinSrgba<u8> {
    type Error = Error;

    fn try_from(value: Value) -> Result<Self, Self::Error> {
        if let Value::Color(v) = value {
            Ok(v)
        } else {
            Err(Error::TypeError)
        }
    }
}

impl ReadCompat for palette::LinSrgba<u8> {}

impl ReadWriteCompat for palette::LinSrgba<u8> {}

// Parses a color from a string. The only forms currently supported
// are "#RRGGBB" and "#RRGGBBAA" where the red, green, blue, and alpha
// portions are two hex digits. Even though this function takes a
// slice, it's a private function and we know we only call it when the
// slice has exactly 6 or 8 hex digits so we don't have to test to see
// if the result exceeds 0xffffff.

fn parse_color(s: &[u8]) -> Option<Value> {
    let mut result = 0u32;

    for ii in s {
        if ii.is_ascii_digit() {
            result = (result << 4) + (ii - b'0') as u32;
        } else if (b'A'..=b'F').contains(ii) {
            result = (result << 4) + (ii - b'A' + 10) as u32;
        } else if (b'a'..=b'f').contains(ii) {
            result = (result << 4) + (ii - b'a' + 10) as u32;
        } else {
            return None;
        }
    }

    if s.len() == 6 {
        result = (result << 8) + 255;
    }

    Some(Value::Color(palette::LinSrgba::new(
        (result >> 24) as u8,
        (result >> 16) as u8,
        (result >> 8) as u8,
        result as u8,
    )))
}

impl TryFrom<&toml::value::Value> for Value {
    type Error = Error;

    fn try_from(value: &toml::value::Value) -> Result<Self, Self::Error> {
        match value {
            toml::value::Value::Boolean(v) => Ok(Value::Bool(*v)),
            toml::value::Value::Integer(v) => i32::try_from(*v)
                .map(Value::Int)
                .map_err(|_| Error::TypeError),
            toml::value::Value::Float(v) => Ok(Value::Flt(*v)),
            toml::value::Value::String(v) => match v.as_bytes() {
                tmp @ &[b'#', _, _, _, _, _, _]
                | tmp @ &[b'#', _, _, _, _, _, _, _, _] => {
                    if let Some(v) = parse_color(&tmp[1..]) {
                        Ok(v)
                    } else {
                        Ok(Value::Str(v.to_owned().into()))
                    }
                }
                _ => Ok(Value::Str(v.to_owned().into())),
            },
            _ => Err(Error::TypeError),
        }
    }
}

impl<'de> Deserialize<'de> for Value {
    fn deserialize<D>(deserializer: D) -> Result<Value, D::Error>
    where
        D: Deserializer<'de>,
    {
        struct ValueVisitor;

        impl<'de> Visitor<'de> for ValueVisitor {
            type Value = Value;

            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                write!(formatter, "a boolean, integer, float, string, or color")
            }

            fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E> {
                Ok(Value::Bool(v))
            }

            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                i32::try_from(v).map(Value::Int).map_err(|_| {
                    E::custom("integer out of range for Value::Int")
                })
            }

            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                if v <= i32::MAX as u64 {
                    Ok(Value::Int(v as i32))
                } else {
                    Err(E::custom("integer out of range for Value::Int"))
                }
            }

            fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E> {
                Ok(Value::Flt(v))
            }

            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                let bytes = v.as_bytes();

                if (bytes.len() == 7 || bytes.len() == 9) && bytes[0] == b'#' {
                    if let Some(col) = parse_color(&bytes[1..]) {
                        return Ok(col);
                    }
                }
                Ok(Value::Str(Arc::from(v)))
            }

            fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
            where
                E: de::Error,
            {
                self.visit_str(&v)
            }
        }

        deserializer.deserialize_any(ValueVisitor)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::convert::TryFrom;

    #[derive(serde::Deserialize)]
    struct AllTypes {
        bool_val: Value,
        int_val: Value,
        flt_val: Value,
        str_val: Value,
        col_val: Value,
    }

    #[test]
    fn test_de_device_values() {
        let cfg: AllTypes = toml::from_str(
            "
bool_val = true
int_val = 123
flt_val = 1234.5
str_val = \"hello\"
col_val = \"#ff00ff\"
",
        )
        .unwrap();

        assert_eq!(cfg.bool_val, Value::Bool(true));
        assert_eq!(cfg.int_val, Value::Int(123));
        assert_eq!(cfg.flt_val, Value::Flt(1234.5));
        assert_eq!(cfg.str_val, Value::Str("hello".into()));
        assert_eq!(
            cfg.col_val,
            Value::Color(palette::LinSrgba::new(255, 0, 255, 255))
        );
    }

    #[test]
    fn test_device_values_to() {
        assert_eq!("false", format!("{}", Value::Bool(false)));
        assert_eq!("true", format!("{}", Value::Bool(true)));

        assert_eq!("0", format!("{}", Value::Int(0)));
        assert_eq!("1", format!("{}", Value::Int(1)));
        assert_eq!("-1", format!("{}", Value::Int(-1)));
        assert_eq!("-2147483648", format!("{}", Value::Int(-0x80000000)));
        assert_eq!("2147483647", format!("{}", Value::Int(0x7fffffff)));

        assert_eq!(
            "\"#010203\"",
            format!("{}", Value::Color(palette::LinSrgba::new(1, 2, 3, 255)))
        );
        assert_eq!(
            "\"#01020304\"",
            format!("{}", Value::Color(palette::LinSrgba::new(1, 2, 3, 4)))
        );
    }

    #[test]
    fn test_device_values_from() {
        assert_eq!(Value::Bool(true), Value::from(true));
        assert_eq!(Value::Bool(false), Value::from(false));

        assert_eq!(Value::Int(0), Value::from(0i32));
        assert_eq!(Value::Int(-1), Value::from(-1i32));
        assert_eq!(Value::Int(2), Value::from(2i32));
        assert_eq!(Value::Int(-3), Value::from(-3i16));
        assert_eq!(Value::Int(4), Value::from(4u16));

        assert_eq!(Value::Flt(5.0), Value::from(5.0f64));

        assert_eq!(Value::Str("hello".into()), "hello".into());

        // Cycle through 256 values.

        for ii in 1..=255u8 {
            let r: u8 = ii;
            let g: u8 = ii ^ 0xa5u8;
            let b: u8 = 255u8 - ii;
            let a: u8 = ii ^ 0x81u8;

            assert_eq!(
                Value::Color(palette::LinSrgba::new(r, g, b, a)),
                Value::from(palette::LinSrgba::new(r, g, b, a))
            );
        }
    }

    #[test]
    fn test_device_values_tryfrom() {
        // Check that we can convert bool values.

        assert_eq!(bool::try_from(Value::Bool(true)), Ok(true));
        assert!(bool::try_from(Value::Int(0)).is_err());
        assert!(bool::try_from(Value::Flt(0.0)).is_err());
        assert!(bool::try_from(Value::Str("hello".into())).is_err());

        // Check that we can convert i32 values.

        assert!(i32::try_from(Value::Bool(true)).is_err());
        assert_eq!(i32::try_from(Value::Int(0x7fffffffi32)), Ok(0x7fffffffi32));
        assert_eq!(
            i32::try_from(Value::Int(-0x80000000i32)),
            Ok(-0x80000000i32)
        );
        assert!(i32::try_from(Value::Flt(0.0)).is_err());
        assert!(i32::try_from(Value::Str("hello".into())).is_err());

        // Check that we can convert i16 values.

        assert!(i16::try_from(Value::Bool(true)).is_err());
        assert_eq!(i16::try_from(Value::Int(0x7fffi32)), Ok(0x7fffi16));
        assert_eq!(i16::try_from(Value::Int(-0x8000i32)), Ok(-0x8000i16));
        assert!(i16::try_from(Value::Int(0x8000i32)).is_err());
        assert!(i16::try_from(Value::Int(-0x8000i32 - 1i32)).is_err());
        assert!(i16::try_from(Value::Flt(0.0)).is_err());
        assert!(i16::try_from(Value::Str("hello".into())).is_err());

        // Check that we can convert u16 values.

        assert!(u16::try_from(Value::Bool(true)).is_err());
        assert_eq!(u16::try_from(Value::Int(0xffffi32)), Ok(0xffffu16));
        assert_eq!(u16::try_from(Value::Int(0i32)), Ok(0u16));
        assert!(u16::try_from(Value::Int(0x10000i32)).is_err());
        assert!(u16::try_from(Value::Int(-1i32)).is_err());
        assert!(u16::try_from(Value::Flt(0.0)).is_err());
        assert!(u16::try_from(Value::Str("hello".into())).is_err());
    }

    #[test]
    fn test_toml_value_tryfrom() {
        assert_eq!(
            Value::try_from(&toml::value::Value::Boolean(true)),
            Ok(Value::Bool(true))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Boolean(false)),
            Ok(Value::Bool(false))
        );

        assert_eq!(
            Value::try_from(&toml::value::Value::Integer(0)),
            Ok(Value::Int(0))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Integer(10)),
            Ok(Value::Int(10))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Integer(-10)),
            Ok(Value::Int(-10))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Integer(0x7fffffff)),
            Ok(Value::Int(0x7fffffff))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Integer(-0x80000000)),
            Ok(Value::Int(-0x80000000))
        );
        assert!(
            Value::try_from(&toml::value::Value::Integer(-0x80000001)).is_err(),
        );
        assert!(
            Value::try_from(&toml::value::Value::Integer(0x80000000)).is_err(),
        );

        assert_eq!(
            Value::try_from(&toml::value::Value::Float(0.0)),
            Ok(Value::Flt(0.0))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Float(10.0)),
            Ok(Value::Flt(10.0))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::Float(-10.0)),
            Ok(Value::Flt(-10.0))
        );

        assert_eq!(
            Value::try_from(&toml::value::Value::String("hello".into())),
            Ok(Value::Str("hello".into()))
        );

        assert_eq!(
            Value::try_from(&toml::value::Value::String("#".into())),
            Ok(Value::Str("#".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#1".into())),
            Ok(Value::Str("#1".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#12".into())),
            Ok(Value::Str("#12".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#123".into())),
            Ok(Value::Str("#123".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#1234".into())),
            Ok(Value::Str("#1234".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#12345".into())),
            Ok(Value::Str("#12345".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#1234567".into())),
            Ok(Value::Str("#1234567".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#123456789".into())),
            Ok(Value::Str("#123456789".into()))
        );
        assert_eq!(
            Value::try_from(&toml::value::Value::String("#1234567z".into())),
            Ok(Value::Str("#1234567z".into()))
        );

        // Cycle through 256 semi-random colors. Make sure the parsing
        // handles upper and lower case hex digits.

        for ii in 1..=255u8 {
            let r: u8 = ii;
            let g: u8 = ii ^ 0xa5u8;
            let b: u8 = 255u8 - ii;
            let a: u8 = ii ^ 0xc3u8;

            assert_eq!(
                Value::try_from(&toml::value::Value::String(format!(
                    "#{:02x}{:02x}{:02x}",
                    r, g, b
                )))
                .unwrap(),
                Value::Color(palette::LinSrgba::new(r, g, b, 255))
            );
            assert_eq!(
                Value::try_from(&toml::value::Value::String(format!(
                    "#{:02X}{:02X}{:02X}",
                    r, g, b
                )))
                .unwrap(),
                Value::Color(palette::LinSrgba::new(r, g, b, 255))
            );
            assert_eq!(
                Value::try_from(&toml::value::Value::String(format!(
                    "#{:02x}{:02x}{:02x}{:02x}",
                    r, g, b, a
                )))
                .unwrap(),
                Value::Color(palette::LinSrgba::new(r, g, b, a))
            );
            assert_eq!(
                Value::try_from(&toml::value::Value::String(format!(
                    "#{:02X}{:02X}{:02X}{:02X}",
                    r, g, b, a
                )))
                .unwrap(),
                Value::Color(palette::LinSrgba::new(r, g, b, a))
            );
        }

        assert!(Value::try_from(&toml::value::Value::Datetime(
            toml::value::Datetime {
                date: None,
                time: None,
                offset: None
            }
        ))
        .is_err());
        assert!(Value::try_from(&toml::value::Value::Array(vec![])).is_err());
        assert!(Value::try_from(&toml::value::Value::Table(
            toml::map::Map::new()
        ))
        .is_err());
    }
}

---
FILE: drmem-api/src/types/mod.rs
//! Defines fundamental types used throughout the DrMem codebase.

use std::fmt;

use std::convert::Infallible;
use tokio::sync::{mpsc, oneshot};

pub mod device;

/// Enumerates all the errors that can be reported in DrMem. Authors
/// for new drivers or storage backends should try to map their errors
/// into one of these values. If no current value is appropriate, a
/// new one could be added (requiring a new release of this crate) but
/// make sure the new error code is generic enough that it may be
/// useful for other drivers or backends. For instance, don't add an
/// error value that is specific to Redis. Add a more general value
/// and use the associated description string to explain the details.

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Error {
    /// Returned whenever a resource cannot be found.
    NotFound,

    /// A resource is already in use.
    InUse,

    /// The device name is already registered to another driver.
    DeviceDefined(String),

    /// Reported when the peer of a communication channel has closed
    /// its handle.
    MissingPeer(String),

    /// A type mismatch is preventing the operation from continuing.
    TypeError,

    /// An invalid value was provided.
    InvArgument(String),

    /// A general error returned by the backend storage. The string
    /// will have more information about the error.
    BackendError(String),

    /// Communication was disrupted due to one end not following a
    /// protocol.
    ProtocolError(String),

    /// The requested operation cannot complete because the process
    /// hasn't provided proper authentication credentials.
    AuthenticationError,

    /// An operation didn't complete in a timely fashion.
    TimeoutError,

    /// The requested operation couldn't complete. The description
    /// field will have more information for the user.
    OperationError(String),

    /// A bad parameter was given in a configuration or a
    /// configuration was missing a required parameter.
    ConfigError(String),

    /// There was a problem parsing a string. The associated string
    /// will describe how the parsing failed.
    ParseError(String),
}

impl std::error::Error for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::NotFound => write!(f, "item not found"),
            Error::InUse => write!(f, "item is in use"),
            Error::DeviceDefined(name) => {
                write!(f, "device {} is already defined", &name)
            }
            Error::MissingPeer(detail) => {
                write!(f, "{detail} is missing peer")
            }
            Error::TypeError => write!(f, "incorrect type"),
            Error::InvArgument(v) => write!(f, "{}", &v),
            Error::BackendError(v) => {
                write!(f, "backend error: {}", &v)
            }
            Error::ProtocolError(v) => write!(f, "protocol error: {}", &v),
            Error::AuthenticationError => write!(f, "permission error"),
            Error::TimeoutError => write!(f, "timeout"),
            Error::OperationError(v) => {
                write!(f, "couldn't complete operation: {}", &v)
            }
            Error::ConfigError(v) => write!(f, "config error: {}", &v),
            Error::ParseError(v) => write!(f, "parse error: {}", &v),
        }
    }
}

// Defining these trait implementations allows any code that sends
// requests over an `mpsc` channel and expects the reply in a
// `oneshot` to easily translate the channel errors into a DrMem
// error.

impl<T> From<mpsc::error::SendError<T>> for Error {
    fn from(_error: mpsc::error::SendError<T>) -> Self {
        Error::MissingPeer(String::from("request channel is closed"))
    }
}

impl From<oneshot::error::RecvError> for Error {
    fn from(_error: oneshot::error::RecvError) -> Self {
        Error::MissingPeer(String::from("request dropped"))
    }
}

impl From<Infallible> for Error {
    fn from(_: Infallible) -> Self {
        unreachable!()
    }
}

---
FILE: drmemd/Cargo.toml
[package]
name = "drmemd"
version = "0.7.1"
authors = ["Rich Neswold <rich.neswold@gmail.com>"]
edition = "2021"
description = "Main process of the DrMem control system"
homepage = "https://github.com/DrMemCS/drmem"
repository = "https://github.com/DrMemCS/drmem"
license = "MIT"
categories = ["embedded", "hardware-support"]
keywords = ["control-system", "automation"]

[badges]
maintenance = { status = "actively-developed" }

[build-dependencies]
cfgrammar = "0.13"
lrlex = "0.13"
lrpar = "0.13"

[dependencies]
futures.workspace = true
futures.default-features = false
futures.features = ["alloc", "std"]

toml.workspace = true
toml.default-features = false
toml.features = ["parse"]

tokio.workspace = true
tokio.default-features = false
tokio.features = ["rt-multi-thread", "time", "fs", "macros"]

tokio-stream.workspace = true
tokio-stream.default-features = false
tokio-stream.features = ["net", "sync"]

tracing.workspace = true
tracing.default-features = false
tracing.features = ["attributes"]

tracing-subscriber.workspace = true
tracing-subscriber.default-features = false
tracing-subscriber.features = ["ansi"]

serde.workspace = true
serde.default-features = false
serde.features = ["derive"]

clap.version = "4"
clap.default-features = false
clap.features = ["cargo", "std"]

chrono.workspace = true
chrono.default-features = false
chrono.features = ["clock"]

palette.workspace = true
palette.default-features = false
palette.features = ["libm", "named", "named_from_str"]

lazy_static = { version = "1", default-features = false }

drmem-api = { path = "../drmem-api", version = "0.7" }

cfgrammar.version = "0.13"
cfgrammar.default-features = false

lrlex.version = "0.13"
lrlex.default-features = false

lrpar.version = "0.13"
lrpar.default-features = false

[dev-dependencies]

tokio-stream.workspace = true
tokio-stream.default-features = false
tokio-stream.features = ["sync", "time"]

noop-waker = "0.1"

# This section defines the driver dependencies. Most drivers are
# optional, but a few drivers define common devices for a `drmem`
# installation.

[dependencies.drmem-drv-ntp]
path = "../drivers/drmem-drv-ntp"
version = "0.7"
optional = true

[dependencies.drmem-drv-sump]
path = "../drivers/drmem-drv-sump"
version = "0.7"
optional = true

[dependencies.drmem-drv-tplink]
path = "../drivers/drmem-drv-tplink"
version = "0.7"
optional = true

[dependencies.drmem-drv-weather-wu]
path = "../drivers/drmem-drv-weather-wu"
version = "0.7"
optional = true

# This section defines the optional dependencies for backend storage.

[dependencies.redis]
version = "0.32"
default-features = false
features = ["tokio-comp", "streams", "tcp_nodelay"]
optional = true

# This section defines the optional dependencies for the 'graphql'
# feature.

[dependencies.juniper]
version = "0.16"
default-features = false
features = ["chrono"]
optional = true

[dependencies.juniper_warp]
version = "0.8"
default-features = false
features = ["subscriptions"]
optional = true

[dependencies.juniper_graphql_ws]
version = "0.4"
default-features = false
optional = true

[dependencies.warp]
version = "0.3"
default-features = false
features = ["tls", "compression-gzip"]
optional = true

[dependencies.libmdns]
version = "0.9"
default-features = false
optional = true

[dependencies.rustls-pki-types]
version = "1.11"
default-features = false
optional = true

[dependencies.ring]
version = "0.17"
default-features = false
optional = true

[dependencies.rustls-pemfile]
version = "1"
default-features = false
optional = true

# These are features that can be enabled for drmem.

[features]
default = []

# Backends

simple-backend = []
redis-backend = ["dep:redis", "graphql"]

# Client APIs

no-client = []
graphql = ["dep:warp", "dep:juniper", "dep:juniper_graphql_ws",
           "dep:juniper_warp", "dep:libmdns", "dep:rustls-pki-types",
           "dep:ring", "dep:rustls-pemfile"]
graphiql = ["graphql"]

# Drivers

all-drivers = ["drmem-drv-ntp", "drmem-drv-sump", "drmem-drv-tplink",
               "drmem-drv-weather-wu"]

---
FILE: drmemd/build.rs
use cfgrammar::yacc::YaccKind;
use lrlex::CTLexerBuilder;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    CTLexerBuilder::new()
        .lrpar_config(|ctp| {
            ctp.yacckind(YaccKind::Grmtools)
                .recoverer(lrpar::RecoveryKind::None)
                .grammar_in_src_dir("logic/logic.y")
                .unwrap()
        })
        .lexer_in_src_dir("logic/logic.l")?
        .build()?;
    Ok(())
}

---
FILE: drmemd/src/backends/mod.rs
use chrono::{DateTime, Utc};
use drmem_api::{client, device, driver, Result};
use futures::Future;

// Defines the trait that a back-end needs to implement to provide
// storage for -- and access to -- the state of each driver's devices.

pub trait Store {
    type Reporter: driver::Reporter;

    // Called when a read-only device is to be registered with the
    // back-end.
    //
    // When `drmemd` begins, it starts up the set of drivers specified
    // in the configuration file. As these drivers initialize, they'll
    // register the devices they need. For read-only devices, this
    // method will be called.
    //
    // - `driver` is the name of the driver. The framework will
    //   guarantee that this parameter is consistent for all devices
    //   defined by a driver.
    // - `name` is the full name of the device.
    // - `units` is an optional value which specifies the engineering
    //   units returned by the device.
    // - `max_history` is a hint as to how large an archive the user
    //   specifies should be used for this device.
    //
    // On success, this function returns a pair. The first element is
    // a closure the driver uses to report updates. The second element
    // is an optional value representing the last value of the device,
    // as saved in the back-end.

    fn register_read_only_device<'a>(
        &'a mut self,
        driver: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        max_history: Option<usize>,
    ) -> impl Future<Output = Result<Self::Reporter>> + Send + 'a;

    // Called when a read-write device is to be registered with the
    // back-end.
    //
    // When `drmemd` begins, it starts up the set of drivers specified
    // in the configuration file. As these drivers initialize, they'll
    // register the devices they need. For read-write devices, this
    // method will be called.
    //
    // - `driver` is the name of the driver. The framework will
    //   guarantee that this parameter is consistent for all devices
    //   defined by a driver.
    // - `name` is the full name of the device.
    // - `units` is an optional value which specifies the engineering
    //   units returned by the device.
    // - `max_history` is a hint as to how large an archive the user
    //   specifies should be used for this device.
    //
    // On success, this function returns a 3-tuple. The first element
    // is a closure the driver uses to report updates. The second
    // element is a handle with which the driver will receive setting
    // requests. The third element is an optional value representing
    // the last value of the device, as saved in the back-end.

    fn register_read_write_device<'a>(
        &'a mut self,
        driver: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        max_history: Option<usize>,
    ) -> impl Future<
        Output = Result<(
            Self::Reporter,
            driver::RxDeviceSetting,
            Option<device::Value>,
        )>,
    > + Send
           + 'a;

    // Called when information from a device is requested.
    //
    // On success, this method should return an array of
    // `client::DevInfoReply` data. If a `pattern` is specified, only
    // device names matching the pattern should be returned. The
    // grammar of the pattern is the one used by Redis (to be
    // consistent across back-ends.)

    fn get_device_info<'a>(
        &'a mut self,
        pattern: Option<&'a str>,
    ) -> impl Future<Output = Result<Vec<client::DevInfoReply>>> + Send + 'a;

    // Sends a request to a driver to set its device to the specified
    // value.

    fn set_device(
        &self,
        name: device::Name,
        value: device::Value,
    ) -> impl Future<Output = Result<device::Value>> + Send + '_;

    // Obtains the `mpsc::Sender<>` handle associated with the
    // specified device. This handle can be used to send settings to
    // the device. If 'own` is set to `true`, the requester will be
    // the only one that can send settings to the device. NOTE: `own`
    // is currently unsupported and should always be set to 'false'.
    // When it gets supported, requesters can decide whether they
    // should set it to true.

    fn get_setting_chan(
        &self,
        name: device::Name,
        own: bool,
    ) -> impl Future<Output = Result<driver::TxDeviceSetting>> + Send + '_;

    // Creates a stream that yields values of a device as it updates.

    fn monitor_device(
        &mut self,
        name: device::Name,
        start: Option<DateTime<Utc>>,
        end: Option<DateTime<Utc>>,
    ) -> impl Future<Output = Result<device::DataStream<device::Reading>>> + Send + '_;
}

#[cfg(feature = "simple-backend")]
pub mod simple;
#[cfg(feature = "simple-backend")]
pub use simple as store;
#[cfg(feature = "simple-backend")]
pub use store::SimpleStore as Instance;

#[cfg(feature = "redis-backend")]
pub mod redis;
#[cfg(feature = "redis-backend")]
pub use redis as store;
#[cfg(feature = "redis-backend")]
pub use store::RedisStore as Instance;

---
FILE: drmemd/src/backends/redis/config.rs
use serde::Deserialize;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};

#[derive(Deserialize, Clone)]
pub struct Config {
    pub addr: Option<SocketAddr>,
    pub dbn: Option<i64>,
}

impl Config {
    pub const fn new() -> Config {
        Config {
            addr: None,
            dbn: None,
        }
    }

    pub fn get_addr(&self) -> SocketAddr {
        self.addr.unwrap_or_else(|| {
            SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 6379)
        })
    }

    #[cfg(debug_assertions)]
    pub fn get_dbn(&self) -> i64 {
        self.dbn.unwrap_or(1)
    }
    #[cfg(not(debug_assertions))]
    pub fn get_dbn(&self) -> i64 {
        self.dbn.unwrap_or(0)
    }
}

pub static DEF: Config = Config::new();

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}

---
FILE: drmemd/src/backends/redis/mod.rs
use crate::backends::Store;
use chrono::*;
use drmem_api::{
    client, device,
    driver::{Reporter, RxDeviceSetting, TxDeviceSetting},
    Error, Result,
};
use futures::{
    task::{Context, Poll},
    Future,
};
use redis::{
    aio::{self, MultiplexedConnection},
    streams::{StreamId, StreamInfoStreamReply},
};
use std::{collections::HashMap, convert::TryInto, pin::Pin, sync::Arc, time};
use tokio::sync::{mpsc, oneshot};
use tokio_stream::{self, Stream, StreamExt};
use tracing::{debug, error, info, info_span, warn, Instrument};

type AioMplexConnection = aio::MultiplexedConnection;
type SettingTable = HashMap<device::Name, TxDeviceSetting>;

pub mod config;

// Translates a Redis error into a DrMem error. The translation is
// slightly lossy in that we lose the exact Redis error that occurred
// and, instead map it into a more general "backend" error. We
// propagate the associated message so, hopefully, that's enough to
// rebuild the context of the error.
//
// This is a job for `impl From<RedisError> for Error`, but it won't
// work here because neither of those types are defined in this
// module. We'd have to put the trait implementation in the
// `drmem-api` crate which, then, requires all projects to build the
// `redis` crate. Since we only need to do the translationin this
// module, this function will be the translater.

fn xlat_err(e: redis::RedisError) -> Error {
    match e.kind() {
        redis::ErrorKind::AuthenticationFailed
        | redis::ErrorKind::InvalidClientConfig => Error::AuthenticationError,

        redis::ErrorKind::TypeError => Error::TypeError,

        redis::ErrorKind::ExecAbortError
        | redis::ErrorKind::BusyLoadingError
        | redis::ErrorKind::TryAgain
        | redis::ErrorKind::ClientError
        | redis::ErrorKind::ExtensionError
        | redis::ErrorKind::ReadOnly => {
            Error::OperationError("backend is read-only".to_owned())
        }

        redis::ErrorKind::NoScriptError
        | redis::ErrorKind::Moved
        | redis::ErrorKind::Ask => Error::NotFound,

        _ => Error::BackendError(format!("{}", &e)),
    }
}

// Encodes a `device::Value` into a binary which gets stored in
// redis. This encoding lets us store type information in redis so
// there's no rounding errors or misinterpretation of the data.

fn to_redis(val: &device::Value) -> Vec<u8> {
    match val {
        device::Value::Bool(false) => vec![b'B', b'F'],
        device::Value::Bool(true) => vec![b'B', b'T'],

        // Integers start with an 'I' followed by 4 bytes.
        device::Value::Int(v) => {
            let mut buf: Vec<u8> = Vec::with_capacity(9);

            buf.push(b'I');
            buf.extend_from_slice(&v.to_be_bytes());
            buf
        }

        // Floating point values start with a 'D' and are followed by
        // 8 bytes.
        device::Value::Flt(v) => {
            let mut buf: Vec<u8> = Vec::with_capacity(9);

            buf.push(b'D');
            buf.extend_from_slice(&v.to_be_bytes());
            buf
        }

        // Strings start with an 'S', followed by a 4-byte length
        // field, and then followed by the string content.
        device::Value::Str(s) => {
            let s = s.as_bytes();
            let mut buf: Vec<u8> = Vec::with_capacity(5 + s.len());

            buf.push(b'S');
            buf.extend_from_slice(&(s.len() as u32).to_be_bytes());
            buf.extend_from_slice(s);
            buf
        }

        // Colors start with a 'C', followed by 4 u8 values,
        // representing red, green, blue, and alpha intensities,
        // respectively.
        device::Value::Color(v) => vec![b'C', v.red, v.green, v.blue, v.alpha],
    }
}

// Decodes an `i32` from an 4-byte buffer.

fn decode_integer(buf: &[u8]) -> Result<device::Value> {
    if buf.len() >= 4 {
        let buf = buf[..4].try_into().unwrap();

        return Ok(device::Value::Int(i32::from_be_bytes(buf)));
    }
    Err(Error::TypeError)
}

// Decodes an `f64` from an 8-byte buffer.

fn decode_float(buf: &[u8]) -> Result<device::Value> {
    if buf.len() >= 8 {
        let buf = buf[..8].try_into().unwrap();

        return Ok(device::Value::Flt(f64::from_be_bytes(buf)));
    }
    Err(Error::TypeError)
}

// Decodes a UTF-8 encoded string from a raw, u8 buffer.

fn decode_string(buf: &[u8]) -> Result<device::Value> {
    if buf.len() >= 4 {
        let len_buf = buf[..4].try_into().unwrap();
        let len = u32::from_be_bytes(len_buf) as usize;

        if buf.len() >= (4 + len) {
            let str_vec = buf[4..4 + len].to_vec();

            return match String::from_utf8(str_vec) {
                Ok(s) => Ok(device::Value::Str(s.into())),
                Err(_) => Err(Error::TypeError),
            };
        }
    }
    Err(Error::TypeError)
}

fn decode_color(buf: &[u8]) -> Result<device::Value> {
    match *buf {
        [r, g, b] => {
            let rgb = palette::LinSrgba::new(r, g, b, 255);

            Ok(device::Value::Color(rgb))
        }
        [r, g, b, a] => {
            let rgb = palette::LinSrgba::new(r, g, b, a);

            Ok(device::Value::Color(rgb))
        }
        _ => Err(Error::TypeError),
    }
}

// Returns a `device::Value` from a `redis::Value`. The only
// enumeration we support is the `redis::Value::BulkString` form since
// that's the one used to return redis data.

fn from_value(v: &redis::Value) -> Result<device::Value> {
    if let redis::Value::BulkString(buf) = v {
        // The buffer has to have at least one character in order to
        // be decoded.

        if !buf.is_empty() {
            match buf[0] as char {
                'B' if buf.len() > 1 => match buf[1] {
                    b'F' => Ok(device::Value::Bool(false)),
                    b'T' => Ok(device::Value::Bool(true)),
                    _ => Err(Error::TypeError),
                },
                'I' => decode_integer(&buf[1..]),
                'D' => decode_float(&buf[1..]),
                'S' => decode_string(&buf[1..]),
                'C' => decode_color(&buf[1..]),

                // Any other character in the tag field is unknown and
                // can't be decoded as a `device::Value`.
                _ => Err(Error::TypeError),
            }
        } else {
            Err(Error::TypeError)
        }
    } else {
        Err(Error::TypeError)
    }
}

// Subtracts 1 microsecond from a SystemTime value. If subtracting
// can't be done (would put the SystemTime out of range) then the
// passed in value is returned.

fn st_minus_1us(st: time::SystemTime) -> time::SystemTime {
    if let Some(val) = st.checked_sub(time::Duration::from_micros(1)) {
        val
    } else {
        st
    }
}

// Converts millisecond/microsecond values to SystemTime. The
// microsecond parameter is clipped to the range 0 - 999.

fn msus_to_st(ms: u64, us: u64) -> Result<time::SystemTime> {
    let ts = time::UNIX_EPOCH.checked_add(time::Duration::from_millis(ms));

    if let Some(ts) = ts {
        let ts = ts.checked_add(time::Duration::from_micros(std::cmp::min(
            us, 999u64,
        )));

        if let Some(ts) = ts {
            return Ok(ts);
        }
    }
    Err(Error::InvArgument(String::from("bad timestamp value")))
}

// Converts a redis stream ID ("###-###") into a `SystemTime`. In
// DrMem, we follow the redis convention that the main portion of the
// ID is milliseconds from 1970. The secondary portion is used to hold
// microseconds ("0" - "999", not "000" - "999").

fn id_to_ts(id: &str) -> Result<time::SystemTime> {
    let fields: Vec<&str> = id.split('-').collect();

    if let &[a, b] = &fields[..] {
        // The redis stream id has the form "#-#" where the first
        // number is a 64-bit value representing milliseconds since
        // 1970. The second portion is a sequence number which is only
        // used if the first number has a duplicate.  This keeps the
        // timestamps increasing in value. DrMem has a base time of 20
        // Hz (50 ms), so we should never have more than one timestamp
        // occur in the same millisecond. However, some may want to
        // push the boundaries, so we'll use the second number as a
        // microsecond field. This code will accept the second field
        // to be 0 - 999. If it exceeds 999, we'll clip it.

        if let (Ok(ms), Ok(us)) = (a.parse::<u64>(), b.parse::<u64>()) {
            return msus_to_st(ms, us);
        }
    }

    Err(Error::InvArgument(String::from("unknown timestamp format")))
}

type ReadFuture = Pin<
    Box<
        dyn Future<
                Output = (AioMplexConnection, redis::RedisResult<redis::Value>),
            > + Send,
    >,
>;

type ReadingResult = ((String, ((String, HashMap<String, redis::Value>),)),);

struct ReadingStream {
    key: String,
    id: String,
    fut: ReadFuture,
}

impl ReadingStream {
    const TIMEOUT: usize = 5_000;

    // Converts a `time::SystemTime` into a redis stream id.
    // Microseconds are mapping into the secondary portion of the id.
    //
    // XXX: This function uses `.unwrap()`, which means this function
    // could `panic!`. However, the timestamps are being generated by
    // redis or DrMem so they should always be in range. If we allow
    // drivers to specify their own timestamps, this may need to be
    // revisited.

    fn ts_to_id(ts: time::SystemTime) -> String {
        let us = ts.duration_since(time::UNIX_EPOCH).unwrap().as_micros();

        format!("{}-{}", us / 1000, us % 1000)
    }

    fn read_next_cmd(key: &str, id: &str) -> redis::Cmd {
        let opts = redis::streams::StreamReadOptions::default()
            .block(Self::TIMEOUT)
            .count(1);

        redis::Cmd::xread_options(&[key], &[id], &opts)
    }

    // Create a future that returns the next device reading from a
    // redis stream (or times-out trying.) The connection is
    // "threaded" through the future (i.e. it takes ownership and
    // returns it with the result.) This is necessary because an
    // AioConnection isn't clonable.

    fn mk_fut(
        mut con: AioMplexConnection,
        key: String,
        id: String,
    ) -> ReadFuture {
        Box::pin(async move {
            let result =
                Self::read_next_cmd(&key, &id).query_async(&mut con).await;

            (con, result)
        })
    }

    pub fn new(
        con: AioMplexConnection,
        key: &str,
        id: Option<time::SystemTime>,
    ) -> Self {
        let key = key.to_string();
        let id = id.map(Self::ts_to_id).unwrap_or_else(|| String::from("$"));
        let fut = Self::mk_fut(con, key.clone(), id.clone());

        ReadingStream { key, id, fut }
    }

    fn parse_reading(data: &redis::Value) -> Option<(String, device::Reading)> {
        let result: redis::RedisResult<ReadingResult> =
            redis::from_redis_value(data);

        match result {
            Ok(((_, ((ref new_id, ref rmap),)),)) => {
                let reading = device::Reading {
                    ts: id_to_ts(new_id).ok()?,
                    value: from_value(rmap.get("value")?).ok()?,
                };

                Some((new_id.to_string(), reading))
            }
            Err(e) => {
                error!("couldn't parse reading: {:?}", &e);
                None
            }
        }
    }
}

// Implements a stream. Note this stream is probably not cancel-safe;
// without knowing the internals of the Future that returns the redis
// result, we can only assume the connection can be put in a bad state
// if this future (poll_next) is canceled. In DrMem, we typically
// consume the entire stream and, in the case of a client canceling
// its use of the stream, we've going to tear down the redis
// connection.

impl Stream for ReadingStream {
    type Item = device::Reading;

    // Polls the redis connection (via XREAD) for another reading and
    // returns it through the stream. The redis command set doesn't
    // have an infinite blocking command so this future uses the
    // timeout parameter to periodically wake up and retry the read.

    fn poll_next(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>> {
        loop {
            // If there is a `Poll::Ready` return value, then redis
            // sent an update.

            if let Poll::Ready(result) = Pin::new(&mut self.fut).poll(cx) {
                // If redis returned an error, report it and close the
                // stream.

                let (con, result) = match result {
                    (con, Ok(v)) => (con, v),
                    (_, Err(e)) => {
                        warn!("read error -- {}", &e);
                        break Poll::Ready(None);
                    }
                };

                // If there's no data, the timeout occurred. Redis has
                // no "block forever" request, so the best that can be
                // done is to wake up periodically and retry the
                // request.

                if result != redis::Value::Nil {
                    if let Some((id, reading)) = Self::parse_reading(&result) {
                        // This future is no longer good. Create a new
                        // future using the updated `id`.

                        self.id = id;
                        self.fut = Self::mk_fut(
                            con,
                            self.key.clone(),
                            self.id.clone(),
                        );

                        // Return the reading data.

                        break Poll::Ready(Some(reading));
                    } else {
                        break Poll::Ready(None);
                    }
                } else {
                    // The read command timed out. Re-issue the future
                    // using the same `id` and loop.

                    self.fut =
                        Self::mk_fut(con, self.key.clone(), self.id.clone());
                }
            } else {
                break Poll::Pending;
            }
        }
    }
}

#[derive(Clone)]
pub struct Report {
    name: Arc<str>,
    hist_key: Arc<str>,
    conn: MultiplexedConnection,
    max_history: Option<usize>,
}

impl Report {
    pub fn new(
        name: &str,
        conn: MultiplexedConnection,
        max_history: Option<usize>,
    ) -> Self {
        Report {
            name: name.into(),
            hist_key: RedisStore::hist_key(name).into(),
            conn,
            max_history,
        }
    }

    // Generates a redis command pipeline that adds a value to a
    // device's history.

    fn report_new_value_cmd(key: &str, val: &device::Value) -> redis::Cmd {
        let data = [("value", to_redis(val))];

        redis::Cmd::xadd(key, "*", &data)
    }

    fn report_bounded_new_value_cmd(
        key: &str,
        val: &device::Value,
        mh: usize,
    ) -> redis::Cmd {
        let opts = redis::streams::StreamMaxlen::Approx(mh);
        let data = [("value", to_redis(val))];

        redis::Cmd::xadd_maxlen(key, opts, "*", &data)
    }
}

impl Reporter for Report {
    async fn report_value(&mut self, value: device::Value) {
        if let Some(mh) = self.max_history {
            if let Err(e) =
                Self::report_bounded_new_value_cmd(&self.hist_key, &value, mh)
                    .query_async::<()>(&mut self.conn)
                    .await
            {
                warn!("couldn't save {} data to redis ... {}", &self.name, e)
            }
        } else {
            if let Err(e) = Self::report_new_value_cmd(&self.hist_key, &value)
                .query_async::<()>(&mut self.conn)
                .await
            {
                warn!("couldn't save {} data to redis ... {}", &self.name, e)
            }
        }
    }
}

/// Defines a context that uses redis for the back-end storage.
pub struct RedisStore {
    /// This connection is used for interacting with the database.
    db_con: AioMplexConnection,
    table: SettingTable,
    cfg: config::Config,
}

impl RedisStore {
    fn make_client(
        cfg: &config::Config,
        name: Option<&String>,
        pword: Option<&String>,
    ) -> Result<redis::Client> {
        use redis::{ConnectionAddr, ConnectionInfo, RedisConnectionInfo};

        let addr = cfg.get_addr();

        let ci = ConnectionInfo {
            addr: ConnectionAddr::Tcp(addr.ip().to_string(), addr.port()),
            redis: RedisConnectionInfo {
                db: cfg.get_dbn(),
                username: name.cloned(),
                password: pword.cloned(),
                protocol: redis::ProtocolVersion::RESP2,
            },
        };

        redis::Client::open(ci).map_err(xlat_err)
    }

    // Creates a single-user connection to redis.

    async fn make_connection(
        cfg: &config::Config,
        name: Option<String>,
        pword: Option<String>,
    ) -> Result<AioMplexConnection> {
        let client = Self::make_client(cfg, name.as_ref(), pword.as_ref())?;

        debug!("creating new redis connection");

        client
            .get_multiplexed_tokio_connection()
            .await
            .map_err(|e| {
                error!("redis error: {}", &e);
                xlat_err(e)
            })
    }

    // Creates a mulitplexed connection to redis.

    async fn make_mplex_connection(
        cfg: &config::Config,
        name: Option<String>,
        pword: Option<String>,
    ) -> Result<AioMplexConnection> {
        let client = Self::make_client(cfg, name.as_ref(), pword.as_ref())?;

        debug!("creating new, shared redis connection");

        client
            .get_multiplexed_tokio_connection()
            .await
            .map_err(|e| {
                error!("redis error: {}", &e);
                xlat_err(e)
            })
    }

    /// Builds a new backend context which interacts with `redis`.
    /// The parameters in `cfg` will be used to locate the `redis`
    /// instance. If `name` and `pword` are not `None`, they will be
    /// used for credentials when connecting to `redis`.
    pub async fn new(
        cfg: &config::Config,
        name: Option<String>,
        pword: Option<String>,
    ) -> Result<Self> {
        let db_con = Self::make_mplex_connection(cfg, name, pword).await?;

        Ok(RedisStore {
            db_con,
            table: HashMap::new(),
            cfg: cfg.clone(),
        })
    }

    // Returns the key that returns meta information for the device.

    fn info_key(name: &str) -> String {
        format!("{name}#info")
    }

    // Returns the key that returns time-series information for the
    // device.

    pub fn hist_key(name: &str) -> String {
        format!("{name}#hist")
    }

    fn init_device_cmd(
        name: &str,
        driver: &str,
        units: Option<&String>,
    ) -> redis::Pipeline {
        let hist_key = Self::hist_key(name);
        let info_key = Self::info_key(name);

        // Start an array of required fields.

        let mut fields: Vec<(&str, String)> =
            vec![("driver", String::from(driver))];

        // Optionally add a "units" field.

        if let Some(units) = units {
            fields.push(("units", units.clone()))
        };

        // Create a command pipeline that deletes the two keys and
        // then creates them properly with default values.

        redis::pipe()
            .atomic()
            .del(&hist_key)
            .ignore()
            .xadd(&hist_key, "1", &[("value", &[1u8])])
            .ignore()
            .xdel(&hist_key, &["1"])
            .ignore()
            .del(&info_key)
            .ignore()
            .hset_multiple(&info_key, &fields)
            .ignore()
            .clone()
    }

    // Builds the low-level command that returns the last value of the
    // device.

    fn last_value_cmd(name: &str) -> redis::Cmd {
        let name = Self::hist_key(name);

        redis::Cmd::xrevrange_count(name, "+", "-", 1usize)
    }

    fn match_pattern_cmd(pattern: Option<&str>) -> redis::Cmd {
        // Take the pattern from the caller and append "#info" since
        // we only want to look at device information keys.

        let pattern = pattern
            .map(Self::info_key)
            .unwrap_or_else(|| String::from("*#info"));

        // Query REDIS to return all keys that match our pattern.

        redis::Cmd::keys(pattern)
    }

    // Builds the low-level command that returns the type of the
    // device's meta record.

    fn info_type_cmd(name: &str) -> redis::Cmd {
        let key = Self::info_key(name);

        redis::cmd("TYPE").arg(&key).clone()
    }

    // Builds the low-level command that returns the type of the
    // device's history record.

    fn hist_type_cmd(name: &str) -> redis::Cmd {
        let key = Self::hist_key(name);

        redis::cmd("TYPE").arg(&key).clone()
    }

    // Creates a redis command pipeline which returns the standard,
    // meta-data for a device.

    fn device_info_cmd(name: &str) -> redis::Cmd {
        let info_key = Self::info_key(name);

        redis::Cmd::hgetall(info_key)
    }

    // Creates the redis command to pull stream information associated
    // with the device's history.

    fn xinfo_cmd(name: &str) -> redis::Cmd {
        let hist_key = Self::hist_key(name);

        redis::Cmd::xinfo_stream(hist_key)
    }

    fn hash_to_info(
        st: &SettingTable,
        name: &device::Name,
        hmap: &HashMap<String, String>,
    ) -> Result<client::DevInfoReply> {
        // Redis doesn't return an error if the key doesn't exist; it
        // returns an empty array. So if our HashMap is empty, the key
        // didn't exist.

        if !hmap.is_empty() {
            // If a "units" field exists and it's a string, we can
            // save it in the `units` field of the reply.

            let units = hmap.get("units").cloned();

            // If a "driver" field exists and it's a string, save it
            // in the "drivers" field of the reply.

            let driver = hmap
                .get("driver")
                .cloned()
                .unwrap_or_else(|| String::from("*missing*"));

            Ok(client::DevInfoReply {
                name: name.clone(),
                units,
                settable: st.contains_key(name),
                driver: driver.into(),
                total_points: 0,
                first_point: None,
                last_point: None,
            })
        } else {
            Err(Error::NotFound)
        }
    }

    // Converts the `StreamId` type, from redis, into our
    // `device::Reading` type.

    fn stream_id_to_reading(sid: &StreamId) -> Result<device::Reading> {
        if let Some(val) = sid.map.get("value") {
            Ok(device::Reading {
                ts: id_to_ts(sid.id.as_str())?,
                value: from_value(val)?,
            })
        } else {
            Err(Error::TypeError)
        }
    }

    // Looks up a device in the redis store and, if found, returns a
    // `client::DevInfoReply` containing the information.

    async fn lookup_device(
        &mut self,
        name: device::Name,
    ) -> Result<client::DevInfoReply> {
        let info = Self::device_info_cmd(name.to_string().as_str())
            .query_async::<HashMap<String, String>>(&mut self.db_con)
            .await
            .map_err(xlat_err)
            .and_then(|v| Self::hash_to_info(&self.table, &name, &v))?;

        Self::xinfo_cmd(name.to_string().as_str())
            .query_async::<StreamInfoStreamReply>(&mut self.db_con)
            .await
            .map_err(xlat_err)
            .and_then(move |v| {
                let info = if v.length > 0 {
                    client::DevInfoReply {
                        total_points: v.length as u32,
                        first_point: Some(Self::stream_id_to_reading(
                            &v.first_entry,
                        )?),
                        last_point: Some(Self::stream_id_to_reading(
                            &v.last_entry,
                        )?),
                        ..info
                    }
                } else {
                    client::DevInfoReply {
                        total_points: 0,
                        first_point: None,
                        last_point: None,
                        ..info
                    }
                };

                Ok(info)
            })
    }

    fn parse_last_value(
        name: &str,
        reply: &redis::Value,
    ) -> Option<device::Reading> {
        if redis::Value::Array(vec![]) == *reply {
            warn!("no previous value for {}", name);
            return None;
        }

        let data: redis::RedisResult<((
            String,
            HashMap<String, redis::Value>,
        ),)> = redis::from_redis_value(reply);

        match data {
            Ok(((key, m),)) => {
                if let Ok(ts) = id_to_ts(&key) {
                    if let Some(val) = m.get("value") {
                        if let Ok(val) = from_value(val) {
                            return Some(device::Reading { ts, value: val });
                        } else {
                            error!(
                                "last value for {} is in an unknown format",
                                name
                            );
                        }
                    } else {
                        error!(
                            "last value for {} doesn't have a \"value\" field",
                            name
                        );
                    }
                } else {
                    error!("couldn't parse timestamp, {}, for {}", key, name)
                }
            }
            Err(e) => {
                error!(
                    "redis error ({}) when converting last value of {}",
                    e, name
                )
            }
        }
        None
    }

    // Obtains the last value reported for a device, or `None` if
    // there is no history for it.

    async fn last_value(&mut self, name: &str) -> Option<device::Reading> {
        let result: redis::RedisResult<redis::Value> =
            Self::last_value_cmd(name)
                .query_async(&mut self.db_con)
                .await;

        match result {
            Ok(reply) => Self::parse_last_value(name, &reply),
            Err(e) => {
                error!(
                    "redis error ({}) when getting last value of {}",
                    e, name
                );
                None
            }
        }
    }

    // Does some sanity checks on a device to see if it appears to be
    // valid.

    async fn validate_device(&mut self, name: &str) -> Result<()> {
        // This section verifies the device has a NAME#info key that
        // is a hash map.

        {
            let cmd = Self::info_type_cmd(name);
            let result: redis::RedisResult<String> =
                cmd.query_async(&mut self.db_con).await;

            match result {
                Ok(data_type) if data_type.as_str() == "hash" => (),
                Ok(_) => {
                    error!("{} info is of the wrong key type", name);
                    return Err(Error::TypeError);
                }
                Err(_) => {
                    warn!("{} info doesn't exist", name);
                    return Err(Error::NotFound);
                }
            }
        }

        // This section verifies the device has a NAME#hist key that
        // is a time-series stream.

        {
            let cmd = Self::hist_type_cmd(name);
            let result: redis::RedisResult<String> =
                cmd.query_async(&mut self.db_con).await;

            match result {
                Ok(data_type) if data_type.as_str() == "stream" => Ok(()),
                Ok(_) => {
                    error!("{} history is of the wrong key type", name);
                    Err(Error::TypeError)
                }
                Err(_) => {
                    warn!("{} history doesn't exist", name);
                    Err(Error::NotFound)
                }
            }
        }
    }

    // Initializes the state of a DrMem device in the REDIS database.
    // It creates two keys: one key is appended with "#info" and
    // addresses a hash table which will contain device meta
    // information; the other key is appended with "#hist" and is a
    // time-series stream which holds recent history of a device's
    // values.

    async fn init_device(
        &mut self,
        name: &str,
        driver: &str,
        units: Option<&String>,
    ) -> Result<()> {
        debug!("initializing {}", name);
        Self::init_device_cmd(name, driver, units)
            .query_async(&mut self.db_con)
            .await
            .map_err(xlat_err)
    }
}

impl Store for RedisStore {
    type Reporter = Report;

    /// Registers a device in the redis backend.
    fn register_read_only_device<'a>(
        &'a mut self,
        driver_name: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        max_history: Option<usize>,
    ) -> impl Future<Output = Result<Self::Reporter>> + Send + 'a {
        let name = name.to_string();

        debug!("registering '{}' as read-only", &name);

        async move {
            if self.validate_device(&name).await.is_err() {
                self.init_device(&name, driver_name, units).await?;

                info!("'{}' has been successfully created", &name);
            }
            Ok(Report::new(&name, self.db_con.clone(), max_history))
        }
    }

    fn register_read_write_device<'a>(
        &'a mut self,
        driver_name: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        max_history: Option<usize>,
    ) -> impl Future<
        Output = Result<(
            Self::Reporter,
            RxDeviceSetting,
            Option<device::Value>,
        )>,
    > + Send
           + 'a {
        let sname = name.to_string();

        debug!("registering '{}' as read-write", &sname);

        async move {
            if self.validate_device(&sname).await.is_err() {
                self.init_device(&sname, driver_name, units).await?;

                info!("'{}' has been successfully created", &sname);
            }

            let (tx, rx) = mpsc::channel(20);

            if self.table.insert(name.clone(), tx).is_some() {
                warn!("{} already had a setting channel", &name);
            }

            Ok((
                Report::new(&sname, self.db_con.clone(), max_history),
                rx,
                self.last_value(&sname).await.map(|v| v.value),
            ))
        }
    }

    // Implement the request to pull device information. Any task with
    // a client channel can make this request although the primary
    // client will be from GraphQL requests.

    async fn get_device_info<'a>(
        &'a mut self,
        pattern: Option<&'a str>,
    ) -> Result<Vec<client::DevInfoReply>> {
        // Get a list of all the keys that match the pattern. For
        // Redis, these keys will have "#info" appended at the end.

        let result: Vec<String> = Self::match_pattern_cmd(pattern)
            .query_async(&mut self.db_con)
            .await
            .map_err(xlat_err)?;

        // Create an empty container to hold the device info records.

        let mut devices = vec![];

        // Loop through the results and pull all the device
        // information. Strip off the trailing "#info" before getting
        // the device information.

        for key in result {
            // Only process keys that are valid device names.

            if let Ok(name) = key.trim_end_matches("#info").try_into() {
                let dev_info = self.lookup_device(name).await?;

                devices.push(dev_info)
            }
        }
        Ok(devices)
    }

    // This method implements the set_device mutation in the GraphQL
    // API.

    async fn set_device(
        &self,
        name: device::Name,
        value: device::Value,
    ) -> Result<device::Value> {
        if let Some(tx) = self.table.get(&name) {
            let (tx_rpy, rx_rpy) = oneshot::channel();

            // Send the request and return from the function with the
            // reply. If any error occurs during communication, fall
            // through to report it.

            if let Ok(()) = tx.send((value, tx_rpy)).await {
                if let Ok(reply) = rx_rpy.await {
                    return reply;
                }
            }

            // Some portion of the RPC failed. Return an error.

            Err(Error::MissingPeer(
                "cannot communicate with driver".to_string(),
            ))
        } else {
            Err(Error::NotFound)
        }
    }

    async fn get_setting_chan(
        &self,
        name: device::Name,
        _own: bool,
    ) -> Result<TxDeviceSetting> {
        if let Some(tx) = self.table.get(&name) {
            Ok(tx.clone())
        } else {
            Err(Error::NotFound)
        }
    }

    async fn monitor_device(
        &mut self,
        name: device::Name,
        start: Option<DateTime<Utc>>,
        end: Option<DateTime<Utc>>,
    ) -> Result<device::DataStream<device::Reading>> {
        match Self::make_connection(&self.cfg, None, None).await {
            Ok(con) => {
                let name = name.to_string();
                let key = RedisStore::hist_key(&name);

                match (start.map(|v| v.into()), end.map(|v| v.into())) {
                    // With no start time, use the latest value of the
                    // device. If there's an end time, add a stream
                    // combinator that ends the stream once the date
                    // reaches it.
                    (None, end) => {
                        let ts = self
                            .last_value(&name)
                            .await
                            .map(|tmp| st_minus_1us(tmp.ts));

                        // If there's an end date, append a filter to
                        // the stream so it stops once the timestamp
                        // reach it.

                        if let Some(end) = end {
                            let date_test =
                                move |v: &device::Reading| v.ts <= end;

                            Ok(Box::pin(
                                ReadingStream::new(con, &key, ts)
                                    .take_while(date_test),
                            )
                                as device::DataStream<device::Reading>)
                        } else {
                            Ok(Box::pin(ReadingStream::new(con, &key, ts))
                                as device::DataStream<device::Reading>)
                        }
                    }

                    // Given a start time with no end time, start
                    // reading the redis stream at that point.
                    (Some(start), None) => Ok(Box::pin(ReadingStream::new(
                        con,
                        &key,
                        Some(st_minus_1us(start)),
                    ))
                        as device::DataStream<device::Reading>),

                    // Start reading at the start time and stop the
                    // stream at the end time.
                    (Some(start_tmp), Some(end_tmp)) => {
                        let start = std::cmp::min(start_tmp, end_tmp);
                        let end = std::cmp::max(start_tmp, end_tmp);
                        let date_test = move |v: &device::Reading| v.ts <= end;

                        Ok(Box::pin(
                            ReadingStream::new(
                                con,
                                &key,
                                Some(st_minus_1us(start)),
                            )
                            .take_while(date_test),
                        )
                            as device::DataStream<device::Reading>)
                    }
                }
            }
            Err(e) => {
                error!("couldn't make a connection : {}", e);

                Ok(Box::pin(tokio_stream::empty())
                    as device::DataStream<device::Reading>)
            }
        }
    }
}

pub async fn open(cfg: &config::Config) -> Result<RedisStore> {
    RedisStore::new(cfg, None, None)
        .instrument(
            info_span!("redis-db", addr=?cfg.get_addr(), db=cfg.get_dbn()),
        )
        .await
}

// This is the test module to make sure the redis backend works
// correctly. We're not testing redis itself -- we assume the redis
// project is verifying its behavior. Many functions have been broken
// out into smaller, helper functions so that we can create tests
// for them without the need of a redis installation.
//
// That being said, there are some requirements which are hard to test
// because they're dependent on redis' behavior.
//
// For instance, when monitoring a device, we want to immediately
// return any "current" value before blocking for future values. If
// there is a "last value", we need to use its timestamp for the next,
// blocking call. We should test this, but it doesn't seem like an
// easy thing to do (without requiring a redis instance.)

#[cfg(test)]
mod tests {
    use super::*;
    use drmem_api::device;

    // We only want to convert Value::BulkString() forms. These tests
    // make sure the other variants don't translate.

    #[test]
    fn test_reject_invalid_forms() {
        if let Ok(v) = from_value(&redis::Value::Int(0)) {
            panic!("Value::Int incorrectly translated to {:?}", v);
        }
        if let Ok(v) = from_value(&redis::Value::Array(vec![])) {
            panic!("Value::Array incorrectly translated to {:?}", v);
        }
        if let Ok(v) = from_value(&redis::Value::SimpleString(String::from("")))
        {
            panic!("Value::SimpleString incorrectly translated to {:?}", v);
        }
        if let Ok(v) = from_value(&redis::Value::Okay) {
            panic!("Value::Okay incorrectly translated to {:?}", v);
        }
    }

    // Test correct decoding of device::Value::Bool values.

    #[test]
    fn test_bool_decoder() {
        assert_eq!(
            Ok(device::Value::Bool(false)),
            from_value(&redis::Value::BulkString(vec![b'B', b'F']))
        );
        assert_eq!(
            Ok(device::Value::Bool(true)),
            from_value(&redis::Value::BulkString(vec![b'B', b'T']))
        );
    }

    // Test correct encoding of device::Value::Bool values.

    #[test]
    fn test_bool_encoder() {
        assert_eq!(vec![b'B', b'F'], to_redis(&device::Value::Bool(false)));
        assert_eq!(vec![b'B', b'T'], to_redis(&device::Value::Bool(true)));
    }

    const INT_TEST_CASES: &[(i32, &[u8])] = &[
        (0, &[b'I', 0x00, 0x00, 0x00, 0x00]),
        (1, &[b'I', 0x00, 0x00, 0x00, 0x01]),
        (-1, &[b'I', 0xff, 0xff, 0xff, 0xff]),
        (0x7fffffff, &[b'I', 0x7f, 0xff, 0xff, 0xff]),
        (-0x80000000, &[b'I', 0x80, 0x00, 0x00, 0x00]),
        (0x01234567, &[b'I', 0x01, 0x23, 0x45, 0x67]),
    ];

    // Test correct encoding of device::Value::Int values.

    #[test]
    fn test_int_encoder() {
        for (v, rv) in INT_TEST_CASES {
            assert_eq!(*rv, to_redis(&device::Value::Int(*v)));
        }
    }

    // Test correct decoding of device::Value::Int values.

    #[test]
    fn test_int_decoder() {
        assert!(from_value(&redis::Value::BulkString(vec![])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'I'])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'I', 0u8])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'I', 0u8, 0u8]))
            .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'I', 0u8, 0u8, 0u8
        ]))
        .is_err());

        for (v, rv) in INT_TEST_CASES {
            let data = redis::Value::BulkString(rv.to_vec());

            assert_eq!(Ok(device::Value::Int(*v)), from_value(&data));
        }
    }

    const FLT_TEST_CASES: &[(f64, &[u8])] = &[
        (0.0, &[b'D', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
        (
            -0.0,
            &[b'D', 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ),
        (1.0, &[b'D', 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
        (
            -1.0,
            &[b'D', 0xbf, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        ),
        (
            9007199254740991.0,
            &[b'D', 67, 63, 255, 255, 255, 255, 255, 255],
        ),
        (9007199254740992.0, &[b'D', 67, 64, 0, 0, 0, 0, 0, 0]),
    ];

    // Test correct encoding of device::Value::Flt values.

    #[test]
    fn test_float_encoder() {
        for (v, rv) in FLT_TEST_CASES {
            assert_eq!(*rv, to_redis(&device::Value::Flt(*v)));
        }
    }

    // Test correct decoding of device::Value::Flt values.

    #[test]
    fn test_float_decoder() {
        assert!(from_value(&redis::Value::BulkString(vec![])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'D'])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'D', 0u8])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'D', 0u8, 0u8]))
            .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'D', 0u8, 0u8, 0u8
        ]))
        .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'D', 0u8, 0u8, 0u8, 0u8
        ]))
        .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'D', 0u8, 0u8, 0u8, 0u8, 0u8
        ]))
        .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'D', 0u8, 0u8, 0u8, 0u8, 0u8, 0u8
        ]))
        .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'D', 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8
        ]))
        .is_err());

        for (v, rv) in FLT_TEST_CASES {
            let data = redis::Value::BulkString(rv.to_vec());

            assert_eq!(Ok(device::Value::Flt(*v)), from_value(&data));
        }
    }

    const COLOR_TEST_CASES: &[((u8, u8, u8, u8), [u8; 5])] = &[
        ((0, 0, 0, 0), [b'C', 0, 0, 0, 0]),
        ((4, 2, 1, 100), [b'C', 4, 2, 1, 100]),
        ((8, 4, 2, 200), [b'C', 8, 4, 2, 200]),
        ((12, 6, 3, 30), [b'C', 12, 6, 3, 30]),
        ((16, 8, 4, 255), [b'C', 16, 8, 4, 255]),
        ((20, 10, 5, 255), [b'C', 20, 10, 5, 255]),
        ((24, 12, 6, 80), [b'C', 24, 12, 6, 80]),
        ((28, 14, 7, 90), [b'C', 28, 14, 7, 90]),
        ((32, 16, 8, 0), [b'C', 32, 16, 8, 0]),
    ];

    #[test]
    fn test_color_encoder() {
        for ((r, g, b, a), rv) in COLOR_TEST_CASES {
            assert_eq!(
                &rv[..],
                to_redis(&device::Value::Color(palette::LinSrgba::new(
                    *r, *g, *b, *a
                )))
            );
        }
    }

    #[test]
    fn test_color_decoder() {
        for ((r, g, b, a), rv) in COLOR_TEST_CASES {
            assert_eq!(
                from_value(&redis::Value::BulkString(rv.to_vec())).unwrap(),
                device::Value::Color(palette::LinSrgba::new(*r, *g, *b, *a))
            );
        }
    }

    const STR_TEST_CASES: &[(&str, &[u8])] = &[
        ("", &[b'S', 0u8, 0u8, 0u8, 0u8]),
        ("ABC", &[b'S', 0u8, 0u8, 0u8, 3u8, b'A', b'B', b'C']),
    ];

    // Test correct encoding of device::Value::Str values.

    #[test]
    fn test_string_encoder() {
        for (v, rv) in STR_TEST_CASES {
            assert_eq!(*rv, to_redis(&device::Value::Str((*v).into())));
        }
    }

    // Test correct decoding of device::Value::Str values.

    #[test]
    fn test_string_decoder() {
        // Buffers smaller than 5 bytes are an error.

        assert!(from_value(&redis::Value::BulkString(vec![])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'S'])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'S', 0u8])).is_err());
        assert!(from_value(&redis::Value::BulkString(vec![b'S', 0u8, 0u8]))
            .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'S', 0u8, 0u8, 0u8
        ]))
        .is_err());

        // Loop through the test cases.

        for (v, rv) in STR_TEST_CASES {
            let data = redis::Value::BulkString(rv.to_vec());

            assert_eq!(Ok(device::Value::Str((*v).into())), from_value(&data));
        }

        // Verify proper response (both good and bad) when the buffer
        // doesn't match the size of the string.

        assert!(from_value(&redis::Value::BulkString(vec![
            b'S', 0u8, 0u8, 0u8, 1u8
        ]))
        .is_err());
        assert!(from_value(&redis::Value::BulkString(vec![
            b'S', 0u8, 0u8, 0u8, 2u8, b'A'
        ]))
        .is_err());
        assert_eq!(
            Ok(device::Value::Str("AB".into())),
            from_value(&redis::Value::BulkString(vec![
                b'S', 0u8, 0u8, 0u8, 2u8, b'A', b'B', 0, 0
            ]))
        );
    }

    #[test]
    fn test_pattern_cmd() {
        assert_eq!(
            &RedisStore::match_pattern_cmd(None).get_packed_command(),
            b"*2\r
$4\r\nKEYS\r
$6\r\n*#info\r\n"
        );
        assert_eq!(
            &RedisStore::match_pattern_cmd(Some("device")).get_packed_command(),
            b"*2\r
$4\r\nKEYS\r
$11\r\ndevice#info\r\n"
        );
        assert_eq!(
            &RedisStore::match_pattern_cmd(Some("*weather*"))
                .get_packed_command(),
            b"*2\r
$4\r\nKEYS\r
$14\r\n*weather*#info\r\n"
        );
    }

    #[test]
    fn test_ts_to_id() {
        let dur = time::Duration::from_secs(1000);
        let ts = time::UNIX_EPOCH + dur;

        assert_eq!(ReadingStream::ts_to_id(ts), "1000000-0");

        let dur = time::Duration::from_micros(1234567);
        let ts = time::UNIX_EPOCH + dur;

        assert_eq!(ReadingStream::ts_to_id(ts), "1234-567");
    }

    #[test]
    fn test_read_next_cmd() {
        let cmd = ReadingStream::read_next_cmd("device#hist", "$");

        assert_eq!(
            &cmd.get_packed_command(),
            b"*8\r
$5\r\nXREAD\r
$5\r\nBLOCK\r
$4\r\n5000\r
$5\r\nCOUNT\r
$1\r\n1\r
$7\r\nSTREAMS\r
$11\r\ndevice#hist\r
$1\r\n$\r\n"
        );
    }

    #[test]
    fn test_info_type_cmd() {
        let cmd = RedisStore::info_type_cmd("device");

        assert_eq!(
            &cmd.get_packed_command(),
            b"*2\r
$4\r\nTYPE\r
$11\r\ndevice#info\r\n"
        );
    }

    #[test]
    fn test_hist_type_cmd() {
        let cmd = RedisStore::hist_type_cmd("device");

        assert_eq!(
            &cmd.get_packed_command(),
            b"*2\r
$4\r\nTYPE\r
$11\r\ndevice#hist\r\n"
        );
    }

    #[test]
    fn test_dev_info_cmd() {
        let cmd = RedisStore::device_info_cmd("device");

        assert_eq!(
            &cmd.get_packed_command(),
            b"*2\r
$7\r\nHGETALL\r
$11\r\ndevice#info\r\n"
        );
    }

    #[test]
    fn test_last_value_cmd() {
        let pipe = RedisStore::last_value_cmd("device");

        assert_eq!(
            &pipe.get_packed_command(),
            b"*6\r
$9\r\nXREVRANGE\r
$11\r\ndevice#hist\r
$1\r\n+\r
$1\r\n-\r
$5\r\nCOUNT\r
$1\r\n1\r\n"
        );
    }

    #[test]
    fn test_parsing_last_value() {
        const NAME: &str = "device";

        assert_eq!(
            RedisStore::parse_last_value(NAME, &redis::Value::Nil),
            None
        );
        assert_eq!(
            RedisStore::parse_last_value(NAME, &redis::Value::Array(vec![])),
            None
        );

        let val = redis::Value::Array(vec![redis::Value::Array(vec![
            redis::Value::BulkString(b"1000000-0".to_vec()),
            redis::Value::Array(vec![
                redis::Value::BulkString(b"value".to_vec()),
                redis::Value::BulkString(b"BT".to_vec()),
            ]),
        ])]);

        assert_eq!(
            RedisStore::parse_last_value(NAME, &val),
            Some(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_secs(1000),
                value: device::Value::Bool(true)
            })
        );

        let val = redis::Value::Array(vec![redis::Value::Array(vec![
            redis::Value::BulkString(b"1234-567".to_vec()),
            redis::Value::Array(vec![
                redis::Value::BulkString(b"value".to_vec()),
                redis::Value::BulkString(b"BF".to_vec()),
            ]),
        ])]);

        assert_eq!(
            RedisStore::parse_last_value(NAME, &val),
            Some(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_micros(1234567),
                value: device::Value::Bool(false)
            })
        );
    }

    #[test]
    fn test_xinfo_cmd() {
        assert_eq!(
            &RedisStore::xinfo_cmd("junk").get_packed_command(),
            b"*3\r
$5\r\nXINFO\r
$6\r\nSTREAM\r
$9\r\njunk#hist\r\n"
        );
    }

    #[test]
    fn test_report_value_cmd() {
        assert_eq!(
            &Report::report_new_value_cmd("key", &(true.into()))
                .get_packed_command(),
            b"*5\r
$4\r\nXADD\r
$3\r\nkey\r
$1\r\n*\r
$5\r\nvalue\r
$2\r\nBT\r\n"
        );
        assert_eq!(
            &Report::report_new_value_cmd("key", &(0x00010203i32.into()))
                .get_packed_command(),
            b"*5\r
$4\r\nXADD\r
$3\r\nkey\r
$1\r\n*\r
$5\r\nvalue\r
$5\r\nI\x00\x01\x02\x03\r\n"
        );
        assert_eq!(
            &Report::report_new_value_cmd("key", &(0x12345678i32.into()))
                .get_packed_command(),
            b"*5\r
$4\r\nXADD\r
$3\r\nkey\r
$1\r\n*\r
$5\r\nvalue\r
$5\r\nI\x12\x34\x56\x78\r\n"
        );
        assert_eq!(
            &Report::report_new_value_cmd("key", &(1.0.into()))
                .get_packed_command(),
            b"*5\r
$4\r\nXADD\r
$3\r\nkey\r
$1\r\n*\r
$5\r\nvalue\r
$9\r\nD\x3f\xf0\x00\x00\x00\x00\x00\x00\r\n"
        );
        assert_eq!(
            &Report::report_new_value_cmd("key", &("hello".into()))
                .get_packed_command(),
            b"*5\r
$4\r\nXADD\r
$3\r\nkey\r
$1\r\n*\r
$5\r\nvalue\r
$10\r\nS\x00\x00\x00\x05hello\r\n"
        );

        assert_eq!(
            &Report::report_bounded_new_value_cmd("key", &(true.into()), 0)
                .get_packed_command(),
            b"*8\r
$4\r\nXADD\r
$3\r\nkey\r
$6\r\nMAXLEN\r
$1\r\n~\r
$1\r\n0\r
$1\r\n*\r
$5\r\nvalue\r
$2\r\nBT\r\n"
        );
        assert_eq!(
            &Report::report_bounded_new_value_cmd(
                "key",
                &(0x00010203i32.into()),
                1
            )
            .get_packed_command(),
            b"*8\r
$4\r\nXADD\r
$3\r\nkey\r
$6\r\nMAXLEN\r
$1\r\n~\r
$1\r\n1\r
$1\r\n*\r
$5\r\nvalue\r
$5\r\nI\x00\x01\x02\x03\r\n"
        );
        assert_eq!(
            &Report::report_bounded_new_value_cmd(
                "key",
                &(0x12345678i32.into()),
                2
            )
            .get_packed_command(),
            b"*8\r
$4\r\nXADD\r
$3\r\nkey\r
$6\r\nMAXLEN\r
$1\r\n~\r
$1\r\n2\r
$1\r\n*\r
$5\r\nvalue\r
$5\r\nI\x12\x34\x56\x78\r\n"
        );
        assert_eq!(
            &Report::report_bounded_new_value_cmd("key", &(1.0.into()), 3)
                .get_packed_command(),
            b"*8\r
$4\r\nXADD\r
$3\r\nkey\r
$6\r\nMAXLEN\r
$1\r\n~\r
$1\r\n3\r
$1\r\n*\r
$5\r\nvalue\r
$9\r\nD\x3f\xf0\x00\x00\x00\x00\x00\x00\r\n"
        );
        assert_eq!(
            &Report::report_bounded_new_value_cmd("key", &("hello".into()), 4)
                .get_packed_command(),
            b"*8\r
$4\r\nXADD\r
$3\r\nkey\r
$6\r\nMAXLEN\r
$1\r\n~\r
$1\r\n4\r
$1\r\n*\r
$5\r\nvalue\r
$10\r\nS\x00\x00\x00\x05hello\r\n"
        );
    }

    #[test]
    fn test_init_dev() {
        assert_eq!(
            String::from_utf8_lossy(
                &RedisStore::init_device_cmd("device", "mem", None)
                    .get_packed_pipeline()
            ),
            "*1\r
$5\r\nMULTI\r
*2\r
$3\r\nDEL\r
$11\r\ndevice#hist\r
*5\r
$4\r\nXADD\r
$11\r\ndevice#hist\r
$1\r\n1\r
$5\r\nvalue\r
$1\r\n\x01\r
*3\r
$4\r\nXDEL\r
$11\r\ndevice#hist\r
$1\r\n1\r
*2\r
$3\r\nDEL\r
$11\r\ndevice#info\r
*4\r
$5\r\nHMSET\r
$11\r\ndevice#info\r
$6\r\ndriver\r
$3\r\nmem\r
*1\r
$4\r\nEXEC\r\n"
        );
        assert_eq!(
            String::from_utf8_lossy(
                &RedisStore::init_device_cmd(
                    "device",
                    "pump",
                    Some(&String::from("gpm"))
                )
                .get_packed_pipeline()
            ),
            "*1\r
$5\r\nMULTI\r
*2\r
$3\r\nDEL\r
$11\r\ndevice#hist\r
*5\r
$4\r\nXADD\r
$11\r\ndevice#hist\r
$1\r\n1\r
$5\r\nvalue\r
$1\r\n\x01\r
*3\r
$4\r\nXDEL\r
$11\r\ndevice#hist\r
$1\r\n1\r
*2\r
$3\r\nDEL\r
$11\r\ndevice#info\r
*6\r
$5\r\nHMSET\r
$11\r\ndevice#info\r
$6\r\ndriver\r
$4\r\npump\r
$5\r\nunits\r
$3\r\ngpm\r
*1\r
$4\r\nEXEC\r\n"
        );
    }

    #[test]
    fn test_streamid_to_reading() {
        // Look for various failure modes.

        assert!(RedisStore::stream_id_to_reading(&StreamId {
            id: "1000-0".into(),
            map: HashMap::from([])
        })
        .is_err());
        assert!(RedisStore::stream_id_to_reading(&StreamId {
            id: "1000-0".into(),
            map: HashMap::from([(
                "junk".into(),
                redis::Value::BulkString(b"10".to_vec())
            )])
        })
        .is_err());
        assert!(RedisStore::stream_id_to_reading(&StreamId {
            id: "1000-0".into(),
            map: HashMap::from([(
                "value".into(),
                redis::Value::BulkString(b"10".to_vec())
            )])
        })
        .is_err());

        // Look for valid conversions.

        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "1000-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Bool(
                        true
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(1000),
                value: device::Value::Bool(true)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "1500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Int(
                        123
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(1500),
                value: device::Value::Int(123)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Int(
                        -321
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Int(-321)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Flt(
                        1.0
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Flt(1.0)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Flt(
                        -1.0
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Flt(-1.0)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Flt(
                        1.0e100
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Flt(1.0e100)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Flt(
                        1.0e-100
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Flt(1.0e-100)
            })
        );
        assert_eq!(
            RedisStore::stream_id_to_reading(&StreamId {
                id: "2500-0".into(),
                map: HashMap::from([(
                    "value".into(),
                    redis::Value::BulkString(to_redis(&device::Value::Str(
                        "Hello".into()
                    )))
                )])
            }),
            Ok(device::Reading {
                ts: time::UNIX_EPOCH + time::Duration::from_millis(2500),
                value: device::Value::Str("Hello".into())
            })
        );
    }

    #[test]
    fn test_hash_to_info() {
        let device: device::Name = "path:junk".try_into().unwrap();
        let mut st = HashMap::new();
        let mut fm = HashMap::new();

        assert_eq!(
            RedisStore::hash_to_info(&st, &device, &fm),
            Err(Error::NotFound)
        );

        let _ = fm.insert("units".to_string(), "gpm".to_string());

        assert_eq!(
            RedisStore::hash_to_info(&st, &device, &fm),
            Ok(client::DevInfoReply {
                name: device.clone(),
                units: Some(String::from("gpm")),
                settable: false,
                driver: "*missing*".into(),
                total_points: 0,
                first_point: None,
                last_point: None,
            })
        );

        let _ = fm.insert("driver".to_string(), "sump".to_string().into());

        assert_eq!(
            RedisStore::hash_to_info(&st, &device, &fm),
            Ok(client::DevInfoReply {
                name: device.clone(),
                units: Some(String::from("gpm")),
                settable: false,
                driver: "sump".into(),
                total_points: 0,
                first_point: None,
                last_point: None,
            })
        );

        let (tx, _) = mpsc::channel(10);
        let _ = st.insert(device.clone(), tx);

        assert_eq!(
            RedisStore::hash_to_info(&st, &device, &fm),
            Ok(client::DevInfoReply {
                name: device.clone(),
                units: Some(String::from("gpm")),
                settable: true,
                driver: "sump".into(),
                total_points: 0,
                first_point: None,
                last_point: None,
            })
        );
    }
}

---
FILE: drmemd/src/backends/simple/config.rs
use serde::Deserialize;

#[derive(Deserialize, Clone)]
pub struct Config {}

impl Config {
    pub const fn new() -> Config {
        Config {}
    }
}

pub static DEF: Config = Config::new();

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}

---
FILE: drmemd/src/backends/simple/glob.rs
use std::{iter::Fuse, str::Chars};

// Defines a finite-state machine that traverses the pattern and tries
// to match a name.

struct Fsm<'a> {
    stack: Vec<(Fuse<Chars<'a>>, Fuse<Chars<'a>>)>,

    it_pat: Fuse<Chars<'a>>,
    it_name: Fuse<Chars<'a>>,

    ch_pat: Option<char>,
    ch_name: Option<char>,
}

impl Fsm<'_> {
    pub fn new<'a>(pat: &'a str, name: &'a str) -> Fsm<'a> {
        Fsm {
            stack: vec![],
            it_pat: pat.chars().fuse(),
            it_name: name.chars().fuse(),
            ch_pat: None,
            ch_name: None,
        }
    }

    fn next_pat_char(&mut self) -> bool {
        self.ch_pat = self.it_pat.next();
        self.ch_pat.is_some()
    }

    fn next_name_char(&mut self) {
        self.ch_name = self.it_name.next();
    }

    fn save(&mut self) {
        self.stack.push((self.it_pat.clone(), self.it_name.clone()))
    }

    fn backtrace(&mut self) -> Option<bool> {
        if let Some((i_p, i_n)) = self.stack.pop() {
            self.it_pat = i_p;
            self.it_name = i_n;
            self.next_pat_char();
            self.next_name_char();
            None
        } else {
            Some(false)
        }
    }

    fn step(&mut self) -> Option<bool> {
        match (self.ch_pat, self.ch_name) {
            (None, None) | (Some('*'), None) => Some(true),

            (None, _) | (_, None) => self.backtrace(),

            (Some('?'), Some(_)) => {
                self.next_pat_char();
                self.next_name_char();
                None
            }

            (Some('*'), Some(_)) => {
                // This loop advances the pattern iterator to the
                // next literal character. If a '?' character is
                // found, it also advances the name iterator.

                while self.ch_pat == Some('?') || self.ch_pat == Some('*') {
                    // If there are no remaining pattern characters,
                    // then all trailing characters were wildcards and
                    // the pattern matches.

                    if !self.next_pat_char() {
                        return Some(true);
                    }

                    // If the next character is a '?', consume, if
                    // possible, the next name character. Otherwise
                    // look for another solution.

                    if let Some('?') = self.ch_pat {
                        if self.ch_name.is_none() {
                            return self.backtrace();
                        }
                        self.next_name_char();
                    }
                }

                while self.ch_name.is_some() {
                    if self.ch_name == self.ch_pat {
                        self.save()
                    }
                    self.next_name_char()
                }

                self.backtrace()
            }

            (Some(a), Some(b)) => {
                if a != b {
                    self.backtrace()
                } else {
                    self.next_pat_char();
                    self.next_name_char();
                    None
                }
            }
        }
    }

    pub fn process(&mut self) -> bool {
        self.next_pat_char();
        self.next_name_char();

        loop {
            if let Some(result) = self.step() {
                return result;
            }
        }
    }
}

pub struct Pattern {
    data: String,
}

impl Pattern {
    pub fn create(pat: &str) -> Pattern {
        Pattern {
            data: String::from(pat),
        }
    }

    pub fn matches(&self, name: &str) -> bool {
        let mut fsm = Fsm::new(&self.data, name);

        fsm.process()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_match() {
        // Empty input.

        assert_eq!(Pattern::create("").matches(""), true);

        // Degenerate cases.

        assert_eq!(Pattern::create("a").matches(""), false);
        assert_eq!(Pattern::create("").matches("a"), false);

        // Literal macthing.

        assert_eq!(Pattern::create("a").matches("a"), true);
        assert_eq!(Pattern::create("a").matches("b"), false);
        assert_eq!(Pattern::create("ab").matches("ab"), true);
        assert_eq!(Pattern::create("abc").matches("abc"), true);

        // Wildcard matching.

        assert_eq!(Pattern::create("?").matches("a"), true);
        assert_eq!(Pattern::create("?").matches("z"), true);
        assert_eq!(Pattern::create("a?").matches("ab"), true);
        assert_eq!(Pattern::create("a?").matches("a"), false);
        assert_eq!(Pattern::create("?bc").matches("abc"), true);
        assert_eq!(Pattern::create("a?c").matches("abc"), true);
        assert_eq!(Pattern::create("ab?").matches("abc"), true);
        assert_eq!(Pattern::create("??c").matches("abc"), true);
        assert_eq!(Pattern::create("?b?").matches("abc"), true);
        assert_eq!(Pattern::create("a??").matches("abc"), true);
        assert_eq!(Pattern::create("???").matches("abc"), true);
        assert_eq!(Pattern::create("a?c?e").matches("abcde"), true);

        // Multi-wildcard matching.

        assert_eq!(Pattern::create("*").matches(""), true);
        assert_eq!(Pattern::create("a*").matches("a"), true);
        assert_eq!(Pattern::create("a*").matches("aa"), true);
        assert_eq!(Pattern::create("a*b").matches("ab"), true);
        assert_eq!(Pattern::create("a*b").matches("azb"), true);
        assert_eq!(Pattern::create("a*b").matches("azzzzzzzzb"), true);
        assert_eq!(Pattern::create("a*bc").matches("azbc"), true);

        // Interspersed wildcards.

        assert_eq!(Pattern::create("a***bc").matches("azbc"), true);
        assert_eq!(Pattern::create("a?*cd").matches("azbcd"), true);
        assert_eq!(Pattern::create("a*?cd").matches("azbcd"), true);
        assert_eq!(Pattern::create("a*?*cd").matches("azbcd"), true);
        assert_eq!(Pattern::create("a*c*e").matches("abcde"), true);
        assert_eq!(Pattern::create("a*?de").matches("abcde"), true);

        // Devious names requiring backtracking.

        assert_eq!(Pattern::create("a*bc").matches("azbcbc"), true);
        assert_eq!(Pattern::create("a*bc").matches("azbdbc"), true);
        assert_eq!(Pattern::create("a*bc*").matches("azbcbc"), true);
        assert_eq!(Pattern::create("a*bc*").matches("azbcbd"), true);
        assert_eq!(Pattern::create("a*bc").matches("azbcd"), false);
    }
}

---
FILE: drmemd/src/backends/simple/mod.rs
//! Provides a simple, storage back-end for the DrMem control system.
//!
//! This is the simplest data-store available. It only saves the last
//! value for each device. It also doesn't provide persistent storage
//! for device meta-information so, after a restart, that information
//! is reset to its default state.
//!
//! This back-end is useful for installations that don't require
//! historical information but, instead, are doing real-time control
//! with current values.

use crate::backends::Store;
use chrono::*;
use drmem_api::{
    client, device,
    driver::{self, Reporter, RxDeviceSetting, TxDeviceSetting},
    Error, Result,
};
use std::collections::{hash_map, HashMap};
use std::{
    sync::{Arc, Mutex},
    time,
};
use tokio::sync::{broadcast, mpsc, oneshot};
use tokio_stream::{
    wrappers::{errors::BroadcastStreamRecvError, BroadcastStream},
    StreamExt,
};
use tracing::{error, warn};

const CHAN_SIZE: usize = 20;

type ReadingState =
    (broadcast::Sender<device::Reading>, Option<device::Reading>);

pub mod config;
mod glob;

#[derive(Clone)]
struct DeviceInfo {
    owner: driver::Name,
    units: Option<String>,
    tx_setting: Option<TxDeviceSetting>,
    reading: Arc<Mutex<ReadingState>>,
}

impl DeviceInfo {
    pub fn create(
        owner: String,
        units: Option<&String>,
        tx_setting: Option<TxDeviceSetting>,
    ) -> DeviceInfo {
        let (tx, _) = broadcast::channel(CHAN_SIZE);

        // Build the entry and insert it in the table.

        DeviceInfo {
            owner: owner.into(),
            units: units.cloned(),
            tx_setting,
            reading: Arc::new(Mutex::new((tx, None))),
        }
    }
}

#[derive(Clone)]
pub struct Report {
    di: DeviceInfo,
    name: device::Name,
}

impl Reporter for Report {
    async fn report_value(&mut self, value: device::Value) -> () {
        // Determine the timestamp *before* we take the mutex. The
        // timing shouldn't pay the price of waiting for the mutex so
        // we grab it right away.

        let mut ts = time::SystemTime::now();

        // If a lock is obtained, update the current value. The only
        // way a lock can fail is if it's "poisoned", which means
        // another thread panicked while holding the lock. This module
        // holds the only code that uses the mutex and all accesses
        // are short and infallible, so the error message shouldn't
        // ever get displayed.

        if let Ok(mut data) = self.di.reading.lock() {
            // At this point, we have access to the previous
            // timestamp. If the new timestamp is *before* the
            // previous, then we fudge the timestamp to be 1 s later
            // (DrMem doesn't allow data values to be inserted in
            // random order.) If, somehow, the timestamp will exceed
            // the range of the `SystemTime` type, the maxmimum
            // timestamp will be used for this sample (as well as
            // future samples.)

            if let Some(prev) = &data.1 {
                if ts <= prev.ts {
                    if let Some(nts) =
                        prev.ts.checked_add(time::Duration::from_micros(1))
                    {
                        ts = nts
                    } else {
                        ts = time::UNIX_EPOCH
                            .checked_add(time::Duration::new(
                                i64::MAX as u64,
                                999_999_999,
                            ))
                            .unwrap()
                    }
                }
            }

            let reading = device::Reading { ts, value };
            let _ = data.0.send(reading.clone());

            // Update the device's state.

            data.1 = Some(reading);
        } else {
            error!("couldn't set current value of {}", &self.name)
        }
    }
}

pub struct SimpleStore(HashMap<device::Name, DeviceInfo>);

pub async fn open(_cfg: &config::Config) -> Result<SimpleStore> {
    Ok(SimpleStore(HashMap::new()))
}

impl Store for SimpleStore {
    type Reporter = Report;

    /// Handle read-only devices registration. This function creates
    /// an association between the device name and its associated
    /// resources. Since the driver is registering a read-only device,
    /// this function doesn't allocate a channel to provide settings.
    async fn register_read_only_device<'a>(
        &'a mut self,
        driver: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        _max_history: Option<usize>,
    ) -> Result<Self::Reporter> {
        // Check to see if the device name already exists.

        match self.0.entry((*name).clone()) {
            // The device didn't exist. Create it and associate it
            // with the driver.
            hash_map::Entry::Vacant(e) => {
                // Build the entry and insert it in the table.

                let di = e.insert(DeviceInfo::create(
                    String::from(driver),
                    units,
                    None,
                ));

                // Create and return the closure that the driver will
                // use to report updates.

                Ok(Report {
                    di: di.clone(),
                    name: name.clone(),
                })
            }

            // The device already exists. If it was created from a
            // previous instance of the driver, allow the registration
            // to succeed.
            hash_map::Entry::Occupied(e) => {
                let dev_info = e.get();

                if dev_info.owner.as_ref() == driver {
                    Ok(Report {
                        di: dev_info.clone(),
                        name: name.clone(),
                    })
                } else {
                    Err(Error::InUse)
                }
            }
        }
    }

    /// Handle read-write devices registration. This function creates
    /// an association between the device name and its associated
    /// resources.
    async fn register_read_write_device<'a>(
        &'a mut self,
        driver: &'a str,
        name: &'a device::Name,
        units: Option<&'a String>,
        _max_history: Option<usize>,
    ) -> Result<(Self::Reporter, RxDeviceSetting, Option<device::Value>)> {
        // Check to see if the device name already exists.

        match self.0.entry((*name).clone()) {
            // The device didn't exist. Create it and associate it
            // with the driver.
            hash_map::Entry::Vacant(e) => {
                // Create a channel with which to send settings.

                let (tx_sets, rx_sets) = mpsc::channel(CHAN_SIZE);

                // Build the entry and insert it in the table.

                let di = e.insert(DeviceInfo::create(
                    String::from(driver),
                    units,
                    Some(tx_sets),
                ));

                // Create and return the closure that the driver will
                // use to report updates.

                Ok((
                    Report {
                        di: di.clone(),
                        name: name.clone(),
                    },
                    rx_sets,
                    None,
                ))
            }

            // The device already exists. If it was created from a
            // previous instance of the driver, allow the registration
            // to succeed.
            hash_map::Entry::Occupied(mut e) => {
                let dev_info = e.get_mut();

                if dev_info.owner.as_ref() == driver {
                    // Create a channel with which to send settings.

                    let (tx_sets, rx_sets) = mpsc::channel(CHAN_SIZE);

                    dev_info.tx_setting = Some(tx_sets);

                    let func = Report {
                        di: dev_info.clone(),
                        name: name.clone(),
                    };
                    let guard = dev_info.reading.lock();

                    Ok((
                        func,
                        rx_sets,
                        if let Ok(data) = guard {
                            data.1.as_ref().map(
                                |device::Reading { value, .. }| value.clone(),
                            )
                        } else {
                            None
                        },
                    ))
                } else {
                    Err(Error::InUse)
                }
            }
        }
    }

    async fn get_device_info<'a>(
        &'a mut self,
        pattern: Option<&'a str>,
    ) -> Result<Vec<client::DevInfoReply>> {
        let pred: Box<dyn FnMut(&(&device::Name, &DeviceInfo)) -> bool> =
            if let Some(pattern) = pattern {
                if let Ok(pattern) = pattern.try_into() {
                    Box::new(move |(k, _)| **k == pattern)
                } else {
                    Box::new(move |(k, _)| {
                        glob::Pattern::create(pattern).matches(&k.to_string())
                    })
                }
            } else {
                Box::new(|_| true)
            };
        let res: Vec<client::DevInfoReply> = self
            .0
            .iter()
            .filter(pred)
            .map(|(k, v)| {
                let (tot, rdg) = if let Ok(data) = v.reading.lock() {
                    if data.1.is_some() {
                        (1, data.1.clone())
                    } else {
                        (0, None)
                    }
                } else {
                    (0, None)
                };

                client::DevInfoReply {
                    name: k.clone(),
                    units: v.units.clone(),
                    settable: v.tx_setting.is_some(),
                    driver: v.owner.clone(),
                    total_points: tot,
                    first_point: rdg.clone(),
                    last_point: rdg,
                }
            })
            .collect();

        Ok(res)
    }

    async fn set_device(
        &self,
        name: device::Name,
        value: device::Value,
    ) -> Result<device::Value> {
        if let Some(di) = self.0.get(&name) {
            if let Some(tx) = &di.tx_setting {
                let (tx_rpy, rx_rpy) = oneshot::channel();

                match tx.send((value, tx_rpy)).await {
                    Ok(()) => match rx_rpy.await {
                        Ok(reply) => reply,
                        Err(_) => Err(Error::MissingPeer(
                            "driver broke connection".to_string(),
                        )),
                    },
                    Err(_) => Err(Error::MissingPeer(
                        "driver is ignoring settings".to_string(),
                    )),
                }
            } else {
                Err(Error::OperationError(format!("{} is read-only", &name)))
            }
        } else {
            Err(Error::NotFound)
        }
    }

    async fn get_setting_chan(
        &self,
        name: device::Name,
        _own: bool,
    ) -> Result<TxDeviceSetting> {
        if let Some(di) = self.0.get(&name) {
            if let Some(tx) = &di.tx_setting {
                return Ok(tx.clone());
            }
        }
        Err(Error::NotFound)
    }

    // Handles a request to monitor a device's changing value. The
    // caller must pass in the name of the device. Returns a stream
    // which returns the last value reported for the device followed
    // by all new updates.

    async fn monitor_device(
        &mut self,
        name: device::Name,
        start: Option<DateTime<Utc>>,
        end: Option<DateTime<Utc>>,
    ) -> Result<device::DataStream<device::Reading>> {
        // Look-up the name of the device. If it doesn't exist, return
        // an error.

        if let Some(di) = self.0.get(&name) {
            // Lock the mutex which protects the broadcast channel and
            // the device's last values.

            if let Ok(guard) = di.reading.lock() {
                let chan = guard.0.subscribe();

                // Convert the broadcast channel into a broadcast
                // stream. Broadcast channels report when a client is
                // too slow in reading values, by returning an error.
                // The DrMem core doesn't know (or care) about these
                // low-level details and doesn't expect them so we
                // filter the errors, but report them to the log.

                let strm =
                    BroadcastStream::new(chan).filter_map(move |entry| {
                        match entry {
                            Ok(v) => Some(v),
                            Err(BroadcastStreamRecvError::Lagged(count)) => {
                                warn!("missed {} readings of {}", count, &name);
                                None
                            }
                        }
                    });

                match (start.map(|v| v.into()), end.map(|v| v.into())) {
                    (None, None) => {
                        if let Some(prev) = &guard.1 {
                            Ok(Box::pin(
                                tokio_stream::once(prev.clone()).chain(strm),
                            )
                                as device::DataStream<device::Reading>)
                        } else {
                            Ok(Box::pin(strm)
                                as device::DataStream<device::Reading>)
                        }
                    }
                    (None, Some(end)) => {
                        let not_end = move |v: &device::Reading| v.ts <= end;

                        if let Some(prev) = &guard.1 {
                            Ok(Box::pin(
                                tokio_stream::once(prev.clone())
                                    .chain(strm)
                                    .take_while(not_end),
                            )
                                as device::DataStream<device::Reading>)
                        } else {
                            Ok(Box::pin(strm.take_while(not_end))
                                as device::DataStream<device::Reading>)
                        }
                    }
                    (Some(start), None) => {
                        let valid = move |v: &device::Reading| v.ts >= start;

                        if let Some(prev) = &guard.1 {
                            Ok(Box::pin(
                                tokio_stream::once(prev.clone())
                                    .chain(strm)
                                    .filter(valid),
                            )
                                as device::DataStream<device::Reading>)
                        } else {
                            Ok(Box::pin(strm.filter(valid))
                                as device::DataStream<device::Reading>)
                        }
                    }
                    (Some(start_tmp), Some(end_tmp)) => {
                        // Make sure the `start` time is before the
                        // `end` time.

                        let start: time::SystemTime =
                            std::cmp::min(start_tmp, end_tmp);
                        let end: time::SystemTime =
                            std::cmp::max(start_tmp, end_tmp);

                        // Define predicates for filters.

                        let valid = move |v: &device::Reading| v.ts >= start;
                        let not_end = move |v: &device::Reading| v.ts <= end;

                        if let Some(prev) = &guard.1 {
                            Ok(Box::pin(
                                tokio_stream::once(prev.clone())
                                    .chain(strm)
                                    .filter(valid)
                                    .take_while(not_end),
                            )
                                as device::DataStream<device::Reading>)
                        } else {
                            Ok(Box::pin(strm.filter(valid).take_while(not_end))
                                as device::DataStream<device::Reading>)
                        }
                    }
                }
            } else {
                Err(Error::OperationError(
                    "unable to lock reading channel".to_owned(),
                ))
            }
        } else {
            Err(Error::NotFound)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::{DeviceInfo, Report, SimpleStore};
    use crate::backends::Store;
    use drmem_api::device;
    use drmem_api::driver::Reporter;
    use std::{collections::HashMap, time};
    use tokio::sync::{mpsc::error::TryRecvError, oneshot};
    use tokio::time::interval;
    use tokio_stream::StreamExt;

    #[test]
    fn test_timestamp() {
        assert!(time::UNIX_EPOCH
            .checked_add(time::Duration::new(i64::MAX as u64, 999_999_999))
            .is_some())
    }

    #[tokio::test]
    async fn test_read_live_stream() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "test:device".try_into().unwrap();

        if let Ok(mut f) = db
            .register_read_only_device("test", &name, None, None)
            .await
        {
            // Test that priming the history with one value returns
            // the entire sequence.

            {
                let data = vec![1, 2, 3];

                f.report_value(device::Value::Int(data[0])).await;

                let s = db
                    .monitor_device(name.clone(), None, None)
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in &data[1..] {
                    f.report_value(device::Value::Int(*ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(1)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert!(s.try_next().await.is_err());
            }

            // Test that priming the history with two values only
            // returns the latest and all remaining.

            {
                let data = vec![1, 2, 3, 4];

                f.report_value(device::Value::Int(data[0])).await;
                f.report_value(device::Value::Int(data[1])).await;

                let s = db
                    .monitor_device(name.clone(), None, None)
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in &data[2..] {
                    f.report_value(device::Value::Int(*ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(4)
                );
                assert!(s.try_next().await.is_err());
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_read_start_stream() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "test:device".try_into().unwrap();

        if let Ok(mut f) = db
            .register_read_only_device("test", &name, None, None)
            .await
        {
            // Verify that monitoring device, starting now, picks up
            // all future inserted data.

            {
                let data = vec![1, 2, 3];

                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(time::SystemTime::now().into()),
                        None,
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                assert!(s.try_next().await.is_err());

                for ii in data {
                    f.report_value(device::Value::Int(ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(1)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert!(s.try_next().await.is_err());
            }

            // Verify that, if the latest point is before the starting
            // timestamp, it doesn't get returned.

            {
                let data = vec![1, 2, 3];

                f.report_value(device::Value::Int(data[0])).await;

                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(time::SystemTime::now().into()),
                        None,
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in &data[1..] {
                    f.report_value(device::Value::Int(*ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert!(s.try_next().await.is_err());
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_read_end_stream() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "test:device".try_into().unwrap();

        if let Ok(mut f) = db
            .register_read_only_device("test", &name, None, None)
            .await
        {
            // Verify that, if the latest point is before the starting
            // timestamp, it doesn't get returned.

            {
                let data = vec![1, 2, 3];

                f.report_value(device::Value::Int(data[0])).await;

                let s = db
                    .monitor_device(
                        name.clone(),
                        None,
                        Some(time::SystemTime::now().into()),
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in &data[1..] {
                    f.report_value(device::Value::Int(*ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(1)
                );
                assert_eq!(s.try_next().await.unwrap(), None);
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_read_start_end_stream() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "test:device".try_into().unwrap();

        if let Ok(mut f) = db
            .register_read_only_device("test", &name, None, None)
            .await
        {
            // Verify that, if both times are before the data, nothing
            // is returned.

            {
                let data = vec![1, 2, 3, 4, 5];

                let mut interval = interval(time::Duration::from_millis(100));

                let now = time::SystemTime::now();
                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(
                            now.checked_sub(time::Duration::from_millis(500))
                                .unwrap()
                                .into(),
                        ),
                        Some(
                            now.checked_sub(time::Duration::from_millis(250))
                                .unwrap()
                                .into(),
                        ),
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in data {
                    interval.tick().await;
                    f.report_value(device::Value::Int(ii)).await;
                }

                assert_eq!(s.try_next().await.unwrap(), None);
            }

            // Verify that, if the latest point is before the starting
            // timestamp, it doesn't get returned.

            {
                let data = vec![1, 2, 3, 4, 5];

                f.report_value(device::Value::Int(data[0])).await;
                let mut interval = interval(time::Duration::from_millis(100));

                let now = time::SystemTime::now();
                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(now.into()),
                        Some(
                            now.checked_add(time::Duration::from_millis(250))
                                .unwrap()
                                .into(),
                        ),
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in &data[1..] {
                    interval.tick().await;
                    f.report_value(device::Value::Int(*ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(4)
                );
                assert_eq!(s.try_next().await.unwrap(), None);
            }

            // Verify that, if the latest point is after the starting
            // timestamp, it isn't part of the results.

            {
                let data = vec![1, 2, 3, 4, 5];

                let mut interval = interval(time::Duration::from_millis(100));

                let now = time::SystemTime::now();
                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(now.into()),
                        Some(
                            now.checked_add(time::Duration::from_millis(250))
                                .unwrap()
                                .into(),
                        ),
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in data {
                    interval.tick().await;
                    f.report_value(device::Value::Int(ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(1)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(2)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert_eq!(s.try_next().await.unwrap(), None);
            }

            // Verify that, if the latest point is after the starting
            // timestamp, it isn't part of the results.

            {
                let data = vec![1, 2, 3, 4, 5];

                let mut interval = interval(time::Duration::from_millis(100));

                let now = time::SystemTime::now();
                let s = db
                    .monitor_device(
                        name.clone(),
                        Some(
                            now.checked_add(time::Duration::from_millis(150))
                                .unwrap()
                                .into(),
                        ),
                        Some(
                            now.checked_add(time::Duration::from_millis(350))
                                .unwrap()
                                .into(),
                        ),
                    )
                    .await
                    .unwrap()
                    .timeout(time::Duration::from_millis(100));

                tokio::pin!(s);

                for ii in data {
                    interval.tick().await;
                    f.report_value(device::Value::Int(ii)).await;
                }

                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(3)
                );
                assert_eq!(
                    s.try_next().await.unwrap().unwrap().value,
                    device::Value::Int(4)
                );
                assert_eq!(s.try_next().await.unwrap(), None);
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_ro_registration() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "misc:junk".try_into().unwrap();

        // Register a device named "junk" and associate it with the
        // driver named "test". We don't define units for this device.

        if let Ok(mut f) = db
            .register_read_only_device("test", &name, None, None)
            .await
        {
            // Make sure the device was defined and the setting
            // channel is `None`.

            assert!(db.0.get(&name).unwrap().tx_setting.is_none());

            // Report a value.

            f.report_value(device::Value::Int(1)).await;

            // Create a receiving handle for device updates.

            let mut rx =
                db.0.get(&name)
                    .unwrap()
                    .reading
                    .lock()
                    .unwrap()
                    .0
                    .subscribe();

            // Assert that re-registering this device with a different
            // driver name results in an error.

            assert!(db
                .register_read_only_device("test2", &name, None, None)
                .await
                .is_err());

            // Assert that re-registering this device with the same
            // driver name is successful.

            if let Ok(mut f) = db
                .register_read_only_device("test", &name, None, None)
                .await
            {
                // Also, verify that the device update channel wasn't
                // disrupted by sending a value and receiving it from
                // the receive handle we opened before re-registering.

                f.report_value(device::Value::Int(2)).await;
                assert_eq!(rx.try_recv().unwrap().value, device::Value::Int(2));
            } else {
                panic!("error registering read-only device from same driver")
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_rw_registration() {
        let mut db = SimpleStore(HashMap::new());
        let name: device::Name = "misc:junk".try_into().unwrap();

        // Register a device named "junk" and associate it with the
        // driver named "test". We don't define units for this device.

        if let Ok((mut f, mut set_chan, None)) = db
            .register_read_write_device("test", &name, None, None)
            .await
        {
            // Make sure the device was defined and a setting channel
            // has been created.

            assert!(db.0.get(&name).unwrap().tx_setting.is_some());

            // Make sure the setting channel is valid.

            {
                let tx_set =
                    db.0.get(&name).unwrap().tx_setting.clone().unwrap();

                assert_eq!(tx_set.is_closed(), false);

                let (tx_os, _rx_os) = oneshot::channel();

                assert!(tx_set
                    .send((device::Value::Int(2), tx_os))
                    .await
                    .is_ok());
                assert_eq!(
                    set_chan.try_recv().unwrap().0,
                    device::Value::Int(2)
                );
            }

            // Report a value.

            f.report_value(device::Value::Int(1)).await;

            // Create a receiving handle for device updates.

            let mut rx =
                db.0.get(&name)
                    .unwrap()
                    .reading
                    .lock()
                    .unwrap()
                    .0
                    .subscribe();

            // Assert that re-registering this device with a different
            // driver name results in an error. Also verify that it
            // didn't affect the setting channel.

            assert!(db
                .register_read_only_device("test2", &name, None, None)
                .await
                .is_err());
            assert_eq!(
                Err(TryRecvError::Empty),
                set_chan.try_recv().map(|_| ())
            );

            // Assert that re-registering this device with the same
            // driver name is successful.

            if let Ok((mut f, _, Some(device::Value::Int(1)))) = db
                .register_read_write_device("test", &name, None, None)
                .await
            {
                assert_eq!(
                    Err(TryRecvError::Empty),
                    set_chan.try_recv().map(|_| ())
                );

                // Also, verify that the device update channel wasn't
                // disrupted by sending a value and receiving it from
                // the receive handle we opened before re-registering.

                f.report_value(device::Value::Int(2)).await;
                assert_eq!(rx.try_recv().unwrap().value, device::Value::Int(2));
            } else {
                panic!("error registering read-only device from same driver")
            }
        } else {
            panic!("error registering read-only device on empty database")
        }
    }

    #[tokio::test]
    async fn test_closure() {
        let di = DeviceInfo::create(String::from("test"), None, None);
        let name: device::Name = "misc:junk".try_into().unwrap();
        let mut f = Report {
            di: di.clone(),
            name: name.clone(),
        };

        assert_eq!(di.reading.lock().unwrap().1, None);
        f.report_value(device::Value::Int(1)).await;
        assert_eq!(
            di.reading.lock().unwrap().1.as_ref().unwrap().value,
            device::Value::Int(1)
        );

        {
            let ts1 = di.reading.lock().unwrap().1.as_ref().unwrap().ts;
            let mut rx = di.reading.lock().unwrap().0.subscribe();

            f.report_value(device::Value::Int(2)).await;
            assert_eq!(rx.try_recv().unwrap().value, device::Value::Int(2));
            assert_eq!(
                di.reading.lock().unwrap().1.as_ref().unwrap().value,
                device::Value::Int(2)
            );
            assert!(ts1 < di.reading.lock().unwrap().1.as_ref().unwrap().ts);
        }

        f.report_value(device::Value::Int(3)).await;
        assert_eq!(
            di.reading.lock().unwrap().1.as_ref().unwrap().value,
            device::Value::Int(3)
        );

        {
            let mut rx1 = di.reading.lock().unwrap().0.subscribe();
            let mut rx2 = di.reading.lock().unwrap().0.subscribe();

            f.report_value(device::Value::Int(4)).await;
            assert_eq!(rx1.try_recv().unwrap().value, device::Value::Int(4));
            assert_eq!(rx2.try_recv().unwrap().value, device::Value::Int(4));
            assert_eq!(
                di.reading.lock().unwrap().1.as_ref().unwrap().value,
                device::Value::Int(4)
            );
        }
    }
}

---
FILE: drmemd/src/config.rs
use crate::backends::store;
use drmem_api::{Error, Result};
use serde::Deserialize;
use std::{collections::HashMap, env, sync::Arc};
use toml::{self, value};
use tracing::Level;

use drmem_api::device;

fn def_log_level() -> String {
    String::from("warn")
}

#[derive(Deserialize)]
pub struct Config {
    #[serde(default = "def_log_level")]
    log_level: String,
    pub latitude: f64,
    pub longitude: f64,
    #[cfg(feature = "graphql")]
    #[serde(default)]
    pub graphql: super::graphql::config::Config,
    pub backend: Option<store::config::Config>,
    #[serde(default)]
    pub driver: Vec<Driver>,
    #[serde(default)]
    pub logic: Vec<Logic>,
}

impl<'a> Config {
    pub fn get_log_level(&self) -> Level {
        match self.log_level.as_str() {
            "info" => Level::INFO,
            "debug" => Level::DEBUG,
            "trace" => Level::TRACE,
            _ => Level::WARN,
        }
    }

    pub fn get_backend(&'a self) -> &'a store::config::Config {
        self.backend.as_ref().unwrap_or(&store::config::DEF)
    }

    #[cfg(feature = "graphql")]
    pub fn get_graphql_addr(&self) -> std::net::SocketAddr {
        self.graphql.addr
    }

    #[cfg(feature = "graphql")]
    pub fn get_name(&self) -> String {
        self.graphql.name.clone()
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            log_level: String::from("warn"),
            latitude: 0.0,
            longitude: 0.0,
            #[cfg(feature = "graphql")]
            graphql: super::graphql::config::Config::default(),
            backend: Some(store::config::Config::new()),
            driver: vec![],
            logic: vec![],
        }
    }
}

#[derive(Deserialize)]
pub struct Driver {
    pub name: String,
    pub prefix: device::Path,
    pub max_history: Option<usize>,
    pub cfg: Option<value::Table>,
}

#[derive(Deserialize, Clone)]
pub struct Logic {
    pub name: String,
    pub summary: Option<Arc<str>>,
    #[serde(default)]
    pub defs: HashMap<String, String>,
    pub exprs: Vec<String>,
    #[serde(default)]
    pub inputs: HashMap<String, device::Name>,
    pub outputs: HashMap<String, device::Name>,
}

fn from_cmdline(mut cfg: Config) -> (bool, Config) {
    use clap::{crate_version, Arg, ArgAction, Command};

    // Define the command line arguments.

    let matches = Command::new("DrMem Mini Control System")
        .version(crate_version!())
        .about("A small, yet capable, control system.")
        .arg(
            Arg::new("config")
                .short('c')
                .long("config")
                .action(ArgAction::Set)
                .value_name("FILE")
                .help("Specifies the configuration file"),
        )
        .arg(
            Arg::new("verbose")
                .short('v')
                .long("verbose")
                .action(ArgAction::Count)
                .help("Sets verbosity of log; can be used more than once"),
        )
        .arg(
            Arg::new("print_cfg")
                .long("print-config")
                .action(ArgAction::SetTrue)
                .help("Displays the configuration and exits"),
        )
        .get_matches();

    // The number of '-v' options determines the log level.

    match matches.get_count("verbose") {
        0 => (),
        1 => cfg.log_level = String::from("info"),
        2 => cfg.log_level = String::from("debug"),
        _ => cfg.log_level = String::from("trace"),
    };

    // Return the config built from the command line and a flag
    // indicating the user wants the final configuration displayed.

    (matches.get_flag("print_cfg"), cfg)
}

fn parse_config(contents: &str) -> Result<Config> {
    toml::from_str(contents)
        .map_err(|e| Error::ConfigError(format!("{e}")))
        .and_then(|cfg: Config| {
            // Make sure latitude is between -90 and 90 degrees.

            if !(-90.0..=90.0).contains(&cfg.latitude) {
                return Err(Error::ConfigError(
                    "'latitude' is out of range".into(),
                ));
            }

            // Make sure longitude is between -180 and 180 degrees.

            if !(-180.0..=180.0).contains(&cfg.longitude) {
                return Err(Error::ConfigError(
                    "'longitude' is out of range".into(),
                ));
            }
            Ok(cfg)
        })
}

async fn from_file(path: &str) -> Option<Result<Config>> {
    use tokio::fs;

    if let Ok(contents) = fs::read(path).await {
        let contents = String::from_utf8_lossy(&contents);

        Some(parse_config(&contents))
    } else {
        None
    }
}

async fn find_cfg() -> Result<Config> {
    const CFG_FILE: &str = "drmem.toml";

    // Create a vector of directories that could contain a
    // configuration file. The directories will be searched in their
    // order within the vector.

    let mut dirs = vec![String::from("./")];

    // If the user has `HOME` defined, append their home directory to
    // the search path. Note the end of the path has a period. This is
    // done so the file will be named `.drmem.toml` in the home
    // directory. (Kind of hack-y, I know.)

    if let Ok(home) = env::var("HOME") {
        dirs.push(format!("{home}/."))
    }

    // Add other, common configuration areas.

    dirs.push(String::from("/usr/local/etc/"));
    dirs.push(String::from("/usr/pkg/etc/"));
    dirs.push(String::from("/etc/"));

    // Iterate through the directories. The first file that is found
    // and can be parsed is used as the configuration.

    for dir in dirs {
        let file = format!("{}{}", &dir, CFG_FILE);

        if let Some(cfg) = from_file(&file).await {
            return cfg;
        }
    }
    Ok(Config::default())
}

fn dump_config(cfg: &Config) {
    println!("Configuration:");
    println!("    log level: {}\n", cfg.get_log_level());

    #[cfg(feature = "simple-backend")]
    {
        println!("Using SIMPLE backend -- no configuration for it.\n");
    }

    #[cfg(feature = "redis-backend")]
    {
        println!("Using REDIS for storage:");
        println!("    address: {}", &cfg.get_backend().get_addr());
        println!("    db #: {}\n", cfg.get_backend().get_dbn());
    }

    #[cfg(feature = "graphql")]
    {
        println!("Using GraphQL:");
        println!("    instance name: {}", cfg.get_name());
        println!("    address: {}\n", cfg.get_graphql_addr());
    }

    println!("Driver configuration:");
    if !cfg.driver.is_empty() {
        for ii in &cfg.driver {
            println!(
                "    name: {}\n    prefix: '{}'\n    cfg: {:?}\n",
                &ii.name,
                &ii.prefix,
                ii.cfg.as_ref().unwrap_or(&value::Table::new())
            )
        }
    } else {
        println!("    No drivers specified.");
    }
}

#[tracing::instrument(name = "loading config")]
pub async fn get() -> Option<Config> {
    match find_cfg().await {
        Ok(cfg) => {
            let (print_cfg, cfg) = from_cmdline(cfg);

            if print_cfg {
                dump_config(&cfg);
                None
            } else {
                Some(cfg)
            }
        }
        Err(e) => {
            println!("{e}");
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config() {
        // Verify the defaults.

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
"#,
        ) {
            Ok(cfg) => assert_eq!(cfg.get_log_level(), Level::WARN),
            Err(e) => panic!("TOML parse error: {}", e),
        }

        // Verify the log_level can be set.

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
log_level = "trace"
"#,
        ) {
            Ok(cfg) => assert_eq!(cfg.get_log_level(), Level::TRACE),
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
log_level = "debug"
"#,
        ) {
            Ok(cfg) => assert_eq!(cfg.get_log_level(), Level::DEBUG),
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
log_level = "info"
"#,
        ) {
            Ok(cfg) => assert_eq!(cfg.get_log_level(), Level::INFO),
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
log_level = "warn"
"#,
        ) {
            Ok(cfg) => assert_eq!(cfg.get_log_level(), Level::WARN),
            Err(e) => panic!("TOML parse error: {}", e),
        }
    }

    #[cfg(feature = "graphql")]
    #[test]
    fn test_graphql_config() {
        use std::net::Ipv4Addr;

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
                assert_eq!(cfg.graphql.pref_host, None);
                assert_eq!(cfg.graphql.pref_port, 3000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
                assert_eq!(cfg.graphql.pref_host, None);
                assert_eq!(cfg.graphql.pref_port, 3000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]
name = "primary-node"
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "primary-node");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
                assert_eq!(cfg.graphql.pref_host, None);
                assert_eq!(cfg.graphql.pref_port, 3000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]
location = "basement"
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "basement".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]
addr = "10.1.1.0:1234"
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(10, 1, 1, 0), 1234).into()
                );
                assert_eq!(cfg.graphql.pref_host, None);
                assert_eq!(cfg.graphql.pref_port, 3000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]
pref_host = "www.google.com"
pref_port = 4000
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
                assert_eq!(
                    cfg.graphql.pref_host,
                    Some("www.google.com".into())
                );
                assert_eq!(cfg.graphql.pref_port, 4000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[graphql]
pref_host = "www.google.com"
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.graphql.name, "unknown name");
                assert_eq!(cfg.graphql.location, "unknown location".into());
                assert_eq!(
                    cfg.graphql.addr,
                    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
                );
                assert_eq!(
                    cfg.graphql.pref_host,
                    Some("www.google.com".into())
                );
                assert_eq!(cfg.graphql.pref_port, 3000)
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }
    }

    #[test]
    fn test_driver_section() {
        // Verify that the [[driver]] section needs an entry to be
        // defined..

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[driver]]
"#,
            )
            .is_err(),
            "TOML parser accepted empty [[driver]] section"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[driver]]
name = "none"
"#,
            )
            .is_err(),
            "TOML parser accepted [[driver]] section with missing prefix"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[driver]]
prefix = "null"
"#,
            )
            .is_err(),
            "TOML parser accepted [[driver]] section with missing name"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[driver]]
name = "none"
prefix = "null"
max_history = false
"#,
            )
            .is_err(),
            "TOML parser accepted [[driver]] section with bad max_history"
        );

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[[driver]]
name = "none"
prefix = "null"
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.driver.len(), 1);

                assert_eq!(cfg.driver[0].name, "none");
                assert_eq!(
                    cfg.driver[0].prefix,
                    TryInto::<device::Path>::try_into("null").unwrap()
                );
                assert_eq!(cfg.driver[0].max_history, None);
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[[driver]]
name = "none"
prefix = "null"
max_history = 10000
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.driver.len(), 1);

                assert_eq!(cfg.driver[0].name, "none");
                assert_eq!(
                    cfg.driver[0].prefix,
                    TryInto::<device::Path>::try_into("null").unwrap()
                );
                assert_eq!(cfg.driver[0].max_history, Some(10000));
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }
    }

    #[test]
    fn test_logic_section() {
        // Verify that the [[logic]] section needs an entry to be
        // defined..

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]"#
            )
            .is_err(),
            "TOML parser accepted empty [[logic]] section"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'exprs' and 'outputs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
exprs = []
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'name' and 'outputs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
outputs = {}
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'name' and 'exprs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
exprs = []
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'outputs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
outputs = {}
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'exprs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
exprs = []
outputs = {}
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with missing 'name'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
exprs = []
inputs = { bulb = "junk+name" }
outputs = {}
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with bad device name in 'inputs'"
        );

        assert!(
            toml::from_str::<Config>(
                r#"
latitude = -45.0
longitude = 45.0

[[logic]]
exprs = []
outputs = { bulb = "junk+name" }
"#,
            )
            .is_err(),
            "TOML parser accepted [[logic]] section with bad device name in 'outputs'"
        );

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
exprs = []
outputs = {}
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.logic.len(), 1);
                assert_eq!(cfg.logic[0].name, "none");
                assert!(cfg.logic[0].defs.is_empty());
                assert!(cfg.logic[0].exprs.is_empty());
                assert!(cfg.logic[0].inputs.is_empty());
                assert!(cfg.logic[0].outputs.is_empty());
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
exprs = []
outputs = { bulb = "room:bulb:enable" }
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.logic.len(), 1);
                assert_eq!(cfg.logic[0].name, "none");
                assert!(cfg.logic[0].defs.is_empty());
                assert!(cfg.logic[0].exprs.is_empty());
                assert!(cfg.logic[0].inputs.is_empty());
                assert_eq!(
                    cfg.logic[0].outputs.get("bulb"),
                    Some(
                        &TryInto::<device::Name>::try_into("room:bulb:enable")
                            .unwrap()
                    )
                );
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[[logic]]
name = "none"
exprs = []
inputs = { bulb = "room:bulb:enable" }
outputs = {}
"#,
        ) {
            Ok(cfg) => {
                assert_eq!(cfg.logic.len(), 1);
                assert_eq!(cfg.logic[0].name, "none");
                assert!(cfg.logic[0].defs.is_empty());
                assert!(cfg.logic[0].exprs.is_empty());
                assert!(cfg.logic[0].outputs.is_empty());
                assert_eq!(
                    cfg.logic[0].inputs.get("bulb"),
                    Some(
                        &TryInto::<device::Name>::try_into("room:bulb:enable")
                            .unwrap()
                    )
                );
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }
    }

    #[cfg(feature = "simple-backend")]
    #[test]
    fn test_simple_config() {}

    #[cfg(feature = "redis-backend")]
    #[test]
    fn test_redis_config() {
        // Verify a missing [backend] results in a properly defined
        // default.

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0
"#,
        ) {
            Ok(cfg) => {
                let def_cfg = Config::default();

                assert_eq!(
                    cfg.get_backend().get_addr(),
                    def_cfg.get_backend().get_addr()
                );
                assert_eq!(
                    cfg.get_backend().get_dbn(),
                    def_cfg.get_backend().get_dbn()
                );
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        // Verify the [backend] section can handle only one field at a
        // time.

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[backend]
addr = "192.168.1.1:6000"
"#,
        ) {
            Ok(cfg) => {
                let def_cfg = Config::default();

                assert_eq!(
                    cfg.get_backend().get_addr(),
                    "192.168.1.1:6000".parse().unwrap()
                );
                assert_eq!(
                    cfg.get_backend().get_dbn(),
                    def_cfg.get_backend().get_dbn()
                );
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }

        match toml::from_str::<Config>(
            r#"
latitude = -45.0
longitude = 45.0

[backend]
dbn = 3
"#,
        ) {
            Ok(cfg) => {
                let def_cfg = Config::default();

                assert_eq!(
                    cfg.get_backend().get_addr(),
                    def_cfg.get_backend().get_addr()
                );
                assert_eq!(cfg.get_backend().get_dbn(), 3);
            }
            Err(e) => panic!("TOML parse error: {}", e),
        }
    }
}

---
FILE: drmemd/src/core/mod.rs
use crate::backends::{store, Instance, Store};
use drmem_api::{client, driver, Error, Result};
use std::convert::Infallible;
use tokio::{sync::mpsc, task::JoinHandle};
use tracing::{info, info_span, warn, Instrument};

/// Holds the state of the core task in the framework.
///
/// The core task starts-up the necessary drivers and maintains a
/// table of active devices. Drivers and client communicate with the
/// core task through channels.
struct State {
    backend: Instance,
}

impl State {
    /// Creates an initialized state for the core task.
    async fn create(cfg: store::config::Config) -> Result<Self> {
        Ok(State {
            backend: store::open(&cfg).await?,
        })
    }

    /// Handles incoming requests and returns a reply.
    async fn handle_driver_request(
        &mut self,
        req: driver::Request<<Instance as Store>::Reporter>,
    ) {
        match req {
            driver::Request::AddReadonlyDevice {
                ref driver_name,
                ref dev_name,
                ref dev_units,
                max_history,
                rpy_chan,
            } => {
                let result = self
                    .backend
                    .register_read_only_device(
                        driver_name,
                        dev_name,
                        dev_units.as_ref(),
                        max_history,
                    )
                    .await
                    .map_err(|_| Error::DeviceDefined(format!("{dev_name}")));

                if rpy_chan.send(result).is_err() {
                    warn!("driver exited before a reply could be sent")
                }
            }

            driver::Request::AddReadWriteDevice {
                ref driver_name,
                ref dev_name,
                ref dev_units,
                max_history,
                rpy_chan,
            } => {
                let result = self
                    .backend
                    .register_read_write_device(
                        driver_name,
                        dev_name,
                        dev_units.as_ref(),
                        max_history,
                    )
                    .await
                    .map_err(|_| Error::DeviceDefined(format!("{dev_name}")));

                if rpy_chan.send(result).is_err() {
                    warn!("driver exited before a reply could be sent")
                }
            }
        }
    }

    async fn handle_client_request(&mut self, req: client::Request) {
        match req {
            client::Request::QueryDeviceInfo { pattern, rpy_chan } => {
                let result =
                    self.backend.get_device_info(pattern.as_deref()).await;

                if let Err(ref e) = result {
                    info!("get_device_info() returned '{}'", e);
                }

                if rpy_chan.send(result).is_err() {
                    warn!("client exited before a reply could be sent")
                }
            }

            client::Request::SetDevice {
                name,
                value,
                rpy_chan,
            } => {
                let fut = self.backend.set_device(name, value);

                if rpy_chan.send(fut.await).is_err() {
                    warn!("client exited before a reply could be sent")
                }
            }

            client::Request::GetSettingChan {
                name,
                _own,
                rpy_chan,
            } => {
                let fut = self.backend.get_setting_chan(name, _own);

                if rpy_chan.send(fut.await).is_err() {
                    warn!("client exited before a reply could be sent")
                }
            }

            client::Request::MonitorDevice {
                name,
                rpy_chan,
                start,
                end,
            } => {
                let fut = self.backend.monitor_device(name, start, end);

                if rpy_chan.send(fut.await).is_err() {
                    warn!("client exited before a reply could be sent")
                }
            }
        }
    }

    /// Captures the State and runs as a async task using it as its
    /// mutable state. Normally it is run as a background task using
    /// `task::spawn`.
    async fn run(
        mut self,
        mut rx_drv_req: mpsc::Receiver<
            driver::Request<<Instance as Store>::Reporter>,
        >,
        mut rx_clnt_req: mpsc::Receiver<client::Request>,
    ) -> Result<Infallible> {
        info!("starting");
        loop {
            #[rustfmt::skip]
            tokio::select! {
		Some(req) = rx_drv_req.recv() =>
                    self
		    .handle_driver_request(req)
		    .instrument(info_span!("driver_req"))
		    .await,
		Some(req) = rx_clnt_req.recv() =>
                    self
		    .handle_client_request(req)
		    .instrument(info_span!("client_req"))
		    .await,
		else => break
            }
        }

        const ERR_MSG: &str = "no drivers or clients left";

        warn!(ERR_MSG);
        Err(Error::MissingPeer(ERR_MSG.to_string()))
    }
}

/// Starts the core task. Returns an `mpsc::Sender<>` handle so other
/// tasks can send requests to it.
pub async fn start(
    cfg: &super::config::Config,
) -> Result<(
    mpsc::Sender<driver::Request<<Instance as Store>::Reporter>>,
    client::RequestChan,
    JoinHandle<Result<Infallible>>,
)> {
    // Create a channel that drivers can use to make requests to the
    // framework. This task will hang onto the Receiver end and each
    // driver will get a .clone() of the transmit handle.

    let (tx_drv_req, rx_drv_req) = mpsc::channel(10);
    let (tx_clnt_req, rx_clnt_req) = mpsc::channel(10);
    let be_cfg = cfg.get_backend().clone();

    Ok((
        tx_drv_req,
        client::RequestChan::new(tx_clnt_req),
        tokio::spawn(async {
            let state = State::create(be_cfg).await?;

            state
                .run(rx_drv_req, rx_clnt_req)
                .instrument(info_span!("drmem"))
                .await
        }),
    ))
}

---
FILE: drmemd/src/driver/cycle/config.rs
use drmem_api::{device, driver::DriverConfig, Error};

#[derive(serde::Deserialize)]
pub struct Params {
    pub millis: u64,
    #[serde(default = "cfg_eab_default")]
    pub enabled_at_boot: bool,
    pub disabled: device::Value,
    pub enabled: Vec<device::Value>,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

fn cfg_eab_default() -> bool {
    false
}

---
FILE: drmemd/src/driver/cycle/device.rs
use drmem_api::{
    device,
    driver::{self, Reporter, ResettableState},
    Result,
};

use super::config;

pub struct Set<R: Reporter> {
    pub d_output: driver::ReadOnlyDevice<device::Value, R>,
    pub d_enable: driver::ReadWriteDevice<bool, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.
        //
        // This first device is the output signal. It toggles between
        // `false` and `true` at a rate determined by the `interval`
        // config option.

        let d_output = core.add_ro_device("output", None, max_history).await?;

        // This device is settable. Any time it transitions from
        // `false` to `true`, the output device begins a cycling.
        // When this device is set to `false`, the device stops
        // cycling.

        let d_enable = core.add_rw_device("enable", None, max_history).await?;

        Ok(Set { d_output, d_enable })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drmemd/src/driver/cycle/driver.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter},
    Result,
};
use std::convert::Infallible;
use tokio::time::{self, Duration};
use tracing::{self, debug};

use super::{config, device};

// This enum represents the three states in which the device can be.

#[derive(Debug, PartialEq)]
enum CycleState {
    Idle,
    Cycling,
}

// The state of a driver instance.

pub struct Instance {
    enabled_at_boot: bool,
    disabled: Value,
    enabled: Vec<Value>,
    state: CycleState,
    index: usize,
    millis: Duration,
}

impl Instance {
    pub const NAME: &'static str = "cycle";

    pub const SUMMARY: &'static str =
        "Provides a cycling output that can be enabled and disabled.";

    pub const DESCRIPTION: &'static str = include_str!("drv_cycle.md");

    /// Creates a new, idle `Instance`.
    pub fn new(
        enabled_at_boot: bool,
        millis: Duration,
        disabled: Value,
        enabled: Vec<Value>,
    ) -> Instance {
        Instance {
            enabled_at_boot,
            state: CycleState::Idle,
            disabled,
            enabled,
            index: 0,
            millis,
        }
    }

    fn time_expired(&mut self) -> Option<Value> {
        match self.state {
            CycleState::Idle => None,

            CycleState::Cycling => {
                let current = &self.enabled[self.index];

                self.index = (self.index + 1) % self.enabled.len();

                if &self.enabled[self.index] != current {
                    Some(self.enabled[self.index].clone())
                } else {
                    None
                }
            }
        }
    }

    // Updates the state based on new `enable`. Returns a 2-tuple
    // where the first element is a boolean which indicates whether
    // the interval timer should be reset. The second element is the
    // value with to set the output. If `None`, the output remains
    // unchanged.

    fn update_state(&mut self, val: bool) -> (bool, Option<Value>) {
        match self.state {
            CycleState::Idle => {
                if val {
                    self.state = CycleState::Cycling;
                    self.index = 0;

                    let value = &self.enabled[self.index];

                    (
                        true,
                        // If the output is already at the desired
                        // value, don't emit it again.
                        if value != &self.disabled {
                            Some(value.clone())
                        } else {
                            None
                        },
                    )
                } else {
                    (false, None)
                }
            }

            CycleState::Cycling => (
                false,
                if val {
                    None
                } else {
                    self.state = CycleState::Idle;

                    // If the output is already at the desired value,
                    // don't emit it again.

                    if self.disabled != self.enabled[self.index] {
                        Some(self.disabled.clone())
                    } else {
                        None
                    }
                },
            ),
        }
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        Ok(Box::new(Instance::new(
            cfg.enabled_at_boot,
            Duration::from_millis(cfg.millis),
            cfg.disabled.clone(),
            cfg.enabled.clone(),
        )))
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        let mut timer = time::interval(self.millis);

        if self.enabled_at_boot {
            self.state = CycleState::Cycling;
            devices.d_enable.report_update(true).await;
            devices
                .d_output
                .report_update(self.enabled[self.index].clone())
                .await;
        } else {
            devices.d_enable.report_update(false).await;
            devices.d_output.report_update(self.disabled.clone()).await;
        }

        loop {
            debug!("state {:?} : waiting for event", &self.state);

            #[rustfmt::skip]
            tokio::select! {
                // If the driver is in a timing cycle, add the sleep
                // future to the list of futures to await.

                _ = timer.tick() => {

		    // If the timeout occurs, update the state and set
		    // the output to the inactive value.

		    if let Some(v) = self.time_expired() {
			debug!("state {:?} : timeout occurred -- output {}",
			       &self.state, v);
			devices.d_output.report_update(v).await;
		    }
                }

                // Always look for settings. We're pattern matching
                // so, if all clients close their handles, this branch
                // will forever be disabled. That should never happen
                // since one handle is saved in the device look-up
                // table. All other handles are cloned from it.

                Some((b, reply)) = devices.d_enable.next_setting() => {
                    let (reset, out) = self.update_state(b);

                    if reset {
			timer.reset()
                    }

                    reply.ok(b);

                    debug!("state {:?} : new input -> {}",
			   &self.state, b);

                    devices.d_enable.report_update(b).await;

                    if let Some(out) = out {
			devices.d_output.report_update(out.clone()).await;
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::Duration;

    #[tokio::test]
    async fn test_cfg() {
        {
            let cfg = toml::from_str::<config::Params>(
                "millis = 500
enabled_at_boot = true
disabled = false
enabled = [true, false]",
            )
            .unwrap();

            assert_eq!(cfg.enabled_at_boot, true);
            assert_eq!(cfg.millis, 500);
            assert_eq!(cfg.disabled, Value::Bool(false));
            assert_eq!(
                cfg.enabled,
                vec![Value::Bool(true), Value::Bool(false)]
            );
        }

        {
            let cfg = toml::from_str::<config::Params>(
                "millis = 500
disabled = false
enabled = [true, false]
",
            )
            .unwrap();

            assert_eq!(cfg.enabled_at_boot, false);
            assert_eq!(cfg.millis, 500);
            assert_eq!(cfg.disabled, Value::Bool(false));
            assert_eq!(
                cfg.enabled,
                vec![Value::Bool(true), Value::Bool(false)]
            );
        }

        {
            let cfg = toml::from_str::<config::Params>(
                "
disabled = false
enabled = [true, false]",
            );

            assert!(cfg.is_err());
        }

        {
            let cfg = toml::from_str::<config::Params>(
                "
millis = 500
enabled = [true, false]",
            );

            assert!(cfg.is_err());
        }

        {
            let cfg = toml::from_str::<config::Params>(
                "
millis = 500
disabled = false",
            );

            assert!(cfg.is_err());
        }

        {
            let cfg = toml::from_str::<config::Params>(
                "millis = 500
disabled = false
enabled = [true, false]",
            )
            .unwrap();

            assert_eq!(cfg.enabled_at_boot, false);
            assert_eq!(cfg.millis, 500);
            assert_eq!(cfg.disabled, Value::Bool(false));
            assert_eq!(
                cfg.enabled,
                vec![Value::Bool(true), Value::Bool(false)]
            );
        }
    }

    #[test]
    fn test_state_changes() {
        let mut timer = Instance::new(
            false,
            Duration::from_millis(1000),
            Value::Bool(false),
            vec![Value::Bool(true), Value::Bool(false)],
        );

        // Verify that, when in the Idle state, an input of `false` or
        // a timer timeout doesn't move the FSM out of the Idle state.

        assert_eq!(timer.state, CycleState::Idle);
        assert_eq!((false, None), timer.update_state(false));
        assert_eq!(None, timer.time_expired());
        assert_eq!(timer.state, CycleState::Idle);

        // Verify that a `true` input in the Idle state requires the
        // timer to be reset and the output to be reported. Verify a
        // second `true` has no effect.

        assert_eq!((true, Some(true.into())), timer.update_state(true));
        assert_eq!((false, None), timer.update_state(true));

        // Verify timeouts result in the toggling of the output.

        assert_eq!(Some(false.into()), timer.time_expired());
        assert_eq!(Some(true.into()), timer.time_expired());
        assert_eq!(Some(false.into()), timer.time_expired());
        assert_eq!(Some(true.into()), timer.time_expired());

        // Verify that, while cycling, a `false` input brings us back
        // to the Idle state.

        assert_eq!((false, Some(false.into())), timer.update_state(false));
        assert_eq!(timer.state, CycleState::Idle);
    }

    #[test]
    fn test_numeric_cycles() {
        let mut timer = Instance::new(
            false,
            Duration::from_millis(1000),
            Value::Int(0),
            vec![Value::Int(1), Value::Int(2), Value::Int(3)],
        );

        // Verify that, when in the Idle state, an input of `false` or
        // a timer timeout doesn't move the FSM out of the Idle state.

        assert_eq!(timer.state, CycleState::Idle);
        assert_eq!((false, None), timer.update_state(false));
        assert_eq!(None, timer.time_expired());
        assert_eq!(timer.state, CycleState::Idle);

        // Verify that a `true` input in the Idle state requires the
        // timer to be reset and the output to be reported. Verify a
        // second `true` has no effect.

        assert_eq!((true, Some((1).into())), timer.update_state(true));
        assert_eq!((false, None), timer.update_state(true));

        // Verify timeouts result in the cycling of the output.

        assert_eq!(Some((2).into()), timer.time_expired());
        assert_eq!(Some((3).into()), timer.time_expired());
        assert_eq!(Some((1).into()), timer.time_expired());
        assert_eq!(Some((2).into()), timer.time_expired());

        // Verify that, while cycling, a `false` input brings us back
        // to the Idle state.

        assert_eq!((false, Some((0).into())), timer.update_state(false));
        assert_eq!(timer.state, CycleState::Idle);

        // Now verify restarting the cycle emits the first value in
        // the array.

        assert_eq!((true, Some((1).into())), timer.update_state(true));
    }

    #[test]
    fn test_duplicate_skips() {
        let mut timer = Instance::new(
            false,
            Duration::from_millis(1000),
            Value::Bool(false),
            vec![Value::Bool(true), Value::Bool(false), Value::Bool(false)],
        );

        // Verify that, when in the Idle state, an input of `false` or
        // a timer timeout doesn't move the FSM out of the Idle state.

        assert_eq!(timer.state, CycleState::Idle);
        assert_eq!((false, None), timer.update_state(false));
        assert_eq!(None, timer.time_expired());
        assert_eq!(timer.state, CycleState::Idle);

        // Verify that a `true` input in the Idle state requires the
        // timer to be reset and the output to be reported. Verify a
        // second `true` has no effect.

        assert_eq!((true, Some(true.into())), timer.update_state(true));
        assert_eq!((false, None), timer.update_state(true));

        // Verify timeouts result in the toggling of the output.

        assert_eq!(Some(false.into()), timer.time_expired());
        assert_eq!(None, timer.time_expired());
        assert_eq!(Some(true.into()), timer.time_expired());
        assert_eq!(Some(false.into()), timer.time_expired());
        assert_eq!(None, timer.time_expired());
        assert_eq!(Some(true.into()), timer.time_expired());

        // Verify that, while cycling, a `false` input brings us back
        // to the Idle state.

        assert_eq!((false, Some(false.into())), timer.update_state(false));
        assert_eq!(timer.state, CycleState::Idle);
    }

    #[test]
    fn test_transition_skips() {
        let mut timer = Instance::new(
            false,
            Duration::from_millis(1000),
            Value::Bool(false),
            vec![Value::Bool(false), Value::Bool(true), Value::Bool(false)],
        );

        // Verify that, when in the Idle state, an input of `false` or
        // a timer timeout doesn't move the FSM out of the Idle state.

        assert_eq!(timer.state, CycleState::Idle);
        assert_eq!((false, None), timer.update_state(false));
        assert_eq!(None, timer.time_expired());
        assert_eq!(timer.state, CycleState::Idle);

        // Verify that a `true` input in the Idle state requires the
        // timer to be reset but the output is skipped (because it's
        // the same value.) Verify a second `true` has no effect.

        assert_eq!((true, None), timer.update_state(true));
        assert_eq!((false, None), timer.update_state(true));

        // Verify timeouts result in the toggling of the output.

        assert_eq!(Some(true.into()), timer.time_expired());
        assert_eq!(Some(false.into()), timer.time_expired());
        assert_eq!(None, timer.time_expired());
        assert_eq!(Some(true.into()), timer.time_expired());
        assert_eq!(Some(false.into()), timer.time_expired());

        // Verify that, while cycling, a `false` input brings us back
        // to the Idle state and the output is skipped because we're
        // already at `false`.

        assert_eq!((false, None), timer.update_state(false));
        assert_eq!(timer.state, CycleState::Idle);
    }
}

---
FILE: drmemd/src/driver/cycle/mod.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmemd/src/driver/latch/config.rs
use drmem_api::{device, driver::DriverConfig, Error};

#[derive(serde::Deserialize)]
pub struct Params {
    pub disabled: device::Value,
    pub enabled: device::Value,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

---
FILE: drmemd/src/driver/latch/device.rs
use drmem_api::{
    device,
    driver::{self, Reporter, ResettableState},
    Result,
};

use crate::driver::latch::config;

pub struct Set<R: Reporter> {
    pub d_output: driver::ReadOnlyDevice<device::Value, R>,
    pub d_trigger: driver::ReadWriteDevice<bool, R>,
    pub d_reset: driver::ReadWriteDevice<bool, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.
        //
        // This first device is the output of the timer.

        let d_output = core.add_ro_device("output", None, max_history).await?;

        let d_trigger =
            core.add_rw_device("trigger", None, max_history).await?;

        let d_reset = core.add_rw_device("reset", None, max_history).await?;

        Ok(Set {
            d_output,
            d_trigger,
            d_reset,
        })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drmemd/src/driver/latch/driver.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter},
    Result,
};
use std::convert::Infallible;

use super::{config, device};

// This enum represents the two states in which the latch can be.

#[derive(Debug, PartialEq)]
enum LatchState {
    Idle,
    Tripped,
}

pub struct Instance {
    state: LatchState,
    active_value: Value,
    inactive_value: Value,
}

impl<'a> Instance {
    pub const NAME: &'static str = "latch";

    pub const SUMMARY: &'static str = "Latches between two values.";

    pub const DESCRIPTION: &'static str = include_str!("drv_latch.md");

    /// Creates a new `Instance` instance.
    pub fn new(active_value: Value, inactive_value: Value) -> Instance {
        Instance {
            state: LatchState::Idle,
            active_value,
            inactive_value,
        }
    }

    // Updates the state based on new inputs. Returns an optional
    // value. If `None`, then nothing needs to be reported.

    fn update_state<'b: 'a>(
        &'b mut self,
        reset: bool,
        delta_trigger: bool,
    ) -> (Option<&'a Value>, Option<&'a Value>) {
        match self.state {
            LatchState::Idle if !delta_trigger => (None, None),
            LatchState::Idle if reset => {
                (Some(&self.active_value), Some(&self.inactive_value))
            }
            LatchState::Idle => {
                self.state = LatchState::Tripped;
                (Some(&self.active_value), None)
            }

            LatchState::Tripped if reset => {
                self.state = LatchState::Idle;
                (Some(&self.inactive_value), None)
            }

            LatchState::Tripped => (None, None),
        }
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        // Build and return the future.

        Ok(Box::new(Instance::new(
            cfg.enabled.clone(),
            cfg.disabled.clone(),
        )))
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        let mut reset = false;
        let mut trigger = false;

        // Initialize the reported state of the latch.

        devices.d_trigger.report_update(false).await;
        devices.d_reset.report_update(false).await;
        devices
            .d_output
            .report_update(self.inactive_value.clone())
            .await;

        loop {
            let device::Set {
                d_trigger, d_reset, ..
            } = &mut *devices;

            #[rustfmt::skip]
            let result = tokio::select! {
                Some((b, reply)) = d_trigger.next_setting() => {
                    let result = self.update_state(reset, !trigger && b);

                    reply.ok(b);
                    devices.d_trigger.report_update(b).await;
                    trigger = b;
                    result
                }

                Some((b, reply)) = d_reset.next_setting() => {
                    let result = self.update_state(reset, false);

                    reply.ok(b);
                    devices.d_reset.report_update(b).await;
                    reset = b;
                    result
                }
            };

            if let Some(v) = result.0 {
                devices.d_output.report_update(v.clone()).await;
                if let Some(v) = result.1 {
                    devices.d_output.report_update(v.clone()).await;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_state_changes() {
        let mut latch = Instance::new(Value::Bool(true), Value::Bool(false));

        assert_eq!(latch.state, LatchState::Idle);
        assert_eq!((None, None), latch.update_state(false, false));

        {
            let (a, b) = latch.update_state(false, true);

            assert_eq!(Some(&Value::Bool(true)), a);
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Tripped);

        {
            let (a, b) = latch.update_state(false, true);

            assert!(a.is_none());
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Tripped);

        {
            let (a, b) = latch.update_state(false, false);

            assert!(a.is_none());
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Tripped);

        {
            let (a, b) = latch.update_state(false, true);

            assert!(a.is_none());
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Tripped);

        {
            let (a, b) = latch.update_state(false, false);

            assert!(a.is_none());
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Tripped);

        {
            let (a, b) = latch.update_state(true, false);

            assert_eq!(Some(&Value::Bool(false)), a);
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Idle);

        {
            let (a, b) = latch.update_state(false, false);

            assert!(a.is_none());
            assert!(b.is_none());
        }
        assert_eq!(latch.state, LatchState::Idle);

        {
            let (a, b) = latch.update_state(true, true);

            assert_eq!(Some(&Value::Bool(true)), a);
            assert_eq!(Some(&Value::Bool(false)), b);
        }
        assert_eq!(latch.state, LatchState::Idle);
    }
}

---
FILE: drmemd/src/driver/latch/mod.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmemd/src/driver/map/config.rs
use drmem_api::{device::Value, driver::DriverConfig, Error, Result};

#[derive(PartialEq, serde::Deserialize, Debug)]
pub struct Entry {
    pub start: i32,
    pub end: Option<i32>,
    pub value: Value,
}

#[derive(serde::Deserialize)]
pub struct Params {
    pub initial: Option<i32>,
    pub default: Value,
    pub values: Vec<Entry>,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        parse(&cfg)
    }
}

// Convert the TOML Table into `InstanceConfig`.

pub fn parse(cfg: &DriverConfig) -> Result<Params> {
    let mut cfg: Params = cfg.parse_into()?;

    // Sort the entries by the value of the start index.

    cfg.values.sort_by(|a, b| a.start.cmp(&b.start));

    // Now check to see if any ranges overlap. If so, that's an
    // error.

    if cfg
        .values
        .windows(2)
        .any(|e| e[0].end.unwrap_or(e[0].start) >= e[1].start)
    {
        return Err(Error::ConfigError(
            "`values` array contains overlapping ranges".into(),
        ));
    }
    Ok(cfg)
}

---
FILE: drmemd/src/driver/map/device.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter, ResettableState},
    Result,
};

use super::config;

pub struct Set<R: Reporter> {
    pub d_output: driver::ReadOnlyDevice<Value, R>,
    pub d_index: driver::ReadWriteDevice<i32, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.
        //
        // This first device is the output of the map.

        let d_output = core.add_ro_device("output", None, max_history).await?;

        // This device is settable. Any setting is forwarded to
        // the backend.

        let d_index = core.add_rw_device("index", None, max_history).await?;

        Ok(Set { d_output, d_index })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drmemd/src/driver/map/driver.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter},
    Result,
};
use std::{convert::Infallible, ops::RangeInclusive};

use super::{config, device};

#[derive(Debug, PartialEq)]
struct Entry(RangeInclusive<i32>, Value);

pub struct Instance {
    init_index: Option<i32>,
    def_val: Value,
    values: Vec<Entry>,
}

impl Instance {
    pub const NAME: &'static str = "map";

    pub const SUMMARY: &'static str = "Maps a range of indices to a value.";

    pub const DESCRIPTION: &'static str = include_str!("drv_map.md");

    /// Creates a new `Instance` instance.
    fn new(cfg: &config::Params) -> Result<Instance> {
        Ok(Instance {
            init_index: cfg.initial,
            def_val: cfg.default.clone(),
            values: cfg.values.iter().map(Instance::to_entry).collect(),
        })
    }

    // Helper method to convert a TOML Table into an `Entry` type.

    fn to_entry(e: &config::Entry) -> Entry {
        match e {
            config::Entry {
                start,
                end: None,
                value,
            } => Entry(*start..=*start, value.clone()),
            config::Entry {
                start,
                end: Some(end),
                value,
            } => Entry(*start.min(end)..=*start.max(end), value.clone()),
        }
    }

    // Find the entry that contains the index. Return the associated
    // value. If no entry matches, return the error value.

    fn map_to(&self, idx: i32) -> Value {
        use std::cmp::Ordering;

        self.values
            .binary_search_by(|e| {
                if idx < *e.0.start() {
                    Ordering::Less
                } else if idx > *e.0.end() {
                    Ordering::Greater
                } else {
                    Ordering::Equal
                }
            })
            .map(|v| self.values[v].1.clone())
            .unwrap_or_else(|_| self.def_val.clone())
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        Instance::new(cfg).map(Box::new)
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        // If we have an initial value, use it.

        if let Some(idx) = self.init_index {
            // Send the updated values to the backend.

            devices.d_output.report_update(self.map_to(idx)).await;
            devices.d_index.report_update(idx).await
        } else {
            devices.d_output.report_update(self.def_val.clone()).await;
        }

        // The driver blocks, waiting for a new index. As long as our
        // setting channel is healthy, we handle each setting.

        while let Some((v, reply)) = devices.d_index.next_setting().await {
            // Send the reply to the setter.

            reply.ok(v);

            // Send the updated values to the backend.

            devices.d_output.report_update(self.map_to(v)).await;
            devices.d_index.report_update(v).await
        }
        panic!("can no longer receive settings");
    }
}

#[cfg(test)]
mod tests {
    use super::config;
    use drmem_api::{device, driver::DriverConfig, Error, Result};

    // Tries to build an `InstanceConfig` from a `&str`.

    fn make_cfg(text: &str) -> Result<config::Params> {
        config::parse(&Into::<DriverConfig>::into(
            toml::from_str::<toml::value::Table>(text)
                .map_err(|e| Error::ConfigError(format!("{}", e)))?,
        ))
    }

    #[test]
    fn test_cfg_initial() {
        {
            let cfg = make_cfg(
                "default = false
values = []
",
            )
            .unwrap();

            assert_eq!(cfg.initial, None);
        }
        {
            let cfg = make_cfg(
                "initial = \"hello\"
default = false
values = []
",
            );

            assert!(cfg.is_err());
        }
        {
            let cfg = make_cfg(
                "initial = 100
default = false
values = []
",
            )
            .unwrap();

            assert_eq!(cfg.initial, Some(100));
        }
    }

    #[test]
    fn test_cfg_default() {
        let cfg = make_cfg(
            "initial = 100
default = \"hello\"
values = []
",
        )
        .unwrap();

        assert_eq!(cfg.default, device::Value::Str("hello".into()));
    }

    #[test]
    fn test_bad_cfg_values() {
        // Missing the 'values' array.

        {
            let cfg = make_cfg("default = 100");

            assert!(cfg.is_err());
        }

        // Missing the 'start' field.

        {
            let cfg = make_cfg(
                "default = 100
values = [{ value = false }]",
            );

            assert!(cfg.is_err());
        }

        // Missing a 'value' field.

        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 0 }]",
            );

            assert!(cfg.is_err());
        }

        // The first and third entry's ranges overlap.

        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 2, end = 7, value = \"there\" },
          { start = 8, end = 11, value = \"world\" },
          { start = 0, end = 3, value = \"hello\" }]",
            );

            assert!(cfg.is_err());
        }

        // The second and third entry's ranges share an endpoint
        // (i.e. overlap.).

        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 8, end = 11, value = \"there\" },
          { start = 3, end = 7, value = \"world\" },
          { start = 0, end = 3, value = \"hello\" }]",
            );

            assert!(cfg.is_err());
        }
    }

    #[test]
    fn test_good_cfg_values() {
        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 0, value = false }]",
            )
            .unwrap();

            assert_eq!(
                cfg.values,
                vec![config::Entry {
                    start: 0,
                    end: None,
                    value: device::Value::Bool(false)
                }]
            );
        }

        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 0, end = 1, value = \"hello\" }]",
            )
            .unwrap();

            assert_eq!(
                cfg.values,
                vec![config::Entry {
                    start: 0,
                    end: Some(1),
                    value: device::Value::Str("hello".into())
                }],
            );
        }

        {
            let cfg = make_cfg(
                "default = 100
values = [{ start = 4, end = 7, value = \"there\" },
          { start = 8, end = 11, value = \"world\" },
          { start = 0, end = 3, value = \"hello\" }]",
            )
            .unwrap();

            assert_eq!(
                cfg.values,
                vec![
                    config::Entry {
                        start: 0,
                        end: Some(3),
                        value: device::Value::Str("hello".into())
                    },
                    config::Entry {
                        start: 4,
                        end: Some(7),
                        value: device::Value::Str("there".into())
                    },
                    config::Entry {
                        start: 8,
                        end: Some(11),
                        value: device::Value::Str("world".into())
                    }
                ]
            );
        }
    }
}

---
FILE: drmemd/src/driver/map/mod.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmemd/src/driver/memory/config.rs
use drmem_api::{device, driver::DriverConfig, Error};

#[derive(serde::Deserialize, Debug, PartialEq)]
pub struct Entry {
    pub name: device::Base,
    pub initial: device::Value,
}

#[derive(serde::Deserialize, Debug, PartialEq)]
pub struct Params {
    pub vars: Vec<Entry>,
}

impl TryFrom<DriverConfig> for Params {
    type Error = Error;

    fn try_from(cfg: DriverConfig) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

#[cfg(test)]
mod test {
    use super::super::config;
    use drmem_api::{driver::DriverConfig, Error, Result};

    fn mk_cfg(text: &str) -> Result<config::Params> {
        Into::<DriverConfig>::into(
            toml::from_str::<toml::value::Table>(text)
                .map_err(|e| Error::ConfigError(format!("{}", e)))?,
        )
        .parse_into()
    }

    #[test]
    fn test_configuration() {
        use super::device;
        use toml::{Table, Value};

        // Test for an empty Map or a Map that doesn't have the "vars"
        // key or a map with "vars" whose value isn't a map or is a
        // map but is empty or has a value, but it's not an array. All
        // of these are errors.

        {
            assert!(mk_cfg("vars = [{initial = true}]").is_err());
            assert!(mk_cfg("vars = [{name = \"var\"}]").is_err());
            assert!(mk_cfg("vars = [{junk = \"var\"}]").is_err());
            assert!(mk_cfg("vars = [{name = \"var\", initial = true}]").is_ok());

            assert_eq!(
                mk_cfg(
                    "
vars = [{name = \"v1\", initial = true},
        {name = \"v2\", initial = 100}]"
                ),
                Ok(config::Params {
                    vars: vec![
                        config::Entry {
                            name: "v1".try_into().unwrap(),
                            initial: device::Value::Bool(true)
                        },
                        config::Entry {
                            name: "v2".try_into().unwrap(),
                            initial: device::Value::Int(100)
                        }
                    ]
                })
            );
        }

        // Now make sure the config code creates a single memory
        // device correctly. We'll deal with sets later.

        {
            let mut test_set: Vec<(&'static str, Value, device::Value)> = vec![
                ("flag", Value::Boolean(true), device::Value::Bool(true)),
                ("int-val", Value::Integer(100), device::Value::Int(100)),
                ("flt-val", Value::Float(50.0), device::Value::Flt(50.0)),
                (
                    "str-val",
                    Value::String("Hello".into()),
                    device::Value::Str("Hello".into()),
                ),
                (
                    "clr-val",
                    Value::String("#ffffff".into()),
                    device::Value::Color(palette::LinSrgba::new(
                        255, 255, 255, 255,
                    )),
                ),
            ];

            for entry in test_set.drain(..) {
                let mut tbl = Table::new();
                let _ = tbl.insert("name".into(), entry.0.try_into().unwrap());
                let _ = tbl.insert("initial".into(), entry.1.clone());
                let mut map = Table::new();

                map.insert(
                    "vars".into(),
                    Value::Array(vec![Value::Table(tbl)]),
                );

                let result: config::Params =
                    Into::<DriverConfig>::into(map).parse_into().unwrap();

                assert!(result.vars.len() == 1);
                assert_eq!(result.vars[0].name.to_string(), entry.0);
                assert_eq!(result.vars[0].initial, entry.2);
            }
        }
    }
}

---
FILE: drmemd/src/driver/memory/device.rs
use super::config;
use drmem_api::{
    device::Value,
    driver::{self, Reporter, ResettableState},
    Error, Result,
};
use std::future::Future;

// Defines the signature if a function that validates a
// `device::Value`'s type.

pub type TypeChecker = fn(&Value) -> bool;

// Returns a function that returns `true` when passed a value of the
// same type as `val`.

fn get_validator(val: &Value) -> TypeChecker {
    match val {
        Value::Bool(_) => |v| matches!(v, Value::Bool(_)),
        Value::Int(_) => |v| matches!(v, Value::Int(_)),
        Value::Flt(_) => |v| matches!(v, Value::Flt(_)),
        Value::Str(_) => |v| matches!(v, Value::Str(_)),
        Value::Color(_) => |v| matches!(v, Value::Color(_)),
    }
}

// Holds the set of memory devices used by an instance of the memory
// driver. Each entry has the device handle and a cooresponding
// function which is used to make sure incoming settings are of the
// correct type.

pub struct Set<R: Reporter> {
    pub set: Vec<(driver::ReadWriteDevice<Value, R>, TypeChecker)>,
}

impl<R: Reporter> Set<R> {
    pub fn get_next(
        &mut self,
    ) -> impl Future<Output = (usize, Value)> + use<'_, R> {
        use std::future::poll_fn;

        poll_fn(move |ctxt| {
            use std::task::Poll;

            // Loop through all the devices. Get the index, the device
            // channel, and the function to verify any incoming
            // setting on that channel.

            for (idx, (dev, is_good)) in self.set.iter_mut().enumerate() {
                // Now that we have a device to look at, we enter a
                // loop. The loop is necessary because we need to
                // leave the stream in a state primed to wake us up
                // which only happens when it returns Poll::Pending.

                loop {
                    // Get a future that gets the next value from the
                    // stream. We "pin" it, since that's a requirement
                    // of futures.

                    let mut fut = std::pin::pin!(dev.next_setting());

                    // See if there's a value to read.

                    match fut.as_mut().poll(ctxt) {
                        // Got a value. Process it.
                        Poll::Ready(Some((val, reply))) => {
                            // Is the setting value of the correct
                            // type? If so, echo it back to the client
                            // (wrapped in Ok().) Return the idx of
                            // the device and the value so it can be
                            // processed by the caller.

                            if is_good(&val) {
                                reply.ok(val.clone());
                                return Poll::Ready((idx, val));
                            } else {
                                reply.err(Error::TypeError)
                            }
                        }

                        // Stream is empty. Break out the loop to
                        // check the next device.
                        Poll::Ready(None) | Poll::Pending => break,
                    }
                }
            }

            // If we exit the for-loop, then all streams were pending
            // (which also means they've all registered their wakers
            // so we'll poll again when a setting arrives.)

            Poll::Pending
        })
    }
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        let mut devs = vec![];

        for e in cfg.vars.iter() {
            // This device is settable. Any setting is forwarded to
            // the backend.

            let mut entry: (driver::ReadWriteDevice<Value, R>, TypeChecker) = (
                core.add_rw_device(e.name.clone(), None, max_history)
                    .await?,
                get_validator(&e.initial),
            );

            // If the user configured an initial value and there was
            // no previous value or the previous value was of a
            // different type, immediately set it with the initial
            // value.

            if entry
                .0
                .get_last()
                .map(|v| !v.is_same_type(&e.initial))
                .unwrap_or(true)
            {
                entry.0.report_update(e.initial.clone()).await
            }

            // Add the entry to the driver's set of devices.

            devs.push(entry)
        }

        Ok(Set { set: devs })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

#[cfg(test)]
mod test {
    use drmem_api::device::Value;

    #[test]
    fn test_validators() {
        use super::get_validator;

        {
            let f = get_validator(&Value::Bool(true));

            assert!(f(&Value::Bool(false)));
            assert!(!f(&Value::Int(10)));
            assert!(!f(&Value::Flt(20.0)));
            assert!(!f(&Value::Str("Hello".into())));
            assert!(!f(&Value::Color(palette::LinSrgba::new(0, 0, 0, 0))));
        }
        {
            let f = get_validator(&Value::Int(5));

            assert!(!f(&Value::Bool(false)));
            assert!(f(&Value::Int(10)));
            assert!(!f(&Value::Flt(20.0)));
            assert!(!f(&Value::Str("Hello".into())));
            assert!(!f(&Value::Color(palette::LinSrgba::new(0, 0, 0, 0))));
        }
        {
            let f = get_validator(&Value::Flt(2.0));

            assert!(!f(&Value::Bool(false)));
            assert!(!f(&Value::Int(10)));
            assert!(f(&Value::Flt(20.0)));
            assert!(!f(&Value::Str("Hello".into())));
            assert!(!f(&Value::Color(palette::LinSrgba::new(0, 0, 0, 0))));
        }
        {
            let f = get_validator(&Value::Str("World".into()));

            assert!(!f(&Value::Bool(false)));
            assert!(!f(&Value::Int(10)));
            assert!(!f(&Value::Flt(20.0)));
            assert!(f(&Value::Str("Hello".into())));
            assert!(!f(&Value::Color(palette::LinSrgba::new(0, 0, 0, 0))));
        }
        {
            let f = get_validator(&Value::Color(palette::LinSrgba::new(
                100, 100, 100, 100,
            )));

            assert!(!f(&Value::Bool(false)));
            assert!(!f(&Value::Int(10)));
            assert!(!f(&Value::Flt(20.0)));
            assert!(!f(&Value::Str("Hello".into())));
            assert!(f(&Value::Color(palette::LinSrgba::new(0, 0, 0, 0))));
        }
    }
}

---
FILE: drmemd/src/driver/memory/driver.rs
use super::{config, device};
use drmem_api::{
    driver::{self, Reporter},
    Result,
};
use std::convert::Infallible;

pub struct Instance;

impl Instance {
    pub const NAME: &'static str = "memory";

    pub const SUMMARY: &'static str = "An area in memory to set values.";

    pub const DESCRIPTION: &'static str = include_str!("drv_memory.md");

    /// Creates a new `Instance` instance.
    pub fn new() -> Instance {
        Instance {}
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(_cfg: &Self::Config) -> Result<Box<Self>> {
        Ok(Box::new(Instance::new()))
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        loop {
            let (idx, val) = devices.get_next().await;

            devices.set[idx].0.report_update(val).await
        }
    }
}

#[cfg(test)]
mod tests {
    use super::device::TypeChecker;
    use drmem_api::{
        device,
        driver::{ReadWriteDevice, Reporter, TxDeviceSetting},
    };
    use tokio::sync::mpsc;

    struct Report(mpsc::Sender<device::Value>);

    impl Report {
        fn new(tx: mpsc::Sender<device::Value>) -> Report {
            Report(tx)
        }
    }

    impl Reporter for Report {
        async fn report_value(&mut self, value: device::Value) {
            self.0.try_send(value).expect("couldn't report value")
        }
    }

    // Builds a type that acts like a settable device.

    fn build_device() -> (
        TxDeviceSetting,
        mpsc::Receiver<device::Value>,
        (ReadWriteDevice<device::Value, Report>, TypeChecker),
    ) {
        let (tx_sets, rx_sets) = mpsc::channel(20);
        let (tx_reports, rx_reports) = mpsc::channel(20);

        (
            tx_sets,
            rx_reports,
            (
                ReadWriteDevice::<device::Value, Report>::new(
                    Report::new(tx_reports),
                    rx_sets,
                    None,
                ),
                |_| true,
            ),
        )
    }

    #[test]
    fn test_custom_future() {
        use super::device::Set;
        use futures::Future;
        use noop_waker::noop_waker;
        use std::task::{Context, Poll};
        use tokio::sync::oneshot;

        // If there's no memory devices, then the future should pend
        // forever.

        {
            let mut dev = Set::<Report> { set: vec![] };
            let fut = std::pin::pin!(dev.get_next());
            let waker = noop_waker();
            let mut context = Context::from_waker(&waker);

            assert_eq!(fut.poll(&mut context), Poll::Pending);
        }

        // Now add a single memory device.

        {
            let (setting, _, device) = build_device();
            let mut dev = Set { set: vec![device] };
            let waker = noop_waker();
            let mut context = Context::from_waker(&waker);

            // Before we push any values, the Future should pend.

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Now we send a `true` value. It should echo it back and
            // a future request will pend.

            let (tx_reply, _) = oneshot::channel();

            setting
                .try_send((device::Value::Bool(true), tx_reply))
                .unwrap();

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(true)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Now send two values and make sure they're both
            // returned.

            {
                let (tx_reply, _) = oneshot::channel();

                setting
                    .try_send((device::Value::Bool(true), tx_reply))
                    .unwrap();
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting
                    .try_send((device::Value::Flt(1.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(true)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Flt(1.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Send two values, but send the second after we've read
            // the first.

            {
                let (tx_reply, _) = oneshot::channel();

                setting
                    .try_send((device::Value::Bool(true), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(true)))
                );
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting
                    .try_send((device::Value::Flt(1.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Flt(1.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }
        }

        // This section tests when we have two memory devices. We are
        // going to assume it scales to more than two.

        {
            let (setting_a, _, device_a) = build_device();
            let (setting_b, _, device_b) = build_device();
            let mut dev = Set {
                set: vec![device_a, device_b],
            };
            let waker = noop_waker();
            let mut context = Context::from_waker(&waker);

            // Nothing inserted, should Pend.

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Set first device. Should return it, then pend.

            {
                let (tx_reply, _) = oneshot::channel();

                setting_a
                    .try_send((device::Value::Flt(1.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Flt(1.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Set second device. Should return it, then pend.

            {
                let (tx_reply, _) = oneshot::channel();

                setting_b
                    .try_send((device::Value::Flt(2.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((1, device::Value::Flt(2.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Set each device. Should read first, first, and second,
            // second.

            {
                let (tx_reply, _) = oneshot::channel();

                setting_a
                    .try_send((device::Value::Bool(true), tx_reply))
                    .unwrap();
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting_b
                    .try_send((device::Value::Flt(1.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(true)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((1, device::Value::Flt(1.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }

            // Set each device twice. Interleave the settings and make
            // sure they come out in the correct order.

            {
                let (tx_reply, _) = oneshot::channel();

                setting_b
                    .try_send((device::Value::Flt(1.0), tx_reply))
                    .unwrap();
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting_a
                    .try_send((device::Value::Bool(true), tx_reply))
                    .unwrap();
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting_b
                    .try_send((device::Value::Flt(5.0), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(true)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((1, device::Value::Flt(1.0)))
                );
            }

            {
                let (tx_reply, _) = oneshot::channel();

                setting_a
                    .try_send((device::Value::Bool(false), tx_reply))
                    .unwrap();
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((0, device::Value::Bool(false)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(
                    fut.poll(&mut context),
                    Poll::Ready((1, device::Value::Flt(5.0)))
                );
            }

            {
                let fut = std::pin::pin!(dev.get_next());

                assert_eq!(fut.poll(&mut context), Poll::Pending);
            }
        }
    }
}

---
FILE: drmemd/src/driver/memory/mod.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmemd/src/driver/mod.rs
use drmem_api::{
    driver::{self, Registrator, Reporter, ResettableState, API},
    Result,
};
use futures::future::Future;
use std::collections::HashMap;
use std::{convert::Infallible, pin::Pin, sync::Arc};
use tokio::sync::Barrier;
use tracing::{error, field, info, info_span, warn, Instrument};

mod cycle;
mod latch;
mod map;
mod memory;
mod timer;

pub type Fut<T> = Pin<Box<dyn Future<Output = T> + Send>>;
pub type MgrTask = Fut<Result<Infallible>>;

pub type Launcher<R> = fn(
    driver::DriverConfig,
    driver::RequestChan<R>,
    Option<usize>,
    barrier: Arc<Barrier>,
) -> MgrTask;

type DriverInfo<R> = (&'static str, &'static str, Launcher<R>);

// This is the main loop of the driver manager. It only returns if the
// driver panics.

async fn mgr_body<T, R>(
    mut devices: T::HardwareType,
    cfg: T::Config,
) -> Infallible
where
    T: API<R> + Send + 'static,
    <T::Config as TryFrom<driver::DriverConfig>>::Error: std::fmt::Display,
    R: Reporter,
{
    const START_DELAY: u64 = 5;
    const MAX_DELAY: u64 = 600;

    let mut restart_delay = START_DELAY;

    loop {
        info!("initializing");

        // Create a Future that creates an instance of the driver
        // using the provided configuration parameters.

        match T::create_instance(&cfg).await {
            Ok(mut instance) => {
                use futures::FutureExt;
                use std::panic::AssertUnwindSafe;

                restart_delay = START_DELAY;
                info!("running");

                let run = instance.run(&mut devices);

                // Drivers are never supposed to exit so
                // catch_unwind() will only catch panics which means
                // we need to only look for `Err(_)` values.

                let Err(e) = AssertUnwindSafe(run).catch_unwind().await;

                error!("exited unexpectedly -- {e:?}")
            }
            Err(e) => error!("couldn't create instance -- {e}"),
        }

        // Delay before restarting the driver. This prevents the
        // system from being compute-bound if the driver panics right
        // away.

        warn!("delay before restarting driver ...");
        tokio::time::sleep(tokio::time::Duration::from_secs(restart_delay))
            .await;

        // Stretch the timeout each time we have to restart. Set the
        // max timeout to 10 minutes.

        restart_delay = std::cmp::min(restart_delay * 2, MAX_DELAY);
        info!("restarting instance of driver");

        devices.reset_state();
    }
}

// This generic function manages an instance of a specific driver. We
// use generics because each driver has a different set of devices
// (T::HardwareType), so one function wouldn't be able to handle every
// type.

fn manage_instance<T, R>(
    cfg: driver::DriverConfig,
    mut req_chan: driver::RequestChan<R>,
    max_history: Option<usize>,
    barrier: Arc<Barrier>,
) -> MgrTask
where
    T: API<R> + Send + 'static,
    <T::Config as TryFrom<driver::DriverConfig>>::Error:
        std::fmt::Display + Send,
    drmem_api::Error: From<<<T as API<R>>::Config as TryFrom<driver::DriverConfig>>::Error>
        + Send,
    R: Reporter,
{
    Box::pin(async move {
        let cfg = match T::Config::try_from(cfg) {
            Ok(cfg) => Ok(cfg),
            err @ Err(_) => {
                barrier.wait().await;
                err
            }
        }?;

        // Let the driver API register the necessary devices.

        let devices =
            T::HardwareType::register_devices(&mut req_chan, &cfg, max_history)
                .instrument(info_span!("register", cfg = field::Empty))
                .await;

        // When we reached this location, all devices have been
        // registered (or not, if an error occurred). Sync to the
        // barrier so the main loop and move on to the next driver.

        barrier.wait().await;

        // Create a future that manages the instance.

        Ok(mgr_body::<T, R>(devices?, cfg).await)
    })
}

#[derive(Clone)]
pub struct DriverDb<R: Reporter>(Arc<HashMap<driver::Name, DriverInfo<R>>>);

impl<R: Reporter> DriverDb<R> {
    pub fn create() -> DriverDb<R> {
        let mut table: HashMap<driver::Name, DriverInfo<R>> = HashMap::new();

        {
            use memory::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        {
            use latch::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        {
            use map::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        {
            use timer::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        {
            use cycle::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        // Load the set-up for the NTP monitor.

        #[cfg(feature = "drmem-drv-ntp")]
        {
            use drmem_drv_ntp::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        // Load the set-up for the GPIO sump pump monitor.

        #[cfg(feature = "drmem-drv-sump")]
        {
            use drmem_drv_sump::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        // Load the set-up for the Weather Underground driver.

        #[cfg(feature = "drmem-drv-weather-wu")]
        {
            use drmem_drv_weather_wu::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        // Load the set-up for the TP-Link driver.

        #[cfg(feature = "drmem-drv-tplink")]
        {
            use drmem_drv_tplink::Instance;

            table.insert(
                Instance::NAME.into(),
                (
                    Instance::SUMMARY,
                    Instance::DESCRIPTION,
                    manage_instance::<Instance, R>,
                ),
            );
        }

        DriverDb(Arc::new(table))
    }

    /// Searches the map for a driver with the specified name. If
    /// present, the driver's information is returned.
    pub fn get_driver(&self, key: &str) -> Option<&DriverInfo<R>> {
        self.0.get(key)
    }

    /// Searches the map for a driver with the specified name. If
    /// found, it extracts the information needed for the GraphQL
    /// query and returns it.
    #[cfg(feature = "graphql")]
    pub fn find(
        &self,
        key: &str,
    ) -> Option<(driver::Name, &'static str, &'static str)> {
        self.get_driver(key)
            .map(|info| (key.into(), info.0, info.1))
    }

    /// Similar to `.find()`, but returns all the drivers'
    /// information.
    #[cfg(feature = "graphql")]
    pub fn get_all(
        &self,
    ) -> impl Iterator<Item = (driver::Name, &'static str, &'static str)> + '_
    {
        self.0.iter().map(|(k, (summary, description, _))| {
            (k.clone(), *summary, *description)
        })
    }
}

---
FILE: drmemd/src/driver/timer/config.rs
use drmem_api::{device, driver, Error};

#[derive(serde::Deserialize)]
pub struct Params {
    pub millis: u64,
    pub disabled: device::Value,
    pub enabled: device::Value,
}

impl TryFrom<driver::DriverConfig> for Params {
    type Error = Error;

    fn try_from(
        cfg: driver::DriverConfig,
    ) -> std::result::Result<Self, Self::Error> {
        cfg.parse_into()
    }
}

---
FILE: drmemd/src/driver/timer/device.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter, ResettableState},
    Result,
};

use super::{config, device};

pub struct Set<R: Reporter> {
    pub d_output: driver::ReadOnlyDevice<device::Value, R>,
    pub d_enable: driver::ReadWriteDevice<bool, R>,
}

impl<R: Reporter> driver::Registrator<R> for Set<R> {
    type Config = config::Params;

    async fn register_devices(
        core: &mut driver::RequestChan<R>,
        _cfg: &Self::Config,
        max_history: Option<usize>,
    ) -> Result<Self> {
        // Define the devices managed by this driver.
        //
        // This first device is the output of the timer. When it's not
        // timing, this device's value with be `!level`. While it's
        // timing, `level`.

        let d_output = core.add_ro_device("output", None, max_history).await?;

        // This device is settable. Any time it transitions from
        // `false` to `true`, the timer begins a timing cycle.

        let d_enable = core.add_rw_device("enable", None, max_history).await?;

        Ok(Set { d_output, d_enable })
    }
}

impl<R: Reporter> ResettableState for Set<R> {}

---
FILE: drmemd/src/driver/timer/driver.rs
use drmem_api::{
    device::Value,
    driver::{self, Reporter},
    Result,
};
use std::convert::Infallible;
use tokio::time::{self, Duration};
use tracing::{debug, info};

use super::{config, device};

// This enum represents the four states in which the timer can
// be. They are a combination of the `enable` input and whether we're
// timing or not.

#[derive(Debug, PartialEq)]
enum TimerState {
    Armed,          // Not timing, input is false
    Timing,         // Timing, input is true
    TimingAndArmed, // Timing, input is false
    TimedOut,       // Not timing, input is true
}

pub struct Instance {
    state: TimerState,
    active_value: Value,
    inactive_value: Value,
    millis: Duration,
}

impl Instance {
    pub const NAME: &'static str = "timer";

    pub const SUMMARY: &'static str =
        "Activates an output for a length of time.";

    pub const DESCRIPTION: &'static str = include_str!("drv_timer.md");

    /// Creates a new `Instance` instance. It is assumed the external
    /// input is `false` so the initial timer state is `Armed`.
    pub fn new(
        active_value: Value,
        inactive_value: Value,
        millis: Duration,
    ) -> Instance {
        Instance {
            state: TimerState::Armed,
            active_value,
            inactive_value,
            millis,
        }
    }

    // Returns `true` if we're in a timing state.

    fn timing(&self) -> bool {
        self.state == TimerState::Timing
            || self.state == TimerState::TimingAndArmed
    }

    // Updates the state to a new one reflecting that we're no longer
    // timing.

    fn time_expired(&mut self) {
        if self.state == TimerState::Timing {
            self.state = TimerState::TimedOut;
        } else if self.state == TimerState::TimingAndArmed {
            self.state = TimerState::Armed;
        }
    }

    // Updates the state based on new `enable`. Returns an optional
    // instant of time with which the caller should use to start a new
    // timer.

    fn update_state(
        &mut self,
        val: bool,
    ) -> (Option<Value>, Option<time::Instant>) {
        match self.state {
            // Currently timing and the input was set to `false`.
            TimerState::TimingAndArmed => {
                // If the input is `true`, enter the Timing state and
                // return a new timeout value. A user has reset the
                // timer while is was in a previous timing cycle.

                (
                    None,
                    if val {
                        self.state = TimerState::Timing;
                        Some(time::Instant::now() + self.millis)
                    } else {
                        None
                    },
                )
            }

            // Not currently timing, but the input was `false`.
            TimerState::Armed => {
                // If the input is `true`, enter the Timing state, and
                // return a timeout value.

                if val {
                    self.state = TimerState::Timing;
                    (
                        Some(self.active_value.clone()),
                        Some(time::Instant::now() + self.millis),
                    )
                } else {
                    (None, None)
                }
            }

            // Currently timing and input is `true`.
            TimerState::Timing => {
                // If the input is `false`, continue with the current
                // timing cycle but enter `TimingAndArmed` because a
                // `true` can restart the timer.

                if !val {
                    self.state = TimerState::TimingAndArmed;
                }

                (None, None)
            }

            // Not timing, input is `true`.
            TimerState::TimedOut => {
                // If the input goes to `false`, the state is `Armed`.

                if !val {
                    self.state = TimerState::Armed;
                }

                (None, None)
            }
        }
    }
}

impl<R: Reporter> driver::API<R> for Instance {
    type Config = config::Params;
    type HardwareType = device::Set<R>;

    async fn create_instance(cfg: &Self::Config) -> Result<Box<Self>> {
        Ok(Box::new(Instance::new(
            cfg.enabled.clone(),
            cfg.disabled.clone(),
            Duration::from_millis(cfg.millis),
        )))
    }

    async fn run(&mut self, devices: &mut Self::HardwareType) -> Infallible {
        let mut timeout = time::Instant::now();

        // Initialize the reported state of the timer.

        devices.d_enable.report_update(false).await;
        devices
            .d_output
            .report_update(self.inactive_value.clone())
            .await;

        loop {
            info!("state {:?} : waiting for event", &self.state);

            #[rustfmt::skip]
            tokio::select! {
                // If the driver is in a timing cycle, add the sleep
                // future to the list of futures to await.

                _ = time::sleep_until(timeout), if self.timing() => {
		    debug!("state {:?} : timeout occurred", &self.state);

		    // If the timeout occurs, update the state and set
		    // the output to the inactive value.

		    self.time_expired();
		    devices
                        .d_output
                        .report_update(self.inactive_value.clone())
                        .await;
                }

                // Always look for settings. We're pattern matching
                // so, if all clients close their handles, this branch
                // will forever be disabled. That should never happen
                // since one handle is saved in the device look-up
                // table. All other handles are cloned from it.

                Some((b, reply)) = devices.d_enable.next_setting() => {
                    let (out, tmo) = self.update_state(b);

                    reply.ok(b);

                    debug!("state {:?} : new input -> {}", &self.state, b);

                    if let Some(tmo) = tmo {
			timeout = tmo
                    }

                    devices.d_enable.report_update(b).await;

                    if let Some(out) = out {
			devices.d_output.report_update(out).await;
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_state_changes() {
        let mut timer = Instance::new(
            Value::Bool(true),
            Value::Bool(false),
            Duration::from_millis(1000),
        );

        assert_eq!(timer.state, TimerState::Armed);
        assert_eq!((None, None), timer.update_state(false));

        let (a, b) = timer.update_state(true);

        assert_eq!(timer.state, TimerState::Timing);
        assert_eq!(Some(Value::Bool(true)), a);
        assert!(b.is_some());

        assert_eq!((None, None), timer.update_state(true));
        assert_eq!(timer.state, TimerState::Timing);

        assert_eq!((None, None), timer.update_state(false));
        assert_eq!(timer.state, TimerState::TimingAndArmed);

        assert_eq!((None, None), timer.update_state(false));
        assert_eq!(timer.state, TimerState::TimingAndArmed);

        let (a, b) = timer.update_state(true);

        assert_eq!(timer.state, TimerState::Timing);
        assert!(a.is_none());
        assert!(b.is_some());

        timer.time_expired();
        assert_eq!(timer.state, TimerState::TimedOut);

        assert_eq!((None, None), timer.update_state(true));
        assert_eq!(timer.state, TimerState::TimedOut);

        assert_eq!((None, None), timer.update_state(false));
        assert_eq!(timer.state, TimerState::Armed);

        let (a, b) = timer.update_state(true);

        assert_eq!(timer.state, TimerState::Timing);
        assert_eq!(Some(Value::Bool(true)), a);
        assert!(b.is_some());

        assert_eq!((None, None), timer.update_state(false));
        assert_eq!(timer.state, TimerState::TimingAndArmed);

        timer.time_expired();
        assert_eq!(timer.state, TimerState::Armed);
    }
}

---
FILE: drmemd/src/driver/timer/mod.rs
mod config;
mod device;
mod driver;

pub use driver::Instance;

---
FILE: drmemd/src/graphql/config.rs
use serde::Deserialize;
use std::{
    net::{Ipv4Addr, SocketAddr},
    path::Path,
    sync::Arc,
};

fn def_name() -> String {
    "unknown name".into()
}

fn def_location() -> Arc<str> {
    "unknown location".into()
}

fn def_address() -> SocketAddr {
    (Ipv4Addr::new(0, 0, 0, 0), 3000).into()
}

fn def_pref_port() -> u16 {
    3000
}

#[derive(Deserialize)]
pub struct Security {
    pub clients: Arc<[String]>,
    pub cert_file: Arc<Path>,
    pub key_file: Arc<Path>,
}

#[derive(Deserialize)]
pub struct Config {
    #[serde(default = "def_name")]
    pub name: String,
    #[serde(default = "def_location")]
    pub location: Arc<str>,
    #[serde(default = "def_address")]
    pub addr: SocketAddr,
    pub pref_host: Option<Arc<str>>,
    #[serde(default = "def_pref_port")]
    pub pref_port: u16,
    pub security: Option<Security>,
}

impl Default for Config {
    fn default() -> Self {
        Config {
            name: def_name(),
            location: def_location(),
            addr: def_address(),
            pref_host: None,
            pref_port: def_pref_port(),
            security: None,
        }
    }
}

---
FILE: drmemd/src/graphql/mod.rs
use crate::config::Logic;
use chrono::prelude::*;
use drmem_api::{
    client, device,
    driver::{self, Reporter},
    Error,
};
use futures::Future;
use juniper::{
    executor::FieldError, graphql_object, graphql_subscription, graphql_value,
    FieldResult, GraphQLInputObject, GraphQLObject, RootNode, Value,
};
use juniper_graphql_ws::ConnectionConfig;
use juniper_warp::subscriptions::serve_graphql_ws;
use libmdns::Responder;
use std::{pin::Pin, result, sync::Arc, time::Duration};
use tracing::{debug, error, info, info_span, warn, Instrument};
use warp::{http::StatusCode, reject, reply, Filter, Rejection, Reply};

pub mod config;

#[derive(Debug)]
struct NoAuthorization;

impl reject::Reject for NoAuthorization {}

// The Context parameter for Queries.

#[derive(Clone)]
struct ConfigDb<R: Reporter>(
    crate::driver::DriverDb<R>,
    client::RequestChan,
    Vec<Arc<LogicBlock<R>>>,
);

impl<R: Reporter> juniper::Context for ConfigDb<R> {}

// `DriverInfo` is an object that can be returned by a GraphQL
// query. It contains information related to drivers that are
// available in the DrMem environment (executable.)

struct DriverInfo<R: Reporter> {
    name: driver::Name,
    summary: &'static str,
    description: &'static str,
    phant: std::marker::PhantomData<R>,
}

#[graphql_object(
    Context = ConfigDb<R>,
    description = "Information about a driver in the running version \
		   of `drmemd`.\n\n\
		   An instance of DrMem has a set of drivers that are \
		   compiled into the executable. This set will be fixed \
		   until the next time the node is restarted (because the \
		   restart may be a new executable with a different set \
		   of drivers.)"
)]
impl<R: Reporter> DriverInfo<R> {
    #[graphql(description = "The name of the driver.")]
    fn name(&self) -> driver::Name {
        self.name.clone()
    }

    #[graphql(description = "A short summary of the driver's purpose.")]
    fn summary(&self) -> &str {
        self.summary
    }

    #[graphql(description = "Detailed information about the driver: the \
                             configuration parameters; the devices it \
                             registers; and other pertinent information. \
                             This information is formatted in Markdown.")]
    fn description(&self) -> &str {
        self.description
    }
}

#[derive(GraphQLInputObject)]
#[graphql(description = "Describes data that can be sent to devices. When \
			 specifying data, one -- and only one -- field \
			 must be set.")]
struct SettingData {
    #[graphql(name = "int", description = "Placeholder for integer values.")]
    f_int: Option<i32>,
    #[graphql(name = "flt", description = "Placeholder for float values.")]
    f_float: Option<f64>,
    #[graphql(name = "bool", description = "Placeholder for boolean values.")]
    f_bool: Option<bool>,
    #[graphql(name = "str", description = "Placeholder for string values.")]
    f_string: Option<String>,
    #[graphql(name = "color", description = "Placeholder for color values.")]
    f_color: Option<Vec<i32>>,
}

// Contains information about a device's history in the backend.

#[derive(GraphQLObject)]
#[graphql(description = "Contains information about a device's history, \
			 as currently stored in the backend. This information \
			 is a snapshot from when it was obtained. Depending \
			 on how frequently a device gets updated, this \
			 information may be obsolete in a short time.")]
struct DeviceHistory {
    #[graphql(description = "Total number of points in backend storage.")]
    total_points: i32,
    #[graphql(description = "The oldest data point in storage. If the total\
			     is 0, then this field will be null. Note that\
			     this value is accurate at the time of this\
			     query. However, at any moment, the oldest data\
			     point could be thrown away if new data arrives.")]
    first_point: Option<Reading>,
    #[graphql(description = "The latest data point in storage. If the total\
			     is 0, then this field will be null. Note that\
			     this value is accurate at the time of this\
			     query. However, at any moment, newer data could\
			     be added.")]
    last_point: Option<Reading>,
}

// `DeviceInfo` is a GraphQL object which contains information about a
// device.

struct DeviceInfo<R: Reporter> {
    device_name: String,
    units: Option<String>,
    settable: bool,
    driver_name: driver::Name,
    history: DeviceHistory,
    db: crate::driver::DriverDb<R>,
}

#[graphql_object(
    Context = ConfigDb<R>,
    description = "Information about a registered device in the running \
		   version of `drmemd`."
)]
impl<R: Reporter> DeviceInfo<R> {
    #[graphql(description = "The name of the device.")]
    fn device_name(&self) -> &str {
        &self.device_name
    }

    #[graphql(description = "The engineering units of the device's value.")]
    fn units(&self) -> Option<&String> {
        self.units.as_ref()
    }

    #[graphql(description = "Indicates whether the device is read-only \
			     or can be controlled.")]
    fn settable(&self) -> bool {
        self.settable
    }

    #[graphql(description = "Information about the driver that implements \
			     this device.")]
    fn driver(&self) -> DriverInfo<R> {
        self.db
            .get_driver(&self.driver_name)
            .map(|di| DriverInfo {
                name: self.driver_name.clone(),
                summary: di.0,
                description: di.1,
                phant: std::marker::PhantomData,
            })
            .unwrap()
    }

    fn history(&self) -> &DeviceHistory {
        &self.history
    }
}

struct LogicBlockVariable<R: Reporter> {
    name: String,
    device: String,
    phant: std::marker::PhantomData<R>,
}

#[graphql_object(
    Context = ConfigDb<R>,
    description = "Shows the input/output variable mapping in a logic block."
)]
impl<R: Reporter> LogicBlockVariable<R> {
    #[graphql(description = "The name of the variable.")]
    fn name(&self) -> &str {
        &self.name
    }

    #[graphql(description = "The name of the variable.")]
    fn device(&self) -> &str {
        &self.device
    }
}

struct LogicBlockExpression<R: Reporter> {
    name: String,
    expr: String,
    phant: std::marker::PhantomData<R>,
}

#[graphql_object(
    Context = ConfigDb<R>,
    description = "Shows the expression definitions in a logic block."
)]
impl<R: Reporter> LogicBlockExpression<R> {
    #[graphql(description = "The name of the definition.")]
    fn name(&self) -> &str {
        &self.name
    }

    #[graphql(description = "The expression.")]
    fn expr(&self) -> &str {
        &self.expr
    }
}

struct LogicBlock<R: Reporter> {
    name: Arc<str>,
    description: String,
    inputs: Vec<LogicBlockVariable<R>>,
    outputs: Vec<LogicBlockVariable<R>>,
    defs: Vec<LogicBlockExpression<R>>,
    expr: Vec<String>,
}

#[graphql_object(
    Context = ConfigDb<R>,
    description = "Shows the configuration of a logic block."
)]
impl<R: Reporter> LogicBlock<R> {
    #[graphql(description = "The name of the logic block.")]
    fn name(&self) -> &str {
        &self.name
    }

    #[graphql(description = "A description of the logic block's purpose.")]
    fn description(&self) -> &str {
        &self.description
    }

    #[graphql(description = "The inputs needed by the logic block.")]
    fn inputs(&self) -> &[LogicBlockVariable<R>] {
        &self.inputs
    }

    #[graphql(description = "The outputs controlled by the logic block.")]
    fn outputs(&self) -> &[LogicBlockVariable<R>] {
        &self.outputs
    }

    #[graphql(description = "Shared expressions used by the logic block.")]
    fn defs(&self) -> &[LogicBlockExpression<R>] {
        &self.defs
    }

    #[graphql(description = "Control expressions used by the logic block.")]
    fn expr(&self) -> &[String] {
        &self.expr
    }
}

// This defines the top-level Query API.

struct Config<R: Reporter>(std::marker::PhantomData<R>);

impl<R: Reporter> Config<R> {
    // These helper functions are used by a call to `Iterator::filter`
    // to select a set of devices.

    fn is_settable(e: &&client::DevInfoReply) -> bool {
        e.settable
    }

    fn is_not_settable(e: &&client::DevInfoReply) -> bool {
        !e.settable
    }

    fn is_true(_e: &&client::DevInfoReply) -> bool {
        true
    }

    // This method returns a closure that can be used with
    // `Iterator<Item = Arc<LogicBlock>>::filter`.

    fn logic_block_filter(
        name: Option<String>,
        devices: Option<Vec<String>>,
    ) -> impl FnMut(&Arc<LogicBlock<R>>) -> bool {
        move |lb: &Arc<LogicBlock<R>>| {
            // If a name was specified, return `false` if the current
            // LogicBlock doesn't that name. If it has the name, we
            // still need to see if the device name  filter further
            // restricts the results.

            if let Some(ref name) = name {
                if *name != *lb.name {
                    return false;
                }
            }

            // If a list of device names was specified, look through
            // the inputs and outputs to see if any devices match any
            // in the list.

            if let Some(ref devices) = devices {
                for ins in lb.inputs.iter() {
                    if devices.iter().any(|v| v == &ins.device) {
                        return true;
                    }
                }
                for outs in lb.outputs.iter() {
                    if devices.iter().any(|v| v == &outs.device) {
                        return true;
                    }
                }
                return false;
            }

            // If neither filter was given or the name filter matched,
            // then return `true` to keep the current entry in the
            // results.

            true
        }
    }
}

#[graphql_object(
    context = ConfigDb<R>,
    description = "Reports configuration information for `drmemd`."
)]
impl<R: Reporter + Clone> Config<R> {
    #[graphql(description = "Returns logic blocks configured in the node. By \
                             default, all logic blocks are returned. If either \
                             parameter is given, the results are filtered to \
                             only return information that matches the selection \
                             values.")]
    fn logic_blocks(
        #[graphql(context)] db: &ConfigDb<R>,
        #[graphql(description = "If provided, only the logic block with the \
                                 specified name will be returned.")]
        sel_name: Option<String>,
        #[graphql(
            description = "This parameter can specify a list of device \
                                 names. Only logic blocks that use any of the \
                                 devices in either input or output will be \
                                 included in the results."
        )]
        sel_devices: Option<Vec<String>>,
    ) -> result::Result<Vec<Arc<LogicBlock<R>>>, FieldError> {
        Ok(db
            .2
            .iter()
            .cloned()
            .filter(Self::logic_block_filter(sel_name, sel_devices))
            .collect())
    }

    #[graphql(description = "Returns information about the available drivers \
			     in the running instance of `drmemd`. If `name` \
			     isn't provided, an array of all driver \
			     information is returned. If `name` is specified \
			     and a driver with that name exists, a single \
			     element array is returned. Otherwise `null` is \
			     returned.")]
    fn driver_info(
        #[graphql(context)] db: &ConfigDb<R>,
        #[graphql(description = "An optional argument which, when provided, \
				 only returns driver information whose name \
				 matches. If this argument isn't provided, \
				 every drivers' information will be returned.")]
        name: Option<String>,
    ) -> result::Result<Vec<DriverInfo<R>>, FieldError> {
        if let Some(name) = name {
            if let Some((n, s, d)) = db.0.find(&name) {
                Ok(vec![DriverInfo {
                    name: n,
                    summary: s,
                    description: d,
                    phant: std::marker::PhantomData,
                }])
            } else {
                Err(FieldError::new(
                    "driver not found",
                    graphql_value!({ "missing_driver": name }),
                ))
            }
        } else {
            let result =
                db.0.get_all()
                    .map(|(n, s, d)| DriverInfo {
                        name: n,
                        summary: s,
                        description: d,
                        phant: std::marker::PhantomData,
                    })
                    .collect();

            Ok(result)
        }
    }

    #[graphql(
        description = "Returns information associated with the devices that \
		       are active in the running system. Arguments to the \
		       query will filter the results.\n\n\
		       If the argument `pattern` is provided, only the \
		       devices whose name matches the pattern will be \
		       included in the results. The pattern follows the \
		       shell \"glob\" style.\n\n\
		       If the argument `settable` is provided, it returns \
		       devices that are or aren't settable, depending on the \
		       value of the agument."
    )]
    async fn device_info(
        #[graphql(context)] db: &ConfigDb<R>,
        #[graphql(
            name = "pattern",
            description = "If this argument is provided, the query returns \
			   information for devices whose name matches the \
			   pattern. The pattern uses \"globbing\" grammar: \
			   '?' matches one character, '*' matches zero or \
			   more, '**' matches arbtrary levels of the path \
			   (between ':'s)."
        )]
        pattern: Option<String>,
        #[graphql(
            name = "settable",
            description = "If this argument is provided, the query filters \
			   the result based on whether the device can be set \
			   or not."
        )]
        settable: Option<bool>,
    ) -> result::Result<Vec<DeviceInfo<R>>, FieldError> {
        let tx = db.1.clone();
        let filt = settable
            .map(|v| {
                if v {
                    Config::<R>::is_settable
                } else {
                    Config::<R>::is_not_settable
                }
            })
            .unwrap_or(Config::<R>::is_true);

        tx.get_device_info(pattern)
            .await
            .map(|v| {
                v.iter()
                    .filter(filt)
                    .map(|e| DeviceInfo {
                        device_name: e.name.to_string(),
                        units: e.units.clone(),
                        settable: e.settable,
                        driver_name: e.driver.clone(),
                        history: DeviceHistory {
                            total_points: e.total_points as i32,
                            first_point: e.first_point.as_ref().map(|v| {
                                Reading {
                                    device: e.name.to_string(),
                                    ..v.into()
                                }
                            }),
                            last_point: e.last_point.as_ref().map(|v| {
                                Reading {
                                    device: e.name.to_string(),
                                    ..v.into()
                                }
                            }),
                        },
                        db: db.0.clone(),
                    })
                    .collect()
            })
            .map_err(|_| {
                FieldError::new("error looking-up device", Value::null())
            })
    }
}

// The `Control` mutation is used to group queries that attempt to
// control devices by sending them settings.

struct Control<R: Reporter>(std::marker::PhantomData<R>);

impl<R: Reporter> Control<R> {
    // Sends a new value to a device.

    async fn perform_setting<
        T: Into<device::Value> + TryFrom<device::Value, Error = Error>,
    >(
        db: &ConfigDb<R>,
        device: &str,
        value: T,
    ) -> result::Result<T, FieldError> {
        // Make sure the device name is properly formed.

        if let Ok(name) = device.try_into() {
            let tx = db.1.clone();

            // Send the setting to the driver. Map the error, if any,
            // to a `FieldError` type.

            tx.set_device::<T>(name, value).await.map_err(|e| {
                let errmsg = format!("{}", &e);

                FieldError::new(
                    "error making setting",
                    graphql_value!({ "error": errmsg }),
                )
            })
        } else {
            Err(FieldError::new("badly formed device name", Value::null()))
        }
    }

    // Helper function which returns a closure that converts a
    // boolean value to a `Reading` type.

    fn bool_to_reading(name: String) -> impl FnOnce(bool) -> Reading {
        |v| Reading {
            device: name,
            stamp: Utc::now(),
            int_value: None,
            float_value: None,
            bool_value: Some(v),
            string_value: None,
            color_value: None,
        }
    }

    // Helper function which returns a closure that converts an
    // integer to a `Reading` type.

    fn int_to_reading(name: String) -> impl FnOnce(i32) -> Reading {
        |v| Reading {
            device: name,
            stamp: Utc::now(),
            int_value: Some(v),
            float_value: None,
            bool_value: None,
            string_value: None,
            color_value: None,
        }
    }

    // Helper function which returns a closure that converts a
    // floating point value to a `Reading` type.

    fn flt_to_reading(name: String) -> impl FnOnce(f64) -> Reading {
        |v| Reading {
            device: name,
            stamp: Utc::now(),
            int_value: None,
            float_value: Some(v),
            bool_value: None,
            string_value: None,
            color_value: None,
        }
    }

    // Helper function which returns a closure that converts a
    // string value to a `Reading` type.

    fn str_to_reading(name: String) -> impl FnOnce(String) -> Reading {
        |v| Reading {
            device: name,
            stamp: Utc::now(),
            int_value: None,
            float_value: None,
            bool_value: None,
            string_value: Some(v.into()),
            color_value: None,
        }
    }

    // Helper function which returns a closure that converts a color
    // value to a `Reading` type.

    fn color_to_reading(
        name: String,
    ) -> impl FnOnce(palette::LinSrgba<u8>) -> Reading {
        |v| Reading {
            device: name,
            stamp: Utc::now(),
            int_value: None,
            float_value: None,
            bool_value: None,
            string_value: None,
            color_value: Some(if v.alpha == 255 {
                vec![v.red as i32, v.green as i32, v.blue as i32]
            } else {
                vec![
                    v.red as i32,
                    v.green as i32,
                    v.blue as i32,
                    v.alpha as i32,
                ]
            }),
        }
    }
}

#[graphql_object(
    context = ConfigDb<R>,
    description = "This group of queries perform modifications to devices."
)]
impl<R: Reporter> Control<R> {
    #[graphql(description = "Submits `value` to be applied to the device \
			     associated with the given `name`. If the data \
			     is in a format the device doesn't support an \
			     error is returned. The `value` parameter \
			     contains several fields. Only one should be \
			     set. It is an error to have all fields `null` \
			     or more than one field non-`null`.")]
    async fn set_device(
        #[graphql(context)] db: &ConfigDb<R>,
        name: String,
        value: SettingData,
    ) -> FieldResult<Reading> {
        match value {
            SettingData {
                f_int: None,
                f_float: None,
                f_bool: None,
                f_string: None,
                f_color: None,
            } => Err(FieldError::new("no data provided", Value::null())),

            SettingData {
                f_int: Some(v),
                f_float: None,
                f_bool: None,
                f_string: None,
                f_color: None,
            } => Control::perform_setting(db, &name, v)
                .await
                .map(Control::<R>::int_to_reading(name)),

            SettingData {
                f_int: None,
                f_float: Some(v),
                f_bool: None,
                f_string: None,
                f_color: None,
            } => Control::perform_setting(db, &name, v)
                .await
                .map(Control::<R>::flt_to_reading(name)),

            SettingData {
                f_int: None,
                f_float: None,
                f_bool: Some(v),
                f_string: None,
                f_color: None,
            } => Control::perform_setting(db, &name, v)
                .await
                .map(Control::<R>::bool_to_reading(name)),

            SettingData {
                f_int: None,
                f_float: None,
                f_bool: None,
                f_string: Some(v),
                f_color: None,
            } => Control::perform_setting(db, &name, v)
                .await
                .map(Control::<R>::str_to_reading(name)),

            SettingData {
                f_int: None,
                f_float: None,
                f_bool: None,
                f_string: None,
                f_color: Some(v),
            } => match v[..] {
                [r, g, b] => {
                    if let (Ok(r), Ok(g), Ok(b)) =
                        (u8::try_from(r), u8::try_from(g), u8::try_from(b))
                    {
                        Control::<R>::perform_setting(
                            db,
                            &name,
                            palette::LinSrgba::<u8>::new(r, g, b, 255),
                        )
                        .await
                        .map(Control::<R>::color_to_reading(name))
                    } else {
                        Err(FieldError::new(
                            "color component is out of range",
                            Value::null(),
                        ))
                    }
                }
                [r, g, b, a] => {
                    if let (Ok(r), Ok(g), Ok(b), Ok(a)) = (
                        u8::try_from(r),
                        u8::try_from(g),
                        u8::try_from(b),
                        u8::try_from(a),
                    ) {
                        Control::perform_setting(
                            db,
                            &name,
                            palette::LinSrgba::<u8>::new(r, g, b, a),
                        )
                        .await
                        .map(Control::<R>::color_to_reading(name))
                    } else {
                        Err(FieldError::new(
                            "color component is out of range",
                            Value::null(),
                        ))
                    }
                }
                _ => Err(FieldError::new(
                    "color values have three or four components",
                    Value::null(),
                )),
            },

            SettingData { .. } => Err(FieldError::new(
                "must only specify one item of data",
                Value::null(),
            )),
        }
    }
}

#[derive(GraphQLInputObject)]
#[graphql(description = "Defines a range of time between two dates.")]
struct DateRange {
    #[graphql(
        description = "The start of the date range (in UTC.) If `null`, \
			     it means \"now\"."
    )]
    start: Option<DateTime<Utc>>,
    #[graphql(description = "The end of the date range (in UTC.) If `null`, \
			     it means \"infinity\".")]
    end: Option<DateTime<Utc>>,
}

#[derive(GraphQLObject)]
#[graphql(
    description = "Represents a value of a device at an instant of time."
)]
struct Reading {
    device: String,
    stamp: DateTime<Utc>,
    #[graphql(description = "Placeholder for integer values.")]
    int_value: Option<i32>,
    #[graphql(description = "Placeholder for float values.")]
    float_value: Option<f64>,
    #[graphql(description = "Placeholder for boolean values.")]
    bool_value: Option<bool>,
    #[graphql(description = "Placeholder for string values.")]
    string_value: Option<Arc<str>>,
    #[graphql(
        description = "Placeholder for color values. Values are a 3-element \
		       array holding red, green, and blue values or a \
		       4-element array holding red, gree, blue, and alpha \
		       values. Each value ranges from 0 - 255."
    )]
    color_value: Option<Vec<i32>>,
}

impl From<&device::Reading> for Reading {
    fn from(value: &device::Reading) -> Self {
        match &value.value {
            device::Value::Bool(v) => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: None,
                float_value: None,
                bool_value: Some(*v),
                string_value: None,
                color_value: None,
            },
            device::Value::Int(v) => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: Some(*v),
                float_value: None,
                bool_value: None,
                string_value: None,
                color_value: None,
            },
            device::Value::Flt(v) => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: None,
                float_value: Some(*v),
                bool_value: None,
                string_value: None,
                color_value: None,
            },
            device::Value::Str(v) => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: None,
                float_value: None,
                bool_value: None,
                string_value: Some(v.clone()),
                color_value: None,
            },
            device::Value::Color(v) if v.alpha == 255 => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: None,
                float_value: None,
                bool_value: None,
                string_value: None,
                color_value: Some(vec![
                    v.red as i32,
                    v.green as i32,
                    v.blue as i32,
                ]),
            },
            device::Value::Color(v) => Reading {
                device: "".into(),
                stamp: DateTime::<Utc>::from(value.ts),
                int_value: None,
                float_value: None,
                bool_value: None,
                string_value: None,
                color_value: Some(vec![
                    v.red as i32,
                    v.green as i32,
                    v.blue as i32,
                    v.alpha as i32,
                ]),
            },
        }
    }
}

struct Subscription<R: Reporter>(std::marker::PhantomData<R>);

impl<R: Reporter> Subscription<R> {
    fn xlat(name: String) -> impl Fn(device::Reading) -> FieldResult<Reading> {
        move |e: device::Reading| {
            let mut reading = Reading {
                device: name.clone(),
                stamp: DateTime::<Utc>::from(e.ts),
                bool_value: None,
                int_value: None,
                float_value: None,
                string_value: None,
                color_value: None,
            };

            match e.value {
                device::Value::Bool(v) => reading.bool_value = Some(v),
                device::Value::Int(v) => reading.int_value = Some(v),
                device::Value::Flt(v) => reading.float_value = Some(v),
                device::Value::Str(v) => reading.string_value = Some(v.clone()),
                device::Value::Color(v) if v.alpha == 255 => {
                    reading.color_value =
                        Some(vec![v.red as i32, v.green as i32, v.blue as i32])
                }
                device::Value::Color(v) => {
                    reading.color_value = Some(vec![
                        v.red as i32,
                        v.green as i32,
                        v.blue as i32,
                        v.alpha as i32,
                    ])
                }
            }

            Ok(reading)
        }
    }
}

#[graphql_subscription(context = ConfigDb<R>)]
impl<R: Reporter> Subscription<R> {
    #[graphql(description = "Sets up a connection to receive all updates to \
			     a device. The GraphQL request must provide the \
			     name of a device. This method returns a stream \
			     which generates a reply each time a device's \
			     value changes.")]
    async fn monitor_device(
        #[graphql(context)] db: &ConfigDb<R>,
        device: String,
        range: Option<DateRange>,
    ) -> device::DataStream<FieldResult<Reading>> {
        use tokio_stream::StreamExt;

        if let Ok(name) = device.clone().try_into() {
            debug!("setting monitor for '{}'", &name);

            let start = range.as_ref().and_then(|v| v.start);
            let end = range.as_ref().and_then(|v| v.end);

            if let Ok(rx) = db.1.monitor_device(name, start, end).await {
                let stream =
                    StreamExt::map(rx, Subscription::<R>::xlat(device));

                Box::pin(stream) as device::DataStream<FieldResult<Reading>>
            } else {
                let stream = tokio_stream::once(Err(FieldError::new(
                    "device not found",
                    Value::null(),
                )));

                Box::pin(stream) as device::DataStream<FieldResult<Reading>>
            }
        } else {
            let stream = tokio_stream::once(Err(FieldError::new(
                "badly formed device name",
                Value::null(),
            )));

            Box::pin(stream) as device::DataStream<FieldResult<Reading>>
        }
    }
}

type Schema<R> = RootNode<'static, Config<R>, Control<R>, Subscription<R>>;

fn schema<R: Reporter + Clone>() -> Schema<R> {
    Schema::new(
        Config::<R>(std::marker::PhantomData),
        Control::<R>(std::marker::PhantomData),
        Subscription::<R>(std::marker::PhantomData),
    )
}

// Define the URI paths used by the GraphQL interface.

mod paths {
    pub const BASE: &str = "drmem";
    pub const QUERY: &str = "q";
    pub const SUBSCRIBE: &str = "s";

    // Until we can build strings at compile-time, we use the
    // `lazy_static` macro.

    lazy_static! {
        pub static ref FULL_QUERY: String = format!("/{}/{}", BASE, QUERY);
        pub static ref FULL_SUBSCRIBE: String =
            format!("/{}/{}", BASE, SUBSCRIBE);
    }
}

fn logic_to_gql<R: Reporter>(logic: &Logic) -> Arc<LogicBlock<R>> {
    LogicBlock {
        name: logic.name.clone().into(),
        description: logic
            .summary
            .clone()
            .unwrap_or_else(|| "".into())
            .to_string(),
        inputs: logic
            .inputs
            .iter()
            .map(|v| LogicBlockVariable::<R> {
                name: v.0.clone(),
                device: v.1.to_string(),
                phant: std::marker::PhantomData,
            })
            .collect(),
        outputs: logic
            .outputs
            .iter()
            .map(|v| LogicBlockVariable::<R> {
                name: v.0.clone(),
                device: v.1.to_string(),
                phant: std::marker::PhantomData,
            })
            .collect(),
        defs: logic
            .defs
            .iter()
            .map(|v| LogicBlockExpression::<R> {
                name: v.0.clone(),
                expr: v.1.clone(),
                phant: std::marker::PhantomData,
            })
            .collect(),
        expr: logic.exprs.clone(),
    }
    .into()
}

// Build `warp::Filter`s that define the entire webspace.

fn build_base_site<R: Reporter + Clone>(
    db: crate::driver::DriverDb<R>,
    cchan: client::RequestChan,
    db_logic: &[Logic],
) -> impl Filter<Extract = (impl Reply,), Error = Rejection> + Clone {
    let context = ConfigDb::<R>(
        db,
        cchan,
        db_logic.iter().map(logic_to_gql).collect::<Vec<_>>(),
    );
    let ctxt = context.clone();

    // Create filter that handles GraphQL queries and mutations.

    let state = warp::any().map(move || ctxt.clone());
    let query_filter = warp::path(paths::QUERY)
        .and(warp::path::end())
        .and(warp::post().or(warp::get()).unify())
        .and(juniper_warp::make_graphql_filter(schema(), state.boxed()));

    // Create filter that handle the interactive GraphQL app. This
    // service is found at the BASE path.

    #[cfg(feature = "graphiql")]
    let graphiql_filter =
        warp::path::end().and(juniper_warp::playground_filter(
            &*paths::FULL_QUERY,
            Some(&*paths::FULL_SUBSCRIBE),
        ));

    // Create the filter that handles subscriptions.

    let sub_filter = warp::path(paths::SUBSCRIBE)
        .and(warp::path::end())
        .and(warp::ws())
        .and(warp::addr::remote())
        .map(
            move |ws: warp::ws::Ws, addr: Option<std::net::SocketAddr>| {
                let ctxt = context.clone();
                let root_node = schema();

                ws.on_upgrade(move |websocket| {
                    async move {
                        let _ = serve_graphql_ws(
                            websocket,
                            Arc::new(root_node),
                            ConnectionConfig::new(ctxt.clone()),
                        )
                        .await;
                    }
                    .instrument(info_span!(
                        "graphql",
                        client = addr
                            .map(|v| v.to_string())
                            .unwrap_or_else(|| String::from("*unknown*"))
                            .as_str()
                    ))
                })
            },
        );

    #[cfg(feature = "graphiql")]
    let site = query_filter.or(graphiql_filter).or(sub_filter);

    #[cfg(not(feature = "graphiql"))]
    let site = query_filter.or(sub_filter);

    // Stitch the filters together to build the map of the web
    // interface.

    warp::path(paths::BASE)
        .and(site)
        .with(warp::log("gql::drmem"))
        .with(warp::filters::compression::gzip())
        .with(
            warp::cors()
                .allow_any_origin()
                .allow_headers(vec![
                    "content-type",
                    "Access-Control-Allow-Origin",
                ])
                .allow_methods(vec!["OPTIONS", "GET", "POST"])
                .max_age(Duration::from_secs(3_600)),
        )
}

fn build_site<R: Reporter + Clone>(
    db: crate::driver::DriverDb<R>,
    cchan: client::RequestChan,
    db_logic: &[Logic],
) -> impl Filter<Extract = (impl Reply,), Error = std::convert::Infallible> + Clone
{
    warn!("building insecure GraphQL interface");
    build_base_site(db, cchan, db_logic).recover(handle_rejection)
}

fn build_secure_site<R: Reporter + Clone>(
    cfg: &config::Security,
    db: crate::driver::DriverDb<R>,
    cchan: client::RequestChan,
    db_logic: &[Logic],
) -> impl Filter<Extract = (impl Reply,), Error = std::convert::Infallible> + Clone
{
    info!("building secure GraphQL interface");

    // Clone the table of clients that are allowed in to the system.

    let clients: Arc<[String]> = Arc::clone(&cfg.clients);

    // Create a closure that validates the client. It takes a client
    // fingerprint as an argument and checks to see if it exists in
    // the list of clients in the configuration.

    let check_client = move |client: String| {
        futures::future::ready(
            if clients.iter().any(|v| cmp_fprints(v, &client)) {
                Ok(())
            } else {
                Err(reject::custom(NoAuthorization))
            },
        )
    };

    // Build the TLS server.

    warp::header::<String>("X-DrMem-Client-Id")
        .and_then(check_client)
        .untuple_one()
        .and(build_base_site(db, cchan, db_logic))
        .recover(handle_rejection)
}

// "Sanitizes" a string containing a digital fingerprint by returning
// an Iterator that only returns the hex digits in uppercase.

fn sanitize<T>(ii: T) -> impl Iterator<Item = char>
where
    T: Iterator<Item = char>,
{
    ii.filter(char::is_ascii_hexdigit)
        .map(|v| v.to_ascii_uppercase())
}

// Compares two `str`s as if they held digital fingerprints.

fn cmp_fprints(a: &str, b: &str) -> bool {
    let mut a = sanitize(a.chars());
    let mut b = sanitize(b.chars());

    loop {
        match (a.next(), b.next()) {
            (None, None) => break true,
            (Some(a), Some(b)) if a == b => continue,
            (_, _) => break false,
        }
    }
}

// Builds the server object that will handle GraphQL requests. If the
// configuration contains the `security` key, the server will require
// TLS connections.

fn build_server<R: Reporter + Clone>(
    cfg: &config::Config,
    db_logic: &[Logic],
    db: crate::driver::DriverDb<R>,
    cchan: client::RequestChan,
) -> Pin<Box<dyn Future<Output = ()> + Send>> {
    if let Some(security) = &cfg.security {
        Box::pin(
            warp::serve(build_secure_site(security, db, cchan, db_logic))
                .tls()
                .key_path(security.key_file.clone())
                .cert_path(security.cert_file.clone())
                .bind(cfg.addr),
        ) as Pin<Box<dyn Future<Output = ()> + Send>>
    } else {
        Box::pin(warp::serve(build_site(db, cchan, db_logic)).bind(cfg.addr))
            as Pin<Box<dyn Future<Output = ()> + Send>>
    }
}

async fn handle_rejection(
    err: Rejection,
) -> Result<impl Reply, std::convert::Infallible> {
    if err.is_not_found() {
        Ok(reply::with_status("NOT_FOUND", StatusCode::NOT_FOUND))
    } else if err.find::<NoAuthorization>().is_some()
        || err.find::<reject::MissingHeader>().is_some()
    {
        Ok(reply::with_status("FORBIDDEN", StatusCode::FORBIDDEN))
    } else {
        error!("unhandled rejection: {:?}", err);
        Ok(reply::with_status(
            "INTERNAL_SERVER_ERROR",
            StatusCode::INTERNAL_SERVER_ERROR,
        ))
    }
}

fn calc_fingerprint(cert: &[u8]) -> String {
    use ring::digest::{Context, Digest, SHA256};
    use std::fmt::Write;

    let mut context = Context::new(&SHA256);

    context.update(cert);

    let digest: Digest = context.finish();

    // Format the fingerprint as a hexadecimal string.

    digest.as_ref().iter().fold(String::new(), |mut output, b| {
        let _ = write!(output, "{b:02X}");
        output
    })
}

fn build_mdns_payload(cfg: &config::Config) -> Result<Vec<String>, Error> {
    // Get the boot-time and store it in the mDNS payload.

    let boot_time: DateTime<Utc> = Utc::now();

    // Build the mDNS payload section. This is a vector of "KEY=VALUE"
    // strings which will get added to the `txt` section of the mDNS
    // announcement.

    let mut payload: Vec<String> = vec![
        format!("version={}", env!("CARGO_PKG_VERSION")),
        format!("location={}", cfg.location),
        format!(
            "boot-time={}",
            boot_time.to_rfc3339_opts(SecondsFormat::Secs, true)
        ),
        format!("queries={}", &*paths::FULL_QUERY),
        format!("mutations={}", &*paths::FULL_QUERY),
        format!("subscriptions={}", &*paths::FULL_SUBSCRIBE),
    ];

    // If security is specified, this section of code adds the digital
    // signature of the certificate to the payload.

    if let Some(sec) = &cfg.security {
        use rustls_pki_types::{pem::PemObject, CertificateDer};

        match CertificateDer::pem_file_iter(sec.cert_file.clone()) {
            Ok(mut certs) => match certs.next() {
                Some(Ok(cert)) => {
                    payload.push(format!("sig_sha={}", calc_fingerprint(&cert)))
                }
                Some(Err(e)) => {
                    return Err(Error::ConfigError(format!(
                        "couldn't parse certificate : {e}"
                    )))
                }
                None => {
                    return Err(Error::ConfigError(format!(
                        "no certificate(s) found in {}",
                        sec.cert_file.display()
                    )))
                }
            },
            Err(e) => {
                return Err(Error::ConfigError(format!(
                    "error accessing certificate file '{}' : {}",
                    &sec.cert_file.display(),
                    e
                )))
            }
        }
    }

    // If the configuration specifies a preferred address to use, add
    // it to the payload.

    if let Some(host) = &cfg.pref_host {
        info!("adding preferred address: {}:{}", &host, cfg.pref_port);
        payload.push(format!("pref-addr={}:{}", &host, cfg.pref_port))
    }

    Ok(payload)
}

pub fn server<R: Reporter + Clone>(
    cfg: &config::Config,
    db_logic: &[Logic],
    db: crate::driver::DriverDb<R>,
    cchan: client::RequestChan,
) -> impl Future<Output = ()> {
    let (resp, task) = Responder::with_default_handle().unwrap();
    let http_task = build_server(cfg, db_logic, db, cchan);

    match build_mdns_payload(cfg) {
        Ok(payload) => {
            // Register DrMem's mDNS entry. In the properties field,
            // inform the client with which paths to use for each
            // GraphQL query type.

            let service = resp.register(
                "_drmem._tcp".into(),
                cfg.name.clone(),
                cfg.addr.port(),
                &payload.iter().map(String::as_str).collect::<Vec<&str>>(),
            );

            // Make mDNS run in the background.

            let jh = tokio::spawn(async move {
                task.await;
                drop(service)
            });

            std::mem::drop(jh);

            http_task.instrument(info_span!("http"))
        }
        Err(e) => {
            panic!("GraphQL config error : {e}")
        }
    }
}

#[cfg(test)]
mod test {
    use super::{cmp_fprints, sanitize};
    use drmem_api::{device, driver::Reporter};

    #[derive(Clone)]
    struct Report;

    impl Reporter for Report {
        async fn report_value(&mut self, _value: device::Value) {}
    }

    #[test]
    fn test_sanitizer() {
        assert_eq!(sanitize("1234".chars()).collect::<String>(), "1234");
        assert_eq!(
            sanitize("0123456789abcdefABCDEF".chars()).collect::<String>(),
            "0123456789ABCDEFABCDEF"
        );
        assert_eq!(sanitize("01:ff:45".chars()).collect::<String>(), "01FF45");
    }

    #[test]
    fn test_fprint_comparisons() {
        assert_eq!(cmp_fprints("", ""), true);
        assert_eq!(cmp_fprints("z", ""), true);
        assert_eq!(cmp_fprints("", "z"), true);

        assert_eq!(cmp_fprints("a", ""), false);
        assert_eq!(cmp_fprints("", "a"), false);

        assert_eq!(cmp_fprints("1234", "1234"), true);
        assert_eq!(cmp_fprints("abcd", "ABCD"), true);
        assert_eq!(cmp_fprints("1234", "ABCD"), false);

        assert_eq!(cmp_fprints("12:34", "1234"), true);
        assert_eq!(cmp_fprints("a:b:c:d", "AB:CD"), true);
    }

    #[tokio::test]
    async fn test_base_site() {
        use super::build_site;
        use crate::driver::DriverDb;
        use drmem_api::client::RequestChan;
        use tokio::sync::mpsc;

        let (tx, _) = mpsc::channel(100);
        let filter =
            build_site(DriverDb::<Report>::create(), RequestChan::new(tx), &[]);

        #[cfg(not(feature = "graphiql"))]
        {
            let value = warp::test::request().path("/").reply(&filter).await;

            assert_eq!(value.status(), 404);
        }

        // Test a client that asks for a valid path, but is using the
        // incorrect method or a valid path and method but no body or
        // all present but the body content isn't valid. Should return
        // a BAD_REQUEST status.

        {
            let value =
                warp::test::request().path("/drmem/q").reply(&filter).await;

            assert_eq!(value.status(), 400);

            let value = warp::test::request()
                .method("POST")
                .path("/drmem/q")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 400);

            let value = warp::test::request()
                .method("POST")
                .path("/drmem/q")
                .body("query { }")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 400);
        }

        // Handle a perfect query.

        {
            let value = warp::test::request()
                .method("POST")
                .path("/drmem/q")
                .body(
                    "{
    \"query\": \"query { driverInfo { name } }\",
    \"variables\": {},
    \"operationName\": null
}",
                )
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 200);
        }

        // Test clients using the WebSocket interface.

        {
            let (tx, _) = mpsc::channel(100);
            let filter = build_site(
                DriverDb::<Report>::create(),
                RequestChan::new(tx),
                &[],
            );
            let client =
                warp::test::ws().path("/drmem/s").handshake(filter).await;

            assert!(client.is_ok());
        }
    }

    #[tokio::test]
    async fn test_site_security() {
        use super::{build_secure_site, config::Security};
        use crate::driver::DriverDb;
        use drmem_api::client::RequestChan;
        use std::{path::Path, sync::Arc};
        use tokio::sync::mpsc;

        let (tx, _) = mpsc::channel(100);
        let cfg = Security {
            clients: Arc::new([
                "00:11:22:33:44:55:66:77".into(),
                "11:11:11:11:11:11:11:11".into(),
            ]),
            cert_file: Path::new("").into(),
            key_file: Path::new("").into(),
        };
        let filter = build_secure_site(
            &cfg,
            DriverDb::<Report>::create(),
            RequestChan::new(tx),
            &[],
        );

        // Test a client that didn't define the Client ID
        // header. Should generate a FORBIDDEN status.

        {
            let value = warp::test::request().path("/").reply(&filter).await;

            assert_eq!(value.status(), 403);
        }

        // Test a client that presents a client ID not in our list of
        // valid clients. Should return a FORBIDDEN status.

        {
            let value = warp::test::request()
                .header("X-DrMem-Client-Id", "77:66:55:44:33:22:11:00")
                .path("/")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 403);
        }

        // Test a valid client that asks for a URL that doesn't have
        // any handler. Should return a NOT_FOUND status.

        {
            let value = warp::test::request()
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 404);
        }

        // Test a valid client that asks for a valid path, but is
        // using the incorrect method or a valid path and method but
        // no body or all present but the body content isn't
        // valid. Should return a BAD_REQUEST status.

        {
            let value = warp::test::request()
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/drmem/q")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 400);

            let value = warp::test::request()
                .method("POST")
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/drmem/q")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 400);

            let value = warp::test::request()
                .method("POST")
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/drmem/q")
                .body("query { }")
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 400);
        }

        // Handle a perfect, secure query.

        {
            let value = warp::test::request()
                .method("POST")
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/drmem/q")
                .body(
                    "{
    \"query\": \"query { driverInfo { name } }\",
    \"variables\": {},
    \"operationName\": null
}",
                )
                .reply(&filter)
                .await;

            assert_eq!(value.status(), 200);
        }

        // Test clients using the WebSocket interface.

        {
            let (tx, _) = mpsc::channel(100);
            let filter = build_secure_site(
                &cfg,
                DriverDb::<Report>::create(),
                RequestChan::new(tx),
                &[],
            );
            let client =
                warp::test::ws().path("/drmem/s").handshake(filter).await;

            assert!(client.is_err());
        }

        {
            let (tx, _) = mpsc::channel(100);
            let filter = build_secure_site(
                &cfg,
                DriverDb::<Report>::create(),
                RequestChan::new(tx),
                &[],
            );
            let client = warp::test::ws()
                .header("X-DrMem-Client-Id", "77:66:55:44:33:22:11:00")
                .path("/drmem/s")
                .handshake(filter)
                .await;

            assert!(client.is_err());
        }

        {
            let (tx, _) = mpsc::channel(100);
            let filter = build_secure_site(
                &cfg,
                DriverDb::<Report>::create(),
                RequestChan::new(tx),
                &[],
            );
            let client = warp::test::ws()
                .header("X-DrMem-Client-Id", "00:11:22:33:44:55:66:77")
                .path("/drmem/s")
                .handshake(filter)
                .await;

            assert!(client.is_ok());
        }
    }

    #[test]
    fn test_digital_fingerprint() {
        use rustls_pki_types::{pem::PemObject, CertificateDer};

        // Expired Mozilla certificate.

        const CERT: &[u8] = b"-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1
MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL
v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8
eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq
tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa
zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB
mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH
V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG
3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs
J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO
291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS
ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7
TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
-----END CERTIFICATE-----";

        let cert = CertificateDer::from_pem_slice(CERT).unwrap();

        assert!(
	    super::cmp_fprints(
		&super::calc_fingerprint(&cert),
		"CA:42:DD:41:74:5F:D0:B8:1E:B9:02:36:2C:F9:D8:BF:71:9D:A1:BD:1B:1E:FC:94:6F:5B:4C:99:F4:2C:1B:9E"
	    )
	);
    }
}

---
FILE: drmemd/src/logic/compile.rs
// This module contains the lexer and parser for the logic node
// language. It's main responsibility is to take expressions and
// convert them into a form that can be run in a background task.
//
// The language supports the following primitive types:
//
//     true/false        booleans
//     ##                integers
//     #.##              floating point numbers
//     "TEXT"            strings
//     {NAME}            variable named NAME (from config params)
//     #rrggbb or
//     #name		 RGB color values
//
// There are two built-in types, "utc" and "local", which can be used
// to obtain time-of-day values. Use the {} notation to access them:
//
//     {utc:second}
//     {utc:minute}
//     {utc:hour}
//     {utc:day}
//     {utc:month}
//     {utc:year}
//     {utc:DOW}	day of week (Monday = 0, Sunday = 6)
//     {utc:DOY}	day of year from 0 to 364 -- this ignores leap
//                      years and treats Feb 29th as Feb 28th
//     {utc:SOM}        the Nth day of week from the start of the month (1..)
//     {utc:EOM}        the Nth day of week from the end of the month (1..)
//     {utc:LY}		true if it's a leap year
//
//     {local:second}
//     {local:minute}
//     {local:hour}
//     {local:day}
//     {local:month}
//     {local:year}
//     {local:DOW}	day of week (Monday = 0, Sunday = 6)
//     {local:DOY}	day of year from 0 to 364 -- this ignores leap
//                      years and treats Feb 29th as Feb 28th
//     {local:SOM}      the Nth day of week from the start of the month (1..)
//     {local:EOM}      the Nth day of week from the end of the month (1..)
//     {local:LY}	true if it's a leap year
//
// There is a built-in type, "solar", that provides solar position in
// the sky.
//
//     {solar:alt}	altitude of sun (< 0 is below horizon, > 0 is above)
//     {solar:az}	azimuth of sun
//     {solar:ra}	right ascension of sun
//     {solar:dec}	declination of sun
//
// The token "->" represents assignment. The only item that can be on
// the right hand side of the arrow is a variable referring to a
// settable device (for logic blocks, output devices are specified in
// the `output` map of the configuration).
//
// Parentheses can be used to group subexpressions.
//
//     not EXPR          Computes the complement of a boolean expression
//     EXPR or EXPR      Computes the boolean OR of two boolean expressions
//     EXPR and EXPR     Computes the boolean AND of two boolean expressions
//     if EXPR then EXPR [else EXPR] end
//
//     =,<>,<,<=,>,>=    Perform the comparison and return a boolean
//
//     +,-,*,/,%         Perform addition, subtraction, multiplication,
//                       division, and modulo operations

use super::solar;
use super::tod;
use chrono::{Datelike, Timelike};
use drmem_api::{device, Error, Result};
use lrlex::lrlex_mod;
use lrpar::lrpar_mod;
use std::fmt;
use tracing::error;

// Pull in the lexer and parser for the Logic Node language.

lrlex_mod!("logic/logic.l");
lrpar_mod!("logic/logic.y");

#[derive(Clone, PartialEq, Debug)]
pub enum Zone {
    Utc,
    Local,
}

impl std::fmt::Display for Zone {
    fn fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
    ) -> std::result::Result<(), std::fmt::Error> {
        match self {
            Zone::Utc => write!(f, "utc"),
            Zone::Local => write!(f, "local"),
        }
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum TimeField {
    Second,
    Minute,
    Hour,
    Day,
    DoW,
    DoY,
    SoM,
    EoM,
    Month,
    Year,
    LeapYear,
}

impl TimeField {
    fn is_leap_year(year: i32) -> bool {
        ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)
    }

    fn get_last_day(month: u32, year: i32) -> u32 {
        match month {
            1 => 31,
            2 => 28 + (Self::is_leap_year(year) as u32),
            3 => 31,
            4 => 30,
            5 => 31,
            6 => 30,
            7 => 31,
            8 => 31,
            9 => 30,
            10 => 31,
            11 => 30,
            12 => 31,
            _ => unreachable!(),
        }
    }

    pub fn project<Tz: chrono::TimeZone>(
        &self,
        time: &chrono::DateTime<Tz>,
    ) -> device::Value {
        match self {
            TimeField::Second => device::Value::Int(time.second() as i32),
            TimeField::Minute => device::Value::Int(time.minute() as i32),
            TimeField::Hour => device::Value::Int(time.hour() as i32),
            TimeField::Day => device::Value::Int(time.day() as i32),
            TimeField::DoW => {
                device::Value::Int(time.weekday().num_days_from_monday() as i32)
            }
            TimeField::DoY => {
                let doy = time.ordinal0() as i32;
                let offset =
                    (doy > 58 && Self::is_leap_year(time.year())) as i32;

                device::Value::Int(doy - offset)
            }
            TimeField::SoM => device::Value::Int(time.day().div_ceil(7) as i32),
            TimeField::EoM => {
                let day = time.day();
                let last_day = Self::get_last_day(time.month(), time.year());

                device::Value::Int(((last_day + 7 - day) / 7) as i32)
            }
            TimeField::Month => device::Value::Int(time.month() as i32),
            TimeField::Year => device::Value::Int(time.year()),
            TimeField::LeapYear => {
                device::Value::Bool(Self::is_leap_year(time.year()))
            }
        }
    }
}

impl std::fmt::Display for TimeField {
    fn fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
    ) -> std::result::Result<(), std::fmt::Error> {
        match self {
            TimeField::Second => write!(f, "second"),
            TimeField::Minute => write!(f, "minute"),
            TimeField::Hour => write!(f, "hour"),
            TimeField::Day => write!(f, "day"),
            TimeField::DoW => write!(f, "DOW"),
            TimeField::EoM => write!(f, "EOM"),
            TimeField::SoM => write!(f, "SOM"),
            TimeField::Month => write!(f, "month"),
            TimeField::Year => write!(f, "year"),
            TimeField::DoY => write!(f, "DOY"),
            TimeField::LeapYear => write!(f, "LY"),
        }
    }
}

#[derive(Clone, PartialEq, Debug)]
pub enum SolarField {
    Elevation,
    Azimuth,
    RightAscension,
    Declination,
}

impl SolarField {
    pub fn project(&self, solar: &solar::Info) -> device::Value {
        match self {
            SolarField::Elevation => device::Value::Flt(solar.elevation),
            SolarField::Azimuth => device::Value::Flt(solar.azimuth),
            SolarField::RightAscension => {
                device::Value::Flt(solar.right_ascension)
            }
            SolarField::Declination => device::Value::Flt(solar.declination),
        }
    }
}

impl std::fmt::Display for SolarField {
    fn fmt(
        &self,
        f: &mut std::fmt::Formatter<'_>,
    ) -> std::result::Result<(), std::fmt::Error> {
        match self {
            SolarField::Elevation => write!(f, "alt"),
            SolarField::Azimuth => write!(f, "az"),
            SolarField::RightAscension => write!(f, "ra"),
            SolarField::Declination => write!(f, "dec"),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum Expr {
    Nothing,

    Lit(device::Value),
    Var(usize),
    TimeVal(Zone, TimeField),
    SolarVal(SolarField),

    Not(Box<Expr>),
    And(Box<Expr>, Box<Expr>),
    Or(Box<Expr>, Box<Expr>),

    If(Box<Expr>, Box<Expr>, Option<Box<Expr>>),

    // NotEq, Gt, and GtEq are parsed and converted into one of the
    // following three representations (the NotEq is a combination Not
    // and Eq value.)
    Eq(Box<Expr>, Box<Expr>),
    Lt(Box<Expr>, Box<Expr>),
    LtEq(Box<Expr>, Box<Expr>),

    Add(Box<Expr>, Box<Expr>),
    Sub(Box<Expr>, Box<Expr>),

    Mul(Box<Expr>, Box<Expr>),
    Div(Box<Expr>, Box<Expr>),
    Rem(Box<Expr>, Box<Expr>),
}

impl Expr {
    pub fn precedence(&self) -> u32 {
        match self {
            Expr::Lit(_)
            | Expr::Var(_)
            | Expr::TimeVal(..)
            | Expr::SolarVal(..)
            | Expr::Nothing => 10,
            Expr::Not(_) => 9,
            Expr::Mul(_, _) | Expr::Div(_, _) | Expr::Rem(_, _) => 5,
            Expr::Add(_, _) | Expr::Sub(_, _) => 4,
            Expr::Lt(_, _) | Expr::LtEq(_, _) | Expr::Eq(_, _) => 3,
            Expr::And(_, _) => 2,
            Expr::Or(_, _) => 1,
            Expr::If(_, _, _) => 0,
        }
    }

    // Traverses an expression and returns the highest changing
    // `TimeVal()` variants that it uses.

    pub fn uses_time(&self) -> Option<tod::TimeField> {
        match self {
            Expr::TimeVal(_, TimeField::Second) => Some(tod::TimeField::Second),
            Expr::TimeVal(_, TimeField::Minute) => Some(tod::TimeField::Minute),
            Expr::TimeVal(_, TimeField::Hour) => Some(tod::TimeField::Hour),
            Expr::TimeVal(_, TimeField::Day)
            | Expr::TimeVal(_, TimeField::SoM)
            | Expr::TimeVal(_, TimeField::EoM)
            | Expr::TimeVal(_, TimeField::DoW)
            | Expr::TimeVal(_, TimeField::DoY) => Some(tod::TimeField::Day),
            Expr::TimeVal(_, TimeField::Month) => Some(tod::TimeField::Month),
            Expr::TimeVal(_, TimeField::Year)
            | Expr::TimeVal(_, TimeField::LeapYear) => {
                Some(tod::TimeField::Year)
            }
            Expr::SolarVal(..)
            | Expr::Lit(_)
            | Expr::Var(_)
            | Expr::Nothing => None,
            Expr::Not(e) => e.uses_time(),
            Expr::Mul(a, b)
            | Expr::Div(a, b)
            | Expr::Rem(a, b)
            | Expr::Add(a, b)
            | Expr::Sub(a, b)
            | Expr::Lt(a, b)
            | Expr::LtEq(a, b)
            | Expr::Eq(a, b)
            | Expr::And(a, b)
            | Expr::Or(a, b) => match (a.uses_time(), b.uses_time()) {
                (None, None) => None,
                (a, None) => a,
                (None, b) => b,
                (Some(a), Some(b)) => Some(a.min(b)),
            },
            Expr::If(a, b, c) => {
                match (
                    a.uses_time(),
                    b.uses_time(),
                    c.as_ref().map(|v| v.uses_time()),
                ) {
                    (None, None, None) | (None, None, Some(None)) => None,
                    (None, None, Some(c @ Some(_))) => c,
                    (None, b @ Some(_), None)
                    | (None, b @ Some(_), Some(None)) => b,
                    (None, Some(b), Some(Some(c))) => Some(b.min(c)),
                    (a @ Some(_), None, None)
                    | (a @ Some(_), None, Some(None)) => a,
                    (Some(a), None, Some(Some(c))) => Some(a.min(c)),
                    (Some(a), Some(b), None)
                    | (Some(a), Some(b), Some(None)) => Some(a.min(b)),
                    (Some(a), Some(b), Some(Some(c))) => Some(a.min(b.min(c))),
                }
            }
        }
    }

    // Traverses an expression and returns `true` if it uses any
    // `SolarVal()` variants.

    pub fn uses_solar(&self) -> bool {
        match self {
            Expr::SolarVal(..) => true,
            Expr::TimeVal(..) | Expr::Lit(_) | Expr::Var(_) | Expr::Nothing => {
                false
            }
            Expr::Not(e) => e.uses_solar(),
            Expr::Mul(a, b)
            | Expr::Div(a, b)
            | Expr::Rem(a, b)
            | Expr::Add(a, b)
            | Expr::Sub(a, b)
            | Expr::Lt(a, b)
            | Expr::LtEq(a, b)
            | Expr::Eq(a, b)
            | Expr::And(a, b)
            | Expr::Or(a, b)
            | Expr::If(a, b, None) => a.uses_solar() || b.uses_solar(),
            Expr::If(a, b, Some(c)) => {
                a.uses_solar() || b.uses_solar() || c.uses_solar()
            }
        }
    }

    fn fmt_subexpr(&self, e: &Expr, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let my_prec = self.precedence();

        if my_prec > e.precedence() {
            write!(f, "({})", &e)
        } else {
            write!(f, "{}", &e)
        }
    }
}

impl fmt::Display for Expr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Expr::Nothing => write!(f, "!"),
            Expr::Lit(v) => write!(f, "{}", &v),
            Expr::Var(v) => write!(f, "inp[{}]", &v),

            Expr::TimeVal(cat, fld) => write!(f, "{{{cat}:{fld}}}"),

            Expr::SolarVal(fld) => write!(f, "{{solar:{fld}}}"),

            Expr::Not(e) => {
                write!(f, "not ")?;
                self.fmt_subexpr(e, f)
            }

            Expr::And(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " and ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Or(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " or ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Eq(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " = ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Lt(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " < ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::LtEq(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " <= ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Add(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " + ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Sub(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " - ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Mul(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " * ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Div(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " / ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::Rem(a, b) => {
                self.fmt_subexpr(a, f)?;
                write!(f, " % ")?;
                self.fmt_subexpr(b, f)
            }

            Expr::If(a, b, c) => {
                write!(f, "if ")?;
                self.fmt_subexpr(a, f)?;
                write!(f, " then ")?;
                self.fmt_subexpr(b, f)?;

                if let Some(c) = c {
                    write!(f, " else ")?;
                    self.fmt_subexpr(c, f)?;
                }
                write!(f, " end")
            }
        }
    }
}

// This is the "environment" of a compile. The first element is a list
// of names associated with devices that are to be read. The second
// element is a list of names associated with devices to be set. The
// `Program::compile` function uses this environment to compute the
// `Expr::Var` and `Program` values.

type Env<'a> = (&'a [String], &'a [String]);

#[derive(Debug, PartialEq)]
pub struct Program(pub Expr, pub usize);

impl Program {
    pub fn optimize(self) -> Self {
        Program(optimize(self.0), self.1)
    }

    pub fn compile(s: &str, env: &Env) -> Result<Program> {
        let lexerdef = logic_l::lexerdef();
        let lexer = lexerdef.lexer(s);
        let (res, errs) = logic_y::parse(&lexer, env);

        res.unwrap_or_else(|| {
            let res = errs.iter().fold(s.to_owned(), |mut acc, e| {
                acc.push_str(&format!("\n    {}", &e));
                acc
            });

            Err(Error::ParseError(res))
        })
    }
}

impl fmt::Display for Program {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} -> out[{}]", &self.0, &self.1)
    }
}

// Evaluates an expression and returns the computed value. If the
// function returns `None`, there was an error in the expression and
// it won't get computed ever again. The log will have a message
// indicating what the error was.

pub fn eval(
    e: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match e {
        Expr::Nothing => None,

        // Literals hold actual `device::Values`, so simply return it.
        Expr::Lit(v) => Some(v.clone()),

        Expr::Var(n) => eval_as_var(*n, inp),

        Expr::TimeVal(Zone::Utc, field) => Some(field.project(&time.0)),

        Expr::TimeVal(Zone::Local, field) => Some(field.project(&time.1)),

        Expr::SolarVal(field) => solar.map(|v| field.project(v)),

        Expr::Not(e) => eval_as_not_expr(e, inp, time, solar),

        Expr::Or(a, b) => eval_as_or_expr(a, b, inp, time, solar),

        Expr::And(a, b) => eval_as_and_expr(a, b, inp, time, solar),

        Expr::Eq(a, b) => eval_as_eq_expr(a, b, inp, time, solar),

        Expr::Lt(a, b) => eval_as_lt_expr(a, b, inp, time, solar),

        Expr::LtEq(a, b) => eval_as_lteq_expr(a, b, inp, time, solar),

        Expr::Add(a, b) => eval_as_add_expr(a, b, inp, time, solar),

        Expr::Sub(a, b) => eval_as_sub_expr(a, b, inp, time, solar),

        Expr::Mul(a, b) => eval_as_mul_expr(a, b, inp, time, solar),

        Expr::Div(a, b) => eval_as_div_expr(a, b, inp, time, solar),

        Expr::Rem(a, b) => eval_as_rem_expr(a, b, inp, time, solar),

        Expr::If(a, b, c) => eval_as_if_expr(a, b, c, inp, time, solar),
    }
}

// Returns the latest value of the variable.

fn eval_as_var(
    idx: usize,
    inp: &[Option<device::Value>],
) -> Option<device::Value> {
    inp[idx].clone()
}

// Evaluates the subexpression of a NOT expression. It only accepts
// booleans as values and simply complements the value.

fn eval_as_not_expr(
    e: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match eval(e, inp, time, solar) {
        Some(device::Value::Bool(v)) => Some(device::Value::Bool(!v)),
        Some(v) => {
            error!("NOT expression contains non-boolean value : {}", &v);
            None
        }
        None => None,
    }
}

// OR expressions. If the first subexpression is `true`, the second
// subexpression isn't evaluated.
fn eval_as_or_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match eval(a, inp, time, solar) {
        v @ Some(device::Value::Bool(true)) => v,
        Some(device::Value::Bool(false)) => {
            match eval(b, inp, time, solar) {
                v @ Some(device::Value::Bool(_)) => v,
                Some(v) => {
                    error!("OR expression contains non-boolean, second argument: {}", &v);
                    None
                }
                None => None,
            }
        }
        Some(v) => {
            error!(
                "OR expression contains non-boolean, first argument: {}",
                &v
            );
            None
        }
        None => {
            match eval(b, inp, time, solar) {
                v @ Some(device::Value::Bool(true)) => v,
                Some(device::Value::Bool(false)) | None => None,
                Some(v) => {
                    error!("OR expression contains non-boolean, second argument: {}", &v);
                    None
                }
            }
        }
    }
}

// AND expressions. If the first subexpression is `false`, the second
// subexpression isn't evaluated.
fn eval_as_and_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match eval(a, inp, time, solar) {
        v @ Some(device::Value::Bool(false)) => v,
        Some(device::Value::Bool(true)) => {
            match eval(b, inp, time, solar) {
                v @ Some(device::Value::Bool(_)) => v,
                Some(v) => {
                    error!("AND expression contains non-boolean, second argument: {}", &v);
                    None
                }
                None => None,
            }
        }
        Some(v) => {
            error!(
                "AND expression contains non-boolean, first argument: {}",
                &v
            );
            None
        }
        None => {
            match eval(b, inp, time, solar) {
                v @ Some(device::Value::Bool(false)) => v,
                Some(device::Value::Bool(true)) | None => None,
                Some(v) => {
                    error!("AND expression contains non-boolean, second argument: {}", &v);
                    None
                }
            }
        }
    }
}

// EQ expressions. Both expressions must be of the same type.
fn eval_as_eq_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Bool(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Bool(a == b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a == b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool(a == b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool(a as f64 == b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a == b as f64))
        }
        (Some(device::Value::Str(a)), Some(device::Value::Str(b))) => {
            Some(device::Value::Bool(a == b))
        }
        (Some(a), Some(b)) => {
            error!("cannot compare {} and {} for equality", &a, &b);
            None
        }
        _ => None,
    }
}

// LT expressions. Both expressions must be of the same type.
fn eval_as_lt_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a < b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool(a < b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool((a as f64) < b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a < b as f64))
        }
        (Some(device::Value::Str(a)), Some(device::Value::Str(b))) => {
            Some(device::Value::Bool(a < b))
        }
        (Some(a), Some(b)) => {
            error!("cannot compare {} and {} for order", &a, &b);
            None
        }
        _ => None,
    }
}

// LT_EQ expressions. Both expressions must be of the same type.
fn eval_as_lteq_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a <= b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool(a <= b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Bool((a as f64) <= b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Bool(a <= b as f64))
        }
        (Some(device::Value::Str(a)), Some(device::Value::Str(b))) => {
            Some(device::Value::Bool(a <= b))
        }
        (Some(a), Some(b)) => {
            error!("cannot compare {} and {} for order", &a, &b);
            None
        }
        _ => None,
    }
}

// ADD expressions.
fn eval_as_add_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a + b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a as i32 + b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Int(a + b as i32))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a + b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a as u8 as f64 + b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Flt(a + b as u8 as f64))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt((a as f64) + b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Flt(a + b as f64))
        }
        (Some(a), Some(b)) => {
            error!("cannot add {} and {} types together", &a, &b);
            None
        }
        _ => None,
    }
}

// SUB expressions.
fn eval_as_sub_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a - b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a as i32 - b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Int(a - b as i32))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a - b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a as u8 as f64 - b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Flt(a - b as u8 as f64))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt((a as f64) - b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Flt(a - b as f64))
        }
        (Some(a), Some(b)) => {
            error!("cannot subtract {} and {} types together", &a, &b);
            None
        }
        _ => None,
    }
}

// MUL expressions.
fn eval_as_mul_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a * b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Int(a as i32 * b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Int(a * b as i32))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a * b))
        }
        (Some(device::Value::Bool(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt(a as u8 as f64 * b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Bool(b))) => {
            Some(device::Value::Flt(a * b as u8 as f64))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b))) => {
            Some(device::Value::Flt((a as f64) * b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) => {
            Some(device::Value::Flt(a * b as f64))
        }
        (Some(a), Some(b)) => {
            error!("cannot multiply {} and {} types together", &a, &b);
            None
        }
        _ => None,
    }
}

// DIV expressions.
fn eval_as_div_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b)))
            if b != 0 =>
        {
            Some(device::Value::Int(a / b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b)))
            if b != 0.0 =>
        {
            Some(device::Value::Flt(a / b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b)))
            if b != 0.0 =>
        {
            Some(device::Value::Flt((a as f64) / b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b)))
            if b != 0 =>
        {
            Some(device::Value::Flt(a / b as f64))
        }
        (Some(a), Some(b)) => {
            error!("cannot divide {} by {}", &a, &b);
            None
        }
        _ => None,
    }
}

// REM expressions.
fn eval_as_rem_expr(
    a: &Expr,
    b: &Expr,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match (eval(a, inp, time, solar), eval(b, inp, time, solar)) {
        (Some(device::Value::Int(a)), Some(device::Value::Int(b))) if b > 0 => {
            Some(device::Value::Int(a % b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Flt(b)))
            if b > 0.0 =>
        {
            Some(device::Value::Flt(a % b))
        }
        (Some(device::Value::Int(a)), Some(device::Value::Flt(b)))
            if b > 0.0 =>
        {
            Some(device::Value::Flt((a as f64) % b))
        }
        (Some(device::Value::Flt(a)), Some(device::Value::Int(b))) if b > 0 => {
            Some(device::Value::Flt(a % b as f64))
        }
        (Some(a), Some(b)) => {
            error!("cannot compute remainder of {} from {}", &b, &a);
            None
        }
        _ => None,
    }
}

fn eval_as_if_expr(
    a: &Expr,
    b: &Expr,
    c: &Option<Box<Expr>>,
    inp: &[Option<device::Value>],
    time: &tod::Info,
    solar: Option<&solar::Info>,
) -> Option<device::Value> {
    match eval(a, inp, time, solar) {
        Some(device::Value::Bool(v)) => {
            if v {
                eval(b, inp, time, solar)
            } else {
                c.as_ref().and_then(|v| eval(v, inp, time, solar))
            }
        }
        Some(v) => {
            error!("IF condition didn't evaluate to boolean value: {}", &v);
            None
        }
        None => None,
    }
}

// This function takes an expression and tries to reduce it.

pub fn optimize(e: Expr) -> Expr {
    match &e {
        // Look for optimizations with expressions starting with NOT.
        Expr::Not(ne) => match &**ne {
            // If the sub-expression is also a NOT expression. If so,
            // we throw them both away.
            Expr::Not(e) => optimize(*e.clone()),

            // If the subexpression is either `true` or `false`,
            // return the complement.
            Expr::Lit(device::Value::Bool(val)) => {
                Expr::Lit(device::Value::Bool(!val))
            }
            _ => e,
        },

        Expr::And(a, b) => match (optimize(*a.clone()), optimize(*b.clone())) {
            (v @ Expr::Lit(device::Value::Bool(false)), _)
            | (_, v @ Expr::Lit(device::Value::Bool(false))) => v,
            (Expr::Lit(device::Value::Bool(true)), e)
            | (e, Expr::Lit(device::Value::Bool(true))) => e,
            _ => e,
        },

        Expr::Or(a, b) => match (optimize(*a.clone()), optimize(*b.clone())) {
            (v @ Expr::Lit(device::Value::Bool(true)), _)
            | (_, v @ Expr::Lit(device::Value::Bool(true))) => v,
            (Expr::Lit(device::Value::Bool(false)), e)
            | (e, Expr::Lit(device::Value::Bool(false))) => e,
            _ => e,
        },

        Expr::If(a, b, c) => {
            let condition = optimize(*a.clone());

            match condition {
                Expr::Nothing => Expr::Nothing,
                Expr::Lit(device::Value::Bool(true)) => optimize(*b.clone()),
                Expr::Lit(device::Value::Bool(false)) => {
                    c.clone().map(|v| optimize(*v)).unwrap_or(Expr::Nothing)
                }
                _ => Expr::If(
                    Box::new(condition),
                    Box::new(optimize(*b.clone())),
                    c.clone().map(|v| Box::new(optimize(*v))),
                ),
            }
        }

        _ => e,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use drmem_api::device;
    use palette::LinSrgba;
    use std::sync::Arc;

    fn to_expr(expr: &str) -> Expr {
        let env: Env = (
            &[String::from("a"), String::from("b")],
            &[String::from("c")],
        );

        match Program::compile(&format!("{} -> {{c}}", expr), &env) {
            Ok(Program(expr, _)) => expr,
            Err(_) => panic!("couldn't parse {}", expr),
        }
    }

    #[test]
    fn test_parser() {
        let env: Env = (
            &[String::from("switch"), String::from("on_time")],
            &[String::from("bulb")],
        );

        const BAD_EXPR: &[&str] = &[
            "",
            "{switch -> {bulb}",
            "switch} -> {bulb}",
            // Don't allow bad categories or fields.
            "{bad:second} -> {bulb}",
            "{utc:bad} -> {bulb}",
            "{local:bad} -> {bulb}",
            // Don't allow whitespace.
            "{ switch} -> {bulb}",
            "{switch } -> {bulb}",
            "{ utc:second} -> {bulb}",
            "{utc :second} -> {bulb}",
            "{utc: second} -> {bulb}",
            "{utc:second } -> {bulb}",
            "#1 -> {bulb}",
            "#12 -> {bulb}",
            "#12345 -> {bulb}",
        ];

        for entry in BAD_EXPR.iter() {
            assert!(
                Program::compile(entry, &env).is_err(),
                "accepted {}",
                entry
            );
        }

        const GOOD_EXPR: &[&str] = &[
            // Test for defined categories and fields.
            "{utc:second} -> {bulb}",
            "{utc:minute} -> {bulb}",
            "{utc:hour} -> {bulb}",
            "{utc:day} -> {bulb}",
            "{utc:month} -> {bulb}",
            "{utc:EOM} -> {bulb}",
            "{utc:SOM} -> {bulb}",
            "{utc:year} -> {bulb}",
            "{utc:DOW} -> {bulb}",
            "{utc:DOY} -> {bulb}",
            "{utc:LY} -> {bulb}",
            "{local:second} -> {bulb}",
            "{local:minute} -> {bulb}",
            "{local:hour} -> {bulb}",
            "{local:day} -> {bulb}",
            "{local:month} -> {bulb}",
            "{local:EOM} -> {bulb}",
            "{local:SOM} -> {bulb}",
            "{local:year} -> {bulb}",
            "{local:DOW} -> {bulb}",
            "{local:DOY} -> {bulb}",
            "{local:LY} -> {bulb}",
            "{solar:alt} -> {bulb}",
            "{solar:az} -> {bulb}",
            "{solar:ra} -> {bulb}",
            "{solar:dec} -> {bulb}",
        ];

        for entry in GOOD_EXPR.iter() {
            assert!(
                Program::compile(entry, &env).is_ok(),
                "rejected {}",
                entry
            );
        }

        // Test proper compilations.

        let good_comp: &[(&str, Program)] = &[
            ("{switch} -> {bulb}", Program(Expr::Var(0), 0)),
            (
                "true -> {bulb}",
                Program(Expr::Lit(device::Value::Bool(true)), 0),
            ),
            (
                "false -> {bulb}",
                Program(Expr::Lit(device::Value::Bool(false)), 0),
            ),
            ("1 -> {bulb}", Program(Expr::Lit(device::Value::Int(1)), 0)),
            (
                "1. -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(1.0)), 0),
            ),
            (
                "1.0 -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(1.0)), 0),
            ),
            (
                "-1.0 -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(-1.0)), 0),
            ),
            (
                "1.5 -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(1.5)), 0),
            ),
            (
                "1.0e10 -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(1.0e10)), 0),
            ),
            (
                "2.75e-10 -> {bulb}",
                Program(Expr::Lit(device::Value::Flt(2.75e-10)), 0),
            ),
            (
                "(((10))) -> {bulb}",
                Program(Expr::Lit(device::Value::Int(10)), 0),
            ),
            (
                "#123 -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        0x11, 0x22, 0x33, 255,
                    ))),
                    0,
                ),
            ),
            (
                "#1234 -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        0x11, 0x22, 0x33, 0x44,
                    ))),
                    0,
                ),
            ),
            (
                "#7f8081 -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        127, 128, 129, 255,
                    ))),
                    0,
                ),
            ),
            (
                "#7f808182 -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        127, 128, 129, 130,
                    ))),
                    0,
                ),
            ),
            (
                "#7F80A0 -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        127, 128, 160, 255,
                    ))),
                    0,
                ),
            ),
            (
                "#black -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Color(LinSrgba::new(
                        0, 0, 0, 255,
                    ))),
                    0,
                ),
            ),
            (
                "if true then 1.0 else 0.0 end -> {bulb}",
                Program(
                    Expr::If(
                        Box::new(Expr::Lit(device::Value::Bool(true))),
                        Box::new(Expr::Lit(device::Value::Flt(1.0))),
                        Some(Box::new(Expr::Lit(device::Value::Flt(0.0)))),
                    ),
                    0,
                ),
            ),
            (
                "if 10.0 < 0.0 then 1.0 else 0.0 end -> {bulb}",
                Program(
                    Expr::If(
                        Box::new(Expr::Lt(
                            Box::new(Expr::Lit(device::Value::Flt(10.0))),
                            Box::new(Expr::Lit(device::Value::Flt(0.0))),
                        )),
                        Box::new(Expr::Lit(device::Value::Flt(1.0))),
                        Some(Box::new(Expr::Lit(device::Value::Flt(0.0)))),
                    ),
                    0,
                ),
            ),
            (
                "{on_time} > 10.0 -> {bulb}",
                Program(
                    Expr::Lt(
                        Box::new(Expr::Lit(device::Value::Flt(10.0))),
                        Box::new(Expr::Var(1)),
                    ),
                    0,
                ),
            ),
            (
                "4 + ({on_time} + 5) * 10 > 10.0 % 3 -> {bulb}",
                Program(
                    Expr::Lt(
                        Box::new(Expr::Rem(
                            Box::new(Expr::Lit(device::Value::Flt(10.0))),
                            Box::new(Expr::Lit(device::Value::Int(3))),
                        )),
                        Box::new(Expr::Add(
                            Box::new(Expr::Lit(device::Value::Int(4))),
                            Box::new(Expr::Mul(
                                Box::new(Expr::Add(
                                    Box::new(Expr::Var(1)),
                                    Box::new(Expr::Lit(device::Value::Int(5))),
                                )),
                                Box::new(Expr::Lit(device::Value::Int(10))),
                            )),
                        )),
                    ),
                    0,
                ),
            ),
            (
                "true and false or false and true -> {bulb}",
                Program(
                    Expr::Or(
                        Box::new(Expr::And(
                            Box::new(Expr::Lit(device::Value::Bool(true))),
                            Box::new(Expr::Lit(device::Value::Bool(false))),
                        )),
                        Box::new(Expr::And(
                            Box::new(Expr::Lit(device::Value::Bool(false))),
                            Box::new(Expr::Lit(device::Value::Bool(true))),
                        )),
                    ),
                    0,
                ),
            ),
            (
                "true and (5 < 7 or true) -> {bulb}",
                Program(
                    Expr::And(
                        Box::new(Expr::Lit(device::Value::Bool(true))),
                        Box::new(Expr::Or(
                            Box::new(Expr::Lt(
                                Box::new(Expr::Lit(device::Value::Int(5))),
                                Box::new(Expr::Lit(device::Value::Int(7))),
                            )),
                            Box::new(Expr::Lit(device::Value::Bool(true))),
                        )),
                    ),
                    0,
                ),
            ),
            (
                "\"Hello, world!\" -> {bulb}",
                Program(
                    Expr::Lit(device::Value::Str("Hello, world!".into())),
                    0,
                ),
            ),
        ];

        for entry in good_comp {
            assert_eq!(Program::compile(entry.0, &env).unwrap(), entry.1);
        }
    }

    #[test]
    fn test_eval_not_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 1],
            Option<device::Value>,
        )] = &[
            // Test for uninitialized and initialized variables.
            (Expr::Not(Box::new(Expr::Var(0))), [None], None),
            (
                Expr::Not(Box::new(Expr::Var(0))),
                [Some(device::Value::Bool(true))],
                Some(device::Value::Bool(false)),
            ),
            // Test literal values.
            (Expr::Not(Box::new(Expr::Lit(FALSE))), [None], Some(TRUE)),
            (Expr::Not(Box::new(Expr::Lit(TRUE))), [None], Some(FALSE)),
            // Test incorrect types.
            (
                Expr::Not(Box::new(Expr::Lit(device::Value::Int(1)))),
                [None],
                None,
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_or_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 2],
            Option<device::Value>,
        )] = &[
            // Test uninitialized and initialized variables.
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), Some(FALSE)],
                Some(FALSE),
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), Some(TRUE)],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(TRUE), Some(FALSE)],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(TRUE), None],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), None],
                None,
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [None, Some(TRUE)],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [None, Some(FALSE)],
                None,
            ),
            // Test literal values.
            (
                Expr::Or(
                    Box::new(Expr::Lit(FALSE)),
                    Box::new(Expr::Lit(FALSE)),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Or(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(FALSE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Lit(FALSE)), Box::new(Expr::Lit(TRUE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Or(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(TRUE))),
                [None, None],
                Some(TRUE),
            ),
            // Test invalid types.
            (
                Expr::Or(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TRUE))),
                [None, None],
                None,
            ),
            (
                Expr::Or(Box::new(Expr::Lit(FALSE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                None,
            ),
            // This is a loophole for expression errors. If the first
            // subexpression is `true`, we don't evaluate the second
            // so we won't catch type errors until the first
            // subexpression is `false`.
            (
                Expr::Or(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(TRUE),
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_and_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 2],
            Option<device::Value>,
        )] = &[
            // Test uninitialized and initialized variables.
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), Some(FALSE)],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), Some(TRUE)],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(TRUE), Some(FALSE)],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(TRUE), Some(TRUE)],
                Some(TRUE),
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(TRUE), None],
                None,
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [Some(FALSE), None],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [None, Some(TRUE)],
                None,
            ),
            (
                Expr::And(Box::new(Expr::Var(0)), Box::new(Expr::Var(1))),
                [None, Some(FALSE)],
                Some(FALSE),
            ),
            // Test literal values.
            (
                Expr::And(
                    Box::new(Expr::Lit(FALSE)),
                    Box::new(Expr::Lit(FALSE)),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::And(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FALSE)),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::And(
                    Box::new(Expr::Lit(FALSE)),
                    Box::new(Expr::Lit(TRUE)),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(TRUE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::And(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TRUE))),
                [None, None],
                None,
            ),
            // This is a loophole for expression errors. If the first
            // subexpression is `false`, we don't evaluate the second
            // so we won't catch type errors until the first
            // subexpression is `true`.
            (
                Expr::And(Box::new(Expr::Lit(FALSE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::And(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                None,
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_eq_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 2],
            Option<device::Value>,
        )] = &[
            (
                Expr::Eq(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Eq(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Eq(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(FP_ONE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Eq(Box::new(Expr::Lit(FP_ONE)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Eq(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(FALSE))),
                [None, None],
                None,
            ),
            (
                Expr::Eq(
                    Box::new(Expr::Lit(device::Value::Str("same".into()))),
                    Box::new(Expr::Lit(device::Value::Str("same".into()))),
                ),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Eq(
                    Box::new(Expr::Lit(device::Value::Str("same".into()))),
                    Box::new(Expr::Lit(device::Value::Str("not same".into()))),
                ),
                [None, None],
                Some(FALSE),
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_lt_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 2],
            Option<device::Value>,
        )] = &[
            (
                Expr::Lt(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(FALSE))),
                [None, None],
                None,
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(FP_ONE))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(FP_ONE))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Lt(Box::new(Expr::Lit(FP_ONE)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::Lt(
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::Lt(
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                    Box::new(Expr::Lit(device::Value::Str("abcd".into()))),
                ),
                [None, None],
                Some(TRUE),
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_lteq_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        let test_data: &[(
            Expr,
            [Option<device::Value>; 2],
            Option<device::Value>,
        )] = &[
            (
                Expr::LtEq(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::LtEq(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::LtEq(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TWO))),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE)),
                ),
                [None, None],
                None,
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FP_ONE)),
                ),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ONE)),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(TWO)),
                ),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(device::Value::Str("abcd".into()))),
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                ),
                [None, None],
                Some(FALSE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                ),
                [None, None],
                Some(TRUE),
            ),
            (
                Expr::LtEq(
                    Box::new(Expr::Lit(device::Value::Str("abc".into()))),
                    Box::new(Expr::Lit(device::Value::Str("abcd".into()))),
                ),
                [None, None],
                Some(TRUE),
            ),
        ];

        for entry in test_data {
            assert_eq!(
                eval(&entry.0, &entry.1, &time, None),
                entry.2,
                "expression '{}' failed",
                &entry.0
            )
        }
    }

    #[test]
    fn test_eval_add_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        const FP_TWO: device::Value = device::Value::Flt(2.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(
            eval(
                &Expr::Add(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(3))
        );
        assert_eq!(
            eval(
                &Expr::Add(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(2))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(1))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(3.0))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(3.0))
        );
        assert_eq!(
            eval(
                &Expr::Add(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(3.0))
        );
    }

    #[test]
    fn test_eval_sub_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        const FP_TWO: device::Value = device::Value::Flt(2.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(
            eval(
                &Expr::Sub(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(1))
        );
        assert_eq!(
            eval(
                &Expr::Sub(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(0))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(1))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(0.0))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Sub(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
    }

    #[test]
    fn test_eval_mul_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        const FP_TWO: device::Value = device::Value::Flt(2.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(
            eval(
                &Expr::Mul(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(2))
        );
        assert_eq!(
            eval(
                &Expr::Mul(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(1))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(0))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(0.0))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Mul(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
    }

    #[test]
    fn test_eval_div_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ZERO: device::Value = device::Value::Int(0);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ZERO: device::Value = device::Value::Flt(0.0);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        const FP_TWO: device::Value = device::Value::Flt(2.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(
            eval(
                &Expr::Div(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(2))
        );
        assert_eq!(
            eval(
                &Expr::Div(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            eval(
                &Expr::Div(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ZERO))),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Div(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
    }

    #[test]
    fn test_eval_rem_expr() {
        const TRUE: device::Value = device::Value::Bool(true);
        const FALSE: device::Value = device::Value::Bool(false);
        const ZERO: device::Value = device::Value::Int(0);
        const NEG_ONE: device::Value = device::Value::Int(-1);
        const ONE: device::Value = device::Value::Int(1);
        const TWO: device::Value = device::Value::Int(2);
        const FP_ZERO: device::Value = device::Value::Flt(0.0);
        const FP_ONE: device::Value = device::Value::Flt(1.0);
        const FP_TWO: device::Value = device::Value::Flt(2.0);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(
            eval(
                &Expr::Rem(Box::new(Expr::Lit(ONE)), Box::new(Expr::Lit(TWO))),
                &[],
                &time,
                None
            ),
            Some(device::Value::Int(1))
        );
        assert_eq!(
            eval(
                &Expr::Rem(Box::new(Expr::Lit(TRUE)), Box::new(Expr::Lit(ONE))),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FP_TWO))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(TRUE)),
                    Box::new(Expr::Lit(FP_ONE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(FALSE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(FP_ONE)),
                    Box::new(Expr::Lit(TWO))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(ONE)),
                    Box::new(Expr::Lit(FP_TWO))
                ),
                &[],
                &time,
                None
            ),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            eval(
                &Expr::Rem(Box::new(Expr::Lit(TWO)), Box::new(Expr::Lit(ZERO))),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(FP_ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(FP_TWO)),
                    Box::new(Expr::Lit(FP_ZERO))
                ),
                &[],
                &time,
                None
            ),
            None
        );
        assert_eq!(
            eval(
                &Expr::Rem(
                    Box::new(Expr::Lit(TWO)),
                    Box::new(Expr::Lit(NEG_ONE))
                ),
                &[],
                &time,
                None
            ),
            None
        );
    }

    #[test]
    fn test_eval() {
        const FALSE: device::Value = device::Value::Bool(false);
        let time = Arc::new((chrono::Utc::now(), chrono::Local::now()));

        assert_eq!(eval(&Expr::Lit(FALSE), &[], &time, None), Some(FALSE));
    }

    // This function tests the optimizations that can be done on an
    // expression.

    #[test]
    fn test_not_optimizer() {
        assert_eq!(
            optimize(Expr::Not(Box::new(Expr::Lit(device::Value::Bool(true))))),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::Not(Box::new(Expr::Lit(device::Value::Bool(
                false
            ))))),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Not(Box::new(Expr::Not(Box::new(Expr::Lit(
                device::Value::Bool(true)
            )))))),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Not(Box::new(Expr::Not(Box::new(Expr::Not(
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )))))),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::Not(Box::new(Expr::Not(Box::new(Expr::Not(
                Box::new(Expr::Not(Box::new(Expr::Lit(device::Value::Bool(
                    true
                )))))
            )))))),
            Expr::Lit(device::Value::Bool(true))
        );
    }

    #[test]
    fn test_and_optimizer() {
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Str("test".into())))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Str("test".into())))
            )),
            Expr::Lit(device::Value::Str("test".into()))
        );

        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::And(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                ))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::And(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                )),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );

        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::And(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(false)))
                ))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::And(
                Box::new(Expr::And(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                )),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
    }

    #[test]
    fn test_or_optimizer() {
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Str("test".into())))
            )),
            Expr::Lit(device::Value::Str("test".into()))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Str("test".into())))
            )),
            Expr::Lit(device::Value::Bool(true))
        );

        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Or(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                ))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Or(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                )),
                Box::new(Expr::Lit(device::Value::Bool(true)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );

        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Or(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(false)))
                ))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Or(
                    Box::new(Expr::Lit(device::Value::Bool(true))),
                    Box::new(Expr::Lit(device::Value::Bool(true)))
                )),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(true))
        );
        assert_eq!(
            optimize(Expr::Or(
                Box::new(Expr::Or(
                    Box::new(Expr::Lit(device::Value::Bool(false))),
                    Box::new(Expr::Lit(device::Value::Bool(false)))
                )),
                Box::new(Expr::Lit(device::Value::Bool(false)))
            )),
            Expr::Lit(device::Value::Bool(false))
        );
    }

    #[test]
    fn test_if_optimizer() {
        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                Some(Box::new(Expr::Lit(device::Value::Flt(2.0))))
            )),
            Expr::Lit(device::Value::Flt(1.0))
        );

        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                Some(Box::new(Expr::Lit(device::Value::Flt(2.0))))
            )),
            Expr::Lit(device::Value::Flt(2.0))
        );

        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Lit(device::Value::Bool(true))),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                None
            )),
            Expr::Lit(device::Value::Flt(1.0))
        );

        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Lit(device::Value::Bool(false))),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                None
            )),
            Expr::Nothing
        );

        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Nothing),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                None
            )),
            Expr::Nothing
        );

        assert_eq!(
            optimize(Expr::If(
                Box::new(Expr::Nothing),
                Box::new(Expr::Lit(device::Value::Flt(1.0))),
                Some(Box::new(Expr::Lit(device::Value::Flt(2.0))))
            )),
            Expr::Nothing
        );
    }

    #[test]
    fn test_to_string() {
        let env: Env = (
            &[String::from("a"), String::from("b")],
            &[String::from("b"), String::from("c")],
        );

        const TESTS: &[(&str, &str)] = &[
            ("{a} -> {b}", "inp[0] -> out[0]"),
            ("true -> {b}", "true -> out[0]"),
            ("not true -> {b}", "not true -> out[0]"),
            ("{a} and {b} -> {c}", "inp[0] and inp[1] -> out[1]"),
            ("{a} or {b} -> {c}", "inp[0] or inp[1] -> out[1]"),
            (
                "{a} and {b} or true -> {c}",
                "inp[0] and inp[1] or true -> out[1]",
            ),
            (
                "{a} and ({b} or true) -> {c}",
                "inp[0] and (inp[1] or true) -> out[1]",
            ),
            ("{a} = {b} -> {c}", "inp[0] = inp[1] -> out[1]"),
            ("{a} < {b} -> {c}", "inp[0] < inp[1] -> out[1]"),
            ("{a} <= {b} -> {c}", "inp[0] <= inp[1] -> out[1]"),
            ("{a} + {b} -> {c}", "inp[0] + inp[1] -> out[1]"),
            (
                "{a} + {b} + {b} -> {c}",
                "inp[0] + inp[1] + inp[1] -> out[1]",
            ),
            ("{a} - {b} -> {c}", "inp[0] - inp[1] -> out[1]"),
            ("{a} * {b} -> {c}", "inp[0] * inp[1] -> out[1]"),
            ("{a} / {b} -> {c}", "inp[0] / inp[1] -> out[1]"),
            ("{a} % {b} -> {c}", "inp[0] % inp[1] -> out[1]"),
            (
                "{a} * 3 + {b} > 4 -> {c}",
                "4 < inp[0] * 3 + inp[1] -> out[1]",
            ),
            (
                "{a} * (3 + {b}) > 4 -> {c}",
                "4 < inp[0] * (3 + inp[1]) -> out[1]",
            ),
            ("{utc:second} -> {c}", "{utc:second} -> out[1]"),
            ("{utc:minute} -> {c}", "{utc:minute} -> out[1]"),
            ("{utc:hour} -> {c}", "{utc:hour} -> out[1]"),
            ("{utc:day} -> {c}", "{utc:day} -> out[1]"),
            ("{utc:month} -> {c}", "{utc:month} -> out[1]"),
            ("{utc:EOM} -> {c}", "{utc:EOM} -> out[1]"),
            ("{utc:SOM} -> {c}", "{utc:SOM} -> out[1]"),
            ("{utc:year} -> {c}", "{utc:year} -> out[1]"),
            ("{utc:DOW} -> {c}", "{utc:DOW} -> out[1]"),
            ("{utc:DOY} -> {c}", "{utc:DOY} -> out[1]"),
            ("{local:second} -> {c}", "{local:second} -> out[1]"),
            ("{local:minute} -> {c}", "{local:minute} -> out[1]"),
            ("{local:hour} -> {c}", "{local:hour} -> out[1]"),
            ("{local:day} -> {c}", "{local:day} -> out[1]"),
            ("{local:month} -> {c}", "{local:month} -> out[1]"),
            ("{local:EOM} -> {c}", "{local:EOM} -> out[1]"),
            ("{local:SOM} -> {c}", "{local:SOM} -> out[1]"),
            ("{local:year} -> {c}", "{local:year} -> out[1]"),
            ("{local:DOW} -> {c}", "{local:DOW} -> out[1]"),
            ("{local:DOY} -> {c}", "{local:DOY} -> out[1]"),
            (
                "if {a} then true else false end -> {c}",
                "if inp[0] then true else false end -> out[1]",
            ),
            (
                "if ({a} > 0.0) then (5 + 3) else false end -> {c}",
                "if 0 < inp[0] then 5 + 3 else false end -> out[1]",
            ),
        ];

        for (in_val, out_val) in TESTS {
            match Program::compile(in_val, &env) {
                Ok(prog) => assert_eq!(
                    prog.to_string(),
                    *out_val,
                    "failed on: {}",
                    in_val
                ),
                Err(e) => panic!("{}", &e),
            }
        }
    }

    fn evaluate(
        expr: &str,
        time: &tod::Info,
        solar: Option<&solar::Info>,
    ) -> Option<device::Value> {
        let env: Env = (&[], &[String::from("a")]);
        let expr = format!("{} -> {{a}}", expr);
        let prog = Program::compile(&expr, &env).unwrap();

        eval(&prog.0, &[], &time, solar)
    }

    #[test]
    fn test_evaluations() {
        use chrono::TimeZone;

        let time = Arc::new((
            chrono::Utc
                .with_ymd_and_hms(2000, 1, 2, 3, 4, 5)
                .single()
                .unwrap(),
            chrono::Local
                .with_ymd_and_hms(2001, 6, 7, 8, 9, 10)
                .single()
                .unwrap(),
        ));

        let solar = Arc::new(solar::SolarInfo {
            elevation: 1.0,
            azimuth: 2.0,
            right_ascension: 3.0,
            declination: 4.0,
        });

        const EXPR_TESTS: &[(&'static str, Option<device::Value>)] = &[
            ("1 / 0", None),
            ("5 > true", None),
            ("1 + 2 * 3", Some(device::Value::Int(7))),
            ("1 + (2 * 3)", Some(device::Value::Int(7))),
            ("1 + 2 < 1 + 3", Some(device::Value::Bool(true))),
            ("1 + 2 < 1 + 1", Some(device::Value::Bool(false))),
            ("1 > 2 or 5 < 3", Some(device::Value::Bool(false))),
            ("1 > 2 or 5 >= 3", Some(device::Value::Bool(true))),
            (
                "if true then 7.0 else 3.0 end",
                Some(device::Value::Flt(7.0)),
            ),
            (
                "IF false THEN 7.0 ELSE 3.0 END",
                Some(device::Value::Flt(3.0)),
            ),
            ("if true then 7.0 end", Some(device::Value::Flt(7.0))),
            ("if false then 7.0 end", None),
            (
                "7.0 - If true Then 7.0 Else 3.0 End",
                Some(device::Value::Flt(0.0)),
            ),
            (
                "7.0 - if false then 7.0 else 3.0 end",
                Some(device::Value::Flt(4.0)),
            ),
            (
                "if true and false then 7.0 else 3.0 end",
                Some(device::Value::Flt(3.0)),
            ),
            (
                "if true or false then 7.0 else 3.0 end",
                Some(device::Value::Flt(7.0)),
            ),
            (
                "if true then if true then 4.0 end else 3.0 end",
                Some(device::Value::Flt(4.0)),
            ),
            ("if true then if false then 4.0 end else 3.0 end", None),
            (
                "if false then \
                    if true then \
                       4.0 \
                    end \
                 else \
                    3.0 \
                 end",
                Some(device::Value::Flt(3.0)),
            ),
            ("{utc:second}", Some(device::Value::Int(5))),
            ("{utc:minute}", Some(device::Value::Int(4))),
            ("{utc:hour}", Some(device::Value::Int(3))),
            ("{utc:day}", Some(device::Value::Int(2))),
            ("{utc:month}", Some(device::Value::Int(1))),
            ("{utc:year}", Some(device::Value::Int(2000))),
            ("{utc:DOW}", Some(device::Value::Int(6))),
            ("{local:second}", Some(device::Value::Int(10))),
            ("{local:minute}", Some(device::Value::Int(9))),
            ("{local:hour}", Some(device::Value::Int(8))),
            ("{local:day}", Some(device::Value::Int(7))),
            ("{local:month}", Some(device::Value::Int(6))),
            ("{local:year}", Some(device::Value::Int(2001))),
            ("{local:DOW}", Some(device::Value::Int(3))),
        ];

        for (expr, result) in EXPR_TESTS {
            assert_eq!(
                evaluate(expr, &time, None),
                result.clone(),
                "error with expression {}",
                expr
            );
        }

        // Verify the solar variables are working correctly.

        assert_eq!(evaluate("{solar:alt}", &time, None), None);
        assert_eq!(evaluate("{solar:az}", &time, None), None);
        assert_eq!(evaluate("{solar:ra}", &time, None), None);
        assert_eq!(evaluate("{solar:dec}", &time, None), None);
        assert_eq!(
            evaluate("{solar:alt}", &time, Some(&solar)),
            Some(device::Value::Flt(1.0))
        );
        assert_eq!(
            evaluate("{solar:az}", &time, Some(&solar)),
            Some(device::Value::Flt(2.0))
        );
        assert_eq!(
            evaluate("{solar:ra}", &time, Some(&solar)),
            Some(device::Value::Flt(3.0))
        );
        assert_eq!(
            evaluate("{solar:dec}", &time, Some(&solar)),
            Some(device::Value::Flt(4.0))
        );

        const LY_TESTS: &[(i32, bool)] = &[
            (1964, true),
            (1996, true),
            (1997, false),
            (1998, false),
            (1999, false),
            (2000, true),
            (2001, false),
            (2002, false),
            (2003, false),
            (2004, true),
            (2096, true),
            (2097, false),
            (2098, false),
            (2099, false),
            (2100, false),
            (2101, false),
            (2102, false),
            (2103, false),
            (2104, true),
        ];

        for (year, is_ly) in LY_TESTS {
            let time = Arc::new((
                chrono::Utc
                    .with_ymd_and_hms(*year, 1, 2, 3, 4, 5)
                    .single()
                    .unwrap(),
                chrono::Local
                    .with_ymd_and_hms(*year, 6, 7, 8, 9, 10)
                    .single()
                    .unwrap(),
            ));

            assert_eq!(
                evaluate("{utc:LY}", &time, None),
                Some(device::Value::Bool(*is_ly)),
                "failed on UTC year {}",
                year
            );
            assert_eq!(
                evaluate("{local:LY}", &time, None),
                Some(device::Value::Bool(*is_ly)),
                "failed on local year {}",
                year
            );
        }

        const DOY_TESTS: &[(i32, u32, u32, i32)] = &[
            (1970, 1, 1, 0),
            (1970, 2, 28, 58),
            (1970, 3, 1, 59),
            (1970, 3, 2, 60),
            (1970, 12, 31, 364),
            (1980, 1, 1, 0),
            (1980, 2, 28, 58),
            (1980, 2, 29, 58),
            (1980, 3, 1, 59),
            (1980, 3, 2, 60),
            (1980, 12, 31, 364),
        ];

        for (year, month, day, doy) in DOY_TESTS {
            let time = Arc::new((
                chrono::Utc
                    .with_ymd_and_hms(*year, *month, *day, 12, 0, 0)
                    .single()
                    .unwrap(),
                chrono::Local
                    .with_ymd_and_hms(*year, *month, *day, 12, 0, 0)
                    .single()
                    .unwrap(),
            ));

            assert_eq!(
                evaluate("{utc:DOY}", &time, None),
                Some(device::Value::Int(*doy)),
                "incorrect DOY for {:02}-{:02}-{:04} UTC",
                *month,
                *day,
                *year
            );
            assert_eq!(
                evaluate("{local:DOY}", &time, None),
                Some(device::Value::Int(*doy)),
                "incorrect DOY for {:02}-{:02}-{:04} LOCAL",
                *month,
                *day,
                *year
            );
        }

        const MON_TESTS: &[(i32, u32, u32, i32, i32)] = &[
            (2025, 6, 1, 1, 5),
            (2025, 3, 1, 1, 5),
            (2025, 3, 2, 1, 5),
            (2025, 3, 7, 1, 4),
            (2025, 3, 8, 2, 4),
            (2025, 3, 24, 4, 2),
            (2025, 3, 25, 4, 1),
        ];

        for (year, month, day, som, eom) in MON_TESTS {
            let time = Arc::new((
                chrono::Utc
                    .with_ymd_and_hms(*year, *month, *day, 12, 0, 0)
                    .single()
                    .unwrap(),
                chrono::Local
                    .with_ymd_and_hms(*year, *month, *day, 12, 0, 0)
                    .single()
                    .unwrap(),
            ));

            assert_eq!(
                evaluate("{utc:SOM}", &time, None),
                Some(device::Value::Int(*som)),
                "incorrect SOM for {:02}-{:02}-{:04} UTC",
                *month,
                *day,
                *year
            );
            assert_eq!(
                evaluate("{local:SOM}", &time, None),
                Some(device::Value::Int(*som)),
                "incorrect SOM for {:02}-{:02}-{:04} LOCAL",
                *month,
                *day,
                *year
            );
            assert_eq!(
                evaluate("{utc:EOM}", &time, None),
                Some(device::Value::Int(*eom)),
                "incorrect EOM for {:02}-{:02}-{:04} UTC",
                *month,
                *day,
                *year
            );
            assert_eq!(
                evaluate("{local:EOM}", &time, None),
                Some(device::Value::Int(*eom)),
                "incorrect EOM for {:02}-{:02}-{:04} LOCAL",
                *month,
                *day,
                *year
            );
        }
    }

    #[test]
    fn test_time_usage() {
        const DATA: &[(&str, Option<tod::TimeField>)] = &[
            // Make sure literals, variables, and solar values don't
            // return a field.
            ("{a}", None),
            ("1", None),
            ("1.0", None),
            ("true", None),
            ("#green", None),
            ("\"test\"", None),
            ("{solar:alt}", None),
            // Make sure the time values return the proper field.
            ("{utc:second}", Some(tod::TimeField::Second)),
            ("{utc:minute}", Some(tod::TimeField::Minute)),
            ("{utc:hour}", Some(tod::TimeField::Hour)),
            ("{utc:day}", Some(tod::TimeField::Day)),
            ("{utc:DOW}", Some(tod::TimeField::Day)),
            ("{utc:DOY}", Some(tod::TimeField::Day)),
            ("{utc:month}", Some(tod::TimeField::Month)),
            ("{utc:EOM}", Some(tod::TimeField::Day)),
            ("{utc:SOM}", Some(tod::TimeField::Day)),
            ("{utc:year}", Some(tod::TimeField::Year)),
            ("{utc:LY}", Some(tod::TimeField::Year)),
            ("{local:second}", Some(tod::TimeField::Second)),
            ("{local:minute}", Some(tod::TimeField::Minute)),
            ("{local:hour}", Some(tod::TimeField::Hour)),
            ("{local:day}", Some(tod::TimeField::Day)),
            ("{local:DOW}", Some(tod::TimeField::Day)),
            ("{local:DOY}", Some(tod::TimeField::Day)),
            ("{local:month}", Some(tod::TimeField::Month)),
            ("{local:EOM}", Some(tod::TimeField::Day)),
            ("{local:SOM}", Some(tod::TimeField::Day)),
            ("{local:year}", Some(tod::TimeField::Year)),
            ("{local:LY}", Some(tod::TimeField::Year)),
            // Now test more complicated expressions to make sure each
            // subtree is correctly compared.
            ("not (2 > 3)", None),
            ("2 + 2", None),
            ("{utc:second} + 2", Some(tod::TimeField::Second)),
            ("2 + {utc:second}", Some(tod::TimeField::Second)),
            ("{local:hour} + {utc:minute}", Some(tod::TimeField::Minute)),
            ("{local:minute} + {utc:day}", Some(tod::TimeField::Minute)),
            // Check the complicated if-statement.
            ("if 5 > 0 then 7 end", None),
            (
                "if {local:minute} > 0 then {local:hour} end",
                Some(tod::TimeField::Minute),
            ),
            (
                "if {local:hour} > 0 then {local:minute} end",
                Some(tod::TimeField::Minute),
            ),
            (
                "if {local:hour} > 0 then {local:minute} else {local:day} end",
                Some(tod::TimeField::Minute),
            ),
            (
                "if {local:minute} > 0 then {local:hour} else {local:day} end",
                Some(tod::TimeField::Minute),
            ),
            (
                "if {local:day} > 0 then {local:hour} else {local:second} end",
                Some(tod::TimeField::Second),
            ),
            (
                "if {local:hour} > 0 then true else {local:day} end",
                Some(tod::TimeField::Hour),
            ),
            (
                "if {local:hour} > 0 then {local:day} else true end",
                Some(tod::TimeField::Hour),
            ),
            (
                "if {local:day} > 0 then true else {local:hour} end",
                Some(tod::TimeField::Hour),
            ),
            (
                "if {local:day} > 0 then {local:hour} else true end",
                Some(tod::TimeField::Hour),
            ),
        ];

        for (expr, result) in DATA {
            assert_eq!(
                &to_expr(expr).uses_time(),
                result,
                "error using {}",
                expr
            );
        }
    }

    #[test]
    fn test_solar_usage() {
        const DATA: &[(&str, bool)] = &[
            // Make sure literals, variables, and time values don't
            // return a field.
            ("{a}", false),
            ("1", false),
            ("1.0", false),
            ("true", false),
            ("#green", false),
            ("\"test\"", false),
            ("{utc:second}", false),
            // Make sure the solar values return true.
            ("{solar:alt}", true),
            ("{solar:dec}", true),
            ("{solar:ra}", true),
            ("{solar:az}", true),
            // Now test more complicated expressions to make sure each
            // subtree is correctly compared.
            ("not (2 > 3)", false),
            ("2 + 2", false),
            ("{solar:alt} + 2", true),
            ("2 + {solar:az}", true),
            ("{solar:dec} + {solar:az}", true),
        ];

        for (expr, result) in DATA {
            assert_eq!(
                &to_expr(expr).uses_solar(),
                result,
                "error using {}",
                expr
            );
        }
    }
}

---
FILE: drmemd/src/logic/mod.rs
use drmem_api::{client, device, driver, Result};
use futures::future::{join_all, pending};
use std::collections::HashMap;
use std::convert::Infallible;
use std::sync::Arc;
use tokio::{
    sync::{broadcast, oneshot, Barrier},
    task::JoinHandle,
};
use tokio_stream::{wrappers::BroadcastStream, StreamExt, StreamMap};
use tracing::{debug, error, info, info_span, warn, Instrument};

use super::config;

mod compile;
pub mod solar;
pub mod tod;

// These are some helpful type aliases.

// The logic node will contain an array of these types. As readings
// come in, they'll be saved in the array.

type Inputs = Option<device::Value>;

// This is a set of streams that returns readings from all input
// devices.

type InputStream = StreamMap<usize, device::DataStream<device::Reading>>;

// Manages settings to a device. It makes sure we don't send duplicate
// settings and it encapsulates the request/reply transaction.

pub struct Output {
    prev: Option<device::Value>,
    chan: driver::TxDeviceSetting,
}

impl Output {
    // Creates a new `Output`. It takes ownership of the provided
    // setting channel and starts with its setting history cleared.

    pub fn create(chan: driver::TxDeviceSetting) -> Self {
        Output { prev: None, chan }
    }

    // Attempts to set the associated device to a new value.

    pub async fn send(&mut self, value: device::Value) -> bool {
        // Only attempt the setting if it is different than the
        // previous setting we sent.

        if let Some(prev) = self.prev.as_ref() {
            if *prev == value {
                return true;
            }
        }

        // Create the reply channel.

        let (tx_rpy, rx_rpy) = oneshot::channel();

        // Send the setting to the driver.

        if let Ok(()) = self.chan.send((value.clone(), tx_rpy)).await {
            match rx_rpy.await {
                Ok(Ok(v)) => {
                    // If the driver adjusted our setting, add a
                    // warning to the log.

                    if v != value {
                        warn!(
                            "driver adjusted setting from {} to {}",
                            &value, &v
                        )
                    }
                    self.prev = Some(value);
                    return true;
                }
                Ok(Err(e)) => error!("driver rejected setting : {}", &e),
                Err(e) => error!("setting failed : {}", &e),
            }
        } else {
            error!("driver not accepting settings")
        }
        false
    }
}

pub struct Node {
    inputs: Vec<Inputs>,
    in_stream: InputStream,
    time_ch: Option<tod::TimeFilter>,
    solar_ch: Option<broadcast::Receiver<solar::Info>>,
    def_exprs: Vec<compile::Program>,
    exprs: Vec<(compile::Program, Output)>,
}

impl Node {
    // Iterate through the input device mapping. As we work through
    // the list, build three things:
    //
    // 1) An array of the variable and definition names.
    //
    // 2) A chained set of streams which provide the readings.
    //
    // 3) An array of `Programs` which store their results in their
    // respective variable location.

    async fn setup_inputs(
        c_req: &client::RequestChan,
        vars: &HashMap<String, device::Name>,
        defs: &HashMap<String, String>,
    ) -> Result<(Vec<String>, InputStream, Vec<compile::Program>)> {
        let mut inputs = Vec::with_capacity(vars.len() + defs.len());
        let mut def_exprs = Vec::with_capacity(defs.len());
        let mut in_stream = StreamMap::with_capacity(vars.len());

        // Iterate through the input variable definitions. This maps
        // an indentifier name with a local, shorter name. For each
        // device, we get a monitor stream and add it to the set.

        for (vv, dev) in vars {
            match c_req.monitor_device(dev.clone(), None, None).await {
                Ok(s) => {
                    // Use the total elements in `inputs` as the
                    // key. As elements are added to the vector, this
                    // value gets incremented. When pulling values
                    // from the StreamMap, the key is returned, which
                    // is also the index in the vector, so we know
                    // which entry to update.

                    in_stream.insert(inputs.len(), s);
                    inputs.push(vv.clone());

                    debug!("inp[{}] = {}", inputs.len(), &dev)
                }
                Err(e) => {
                    error!("error mapping '{}' to '{}': {}", &vv, &dev, &e);
                    return Err(e);
                }
            }
        }

        // Now add the definitions to the vector of inputs (we've
        // already verified the 'defs' names don't conflict with
        // 'inputs' names.)

        for (name, expr) in defs {
            // Add the definition's target name to the list of names.

            inputs.push(name.clone());

            // Compile the expression. The length of the input slice
            // is clipped to the size of the input variables. We do
            // this so we don't include any variables created by
            // definitions. This includes loops (a definition
            // referring to itself) and referring to other defintions
            // (because we can't enforce an order of evaluation.) The
            // "outputs" are also the inputs since `defs` calculate
            // values used by expressions and save their result in an
            // input parameter.

            let env = (&inputs[..vars.len()], &inputs[..]);
            let result = compile::Program::compile(
                &format!("{} -> {{{}}}", &expr, &name),
                &env,
            )
            .map(compile::Program::optimize)?;

            if result.0 == compile::Expr::Nothing {
                warn!("expression '{}' never generates a value", &expr);
            } else {
                debug!("inp[{}] = {}", result.1, &result.0);
            }

            // Add the program to the list of programs.

            def_exprs.push(result);
        }

        Ok((inputs, in_stream, def_exprs))
    }

    async fn setup_outputs(
        c_req: &client::RequestChan,
        vars: &HashMap<String, device::Name>,
    ) -> Result<(Vec<String>, Vec<Output>)> {
        let mut outputs = Vec::with_capacity(vars.len());
        let mut out_chans = Vec::with_capacity(vars.len());

        for (vv, dev) in vars {
            match c_req.get_setting_chan(dev.clone(), false).await {
                Ok(ch) => {
                    // Use the total elements in `inputs` as the
                    // key. As elements are added to the vector, this
                    // value gets incremented. When pulling values
                    // from the StreamMap, the key is returned, which
                    // is also the index in the vector, so we know
                    // which entry to update.

                    out_chans.push(Output::create(ch));
                    outputs.push(vv.clone());

                    debug!("out[{}] controls {}", outputs.len(), &dev)
                }
                Err(e) => {
                    error!("error mapping '{}' to '{}': {}", &vv, &dev, &e);
                    return Err(e);
                }
            }
        }
        Ok((outputs, out_chans))
    }

    // Creates an instance of `Node` and initializes its state using
    // the configuration information.

    async fn init(
        c_req: client::RequestChan,
        c_time: broadcast::Receiver<tod::Info>,
        c_solar: broadcast::Receiver<solar::Info>,
        cfg: config::Logic,
    ) -> Result<Node> {
        debug!("compiling expressions");

        if cfg.exprs.is_empty() {
            return Err(drmem_api::Error::ConfigError(
                "configuration doesn't define any expressions".into(),
            ));
        }

        // Validate the inputs.
        //
        // We add the names of the `inputs` and `defs` variables to a
        // set. If a name is already in the set, we return an error.
        // We add the devices in another set and make sure all are
        // unique.

        {
            use std::collections::HashSet;

            let mut name_set: HashSet<&String> =
                HashSet::with_capacity(cfg.inputs.len() + cfg.defs.len());
            let mut dev_set: HashSet<&device::Name> =
                HashSet::with_capacity(cfg.inputs.len());

            for (ref k, ref v) in &cfg.inputs {
                if !name_set.insert(k) {
                    return Err(drmem_api::Error::ConfigError(format!(
                        "name '{k}' is defined more than once in 'inputs'"
                    )));
                }
                if !dev_set.insert(v) {
                    return Err(drmem_api::Error::ConfigError(format!(
                        "device '{v}' is defined more than once in 'inputs'"
                    )));
                }
            }

            for ref k in cfg.defs.keys() {
                if !name_set.insert(k) {
                    return Err(drmem_api::Error::ConfigError(format!(
                        "'{k}' is defined in 'defs' and 'inputs' sections",
                    )));
                }
            }
        }

        // Validate the outputs.
        //
        // We add the names of the `outputs` variables to a set. If a
        // name is already in the set, we return an error. We add the
        // devices in another set and make sure all are unique.

        {
            use std::collections::HashSet;

            if cfg.outputs.is_empty() {
                return Err(drmem_api::Error::ConfigError(
                    "configuration doesn't define any outputs".into(),
                ));
            }

            let mut name_set: HashSet<&str> =
                HashSet::with_capacity(cfg.outputs.len());
            let mut dev_set: HashSet<&device::Name> =
                HashSet::with_capacity(cfg.outputs.len());

            for (ref k, ref v) in &cfg.outputs {
                if !name_set.insert(k.as_str()) {
                    return Err(drmem_api::Error::ConfigError(format!(
                        "name '{k}' is defined more than once in 'outputs'",
                    )));
                }
                if !dev_set.insert(v) {
                    return Err(drmem_api::Error::ConfigError(format!(
                        "device '{v}' is defined more than once in 'outputs'",
                    )));
                }
            }
        }

        let (inputs, in_stream, def_exprs) =
            Node::setup_inputs(&c_req, &cfg.inputs, &cfg.defs).await?;

        let (outputs, out_chans) =
            Node::setup_outputs(&c_req, &cfg.outputs).await?;

        // Create the input/output environment that the compiler can
        // use to compute the variables in the expression.

        let env = (&inputs[..], &outputs[..]);

        // Iterate through the vector of strings. For each, compile it
        // into a `Program` type. Report the success or failure.

        let exprs: Result<Vec<compile::Program>> = cfg
            .exprs
            .iter()
            .map(|s| {
                compile::Program::compile(s.as_str(), &env)
                    .map(compile::Program::optimize)
            })
            .inspect(|e| match e {
                Ok(ex) => {
                    if ex.0 == compile::Expr::Nothing {
                        warn!(
                            "expression for out[{}] never generates a value",
                            ex.1
                        )
                    } else {
                        debug!("out[{}] = {}", ex.1, &ex.0)
                    }
                }
                Err(e) => error!("{}", &e),
            })
            .collect();
        let mut exprs = exprs?;

        // Sort the expressions based on the index of the outputs.
        // The output variables are in a hash map, so the vector is
        // built in whatever order the map uses. This might not be the
        // same order that the expressions are given. By sorting the
        // expressions, we line them up so they can be zipped together
        // later in this function.
        //
        // XXX: This should be refactored. The parser should return
        // the output variable name instead of an index in the output
        // environment. Then we should go through the expressions, in
        // order, and add the target output to the output vector. This
        // would have two benefits:
        //
        // 1) Even though multiple expressions send their results at
        // roughly the same time, the actual settings would go out
        // quickly in expression order.
        //
        // 2) If the user specified more output variables than
        // expressions that use them, resources wouldn't be allocated
        // for unused output devices.

        exprs[..].sort_unstable_by(
            |compile::Program(_, a), compile::Program(_, b)| a.cmp(b),
        );

        // Look at each expression and see if it needs the
        // time-of-day.

        let needs_time = exprs
            .iter()
            .chain(&def_exprs)
            .filter_map(|compile::Program(e, _)| e.uses_time())
            .min();

        // Look at each expression and see if it needs any solar
        // information.

        let needs_solar = exprs
            .iter()
            .chain(&def_exprs)
            .any(|compile::Program(e, _)| e.uses_solar());

        // Return the initialized `Node`.

        Ok(Node {
            inputs: vec![None; inputs.len()],
            in_stream,
            time_ch: needs_time
                .map(|tf| tod::time_filter(BroadcastStream::new(c_time), tf)),
            solar_ch: if needs_solar { Some(c_solar) } else { None },
            def_exprs,
            exprs: exprs.drain(..).zip(out_chans).collect(),
        })
    }

    // Runs the node logic. This method should never return.

    async fn run(mut self) -> Result<Infallible> {
        let mut time = Arc::new((chrono::Utc::now(), chrono::Local::now()));
        let mut solar = None;

        info!("running");

        loop {
            // Create a future that yields the time-of-day using the
            // TimeFilter. If no expression uses time, then `time_ch`
            // will be `None` and we return a future that never
            // resolves.

            let wait_for_time = async {
                match self.time_ch.as_mut() {
                    None => pending().await,
                    Some(s) => s.next().await,
                }
            };

            // Create a future that yields the next solar update. If
            // no expression uses solar data, `solar_ch` will be
            // `None` and we, instead, return a future that never
            // resolves.

            let wait_for_solar = async {
                match self.solar_ch.as_mut() {
                    None => pending().await,
                    Some(ch) => ch.recv().await,
                }
            };

            #[rustfmt::skip]
	    tokio::select! {
		biased;

		// If we need the solar channel, wait for the next
		// update.

		v = wait_for_solar => {
		    match v {
			Ok(v) => solar = Some(v),
			Err(broadcast::error::RecvError::Lagged(_)) => {
			    warn!("not handling solar info fast enough");
			    continue
			}
			Err(broadcast::error::RecvError::Closed) => {
			    error!("solar info channel is closed");
			    return Err(drmem_api::Error::OperationError(
				"solar channel closed".into()
			    ));
			}
		    }
		}

		// If we need the time channel, wait for the next
		// second.

		Some(v) = wait_for_time => {
		    time = v;
		}

		// Wait for the next reading to arrive. All the
		// incoming streams have been combined into one and
		// the returned value is a pair consisting of an index
		// and the actual reading.

		Some((idx, reading)) = self.in_stream.next() => {
		    // Save the reading in our array for future
		    // recalculations.

		    self.inputs[idx] = Some(reading.value);
		}
	    }

            // Calculate each expression of the `defs` array. Store
            // each expression's result in the associated `input`
            // cell.

            self.def_exprs
                .iter()
                .for_each(|compile::Program(expr, idx)| {
                    self.inputs[*idx] =
                        compile::eval(expr, &self.inputs, &time, solar.as_ref())
                });

            // Calculate each of the final expressions. If there are
            // more than one expressions in this node, they are
            // evaluated concurrently.

            join_all(self.exprs.iter_mut().filter_map(
                |(compile::Program(expr, _), out)| {
                    compile::eval(expr, &self.inputs, &time, solar.as_ref())
                        .map(|v| out.send(v))
                },
            ))
            .await;
        }
    }

    // Starts a new instance of a logic node.

    pub async fn start(
        c_req: client::RequestChan,
        rx_tod: broadcast::Receiver<tod::Info>,
        rx_solar: broadcast::Receiver<solar::Info>,
        cfg: config::Logic,
        barrier: Arc<Barrier>,
    ) -> JoinHandle<Result<Infallible>> {
        let name = cfg.name.clone();

        // Put the node in the background.

        tokio::spawn(
            async move {
                // Create a new instance and let it initialize itself.
                // Hold onto the result -- success or failure -- and
                // handle it after the barrier.

                let node = Node::init(c_req, rx_tod, rx_solar, cfg)
                    .instrument(info_span!("init"))
                    .await;

                // This barrier syncs this tasks with the start-up
                // task. When both wait on the barrier, they both wake
                // up and continue. The start-up task then knows this
                // logic block has registered all the devices, tod,
                // and solar handles it needs.

                barrier.wait().await;

                // Enter the main loop of the logic block.
                //
                // NOTE: We used the '?' operator here instead of the
                // assignment above because we have to wait on the
                // barrier. If we let the '?' operator return before
                // waiting on the barrier, the initialization loop
                // would wait forever.

                node?.run().await
            }
            .instrument(info_span!("logic", name)),
        )
    }
}

#[cfg(test)]
mod test {
    use super::{config, solar, tod, Node};
    use drmem_api::{
        client::{self, Request},
        device, driver, Error, Result,
    };
    use futures::Future;
    use std::{collections::HashMap, sync::Arc, time::Duration};
    use tokio::{
        sync::{broadcast, mpsc, oneshot, Barrier},
        task, time,
    };
    use tokio_stream::{wrappers::ReceiverStream, StreamExt};

    // This type implements an emulator of the DrMem core. It will
    // spin up a logic block using the provided configuration. The
    // unit tests can provide channels to send readings and receive
    // settings and verify correct operation.

    struct Emulator {
        inputs: HashMap<Arc<str>, mpsc::Receiver<device::Value>>,
        outputs: HashMap<Arc<str>, driver::TxDeviceSetting>,
    }

    impl Emulator {
        pub async fn start(
            mut inputs: Vec<(Arc<str>, mpsc::Receiver<device::Value>)>,
            mut outputs: Vec<(Arc<str>, driver::TxDeviceSetting)>,
            cfg: config::Logic,
        ) -> Result<(
            broadcast::Sender<tod::Info>,
            broadcast::Sender<solar::Info>,
            task::JoinHandle<Result<bool>>,
            oneshot::Sender<()>,
        )> {
            Emulator {
                inputs: HashMap::from_iter(inputs.drain(..)),
                outputs: HashMap::from_iter(outputs.drain(..)),
            }
            .launch(cfg)
            .await
        }

        // Launches a logic block with the provided configuration.

        async fn launch(
            mut self,
            cfg: config::Logic,
        ) -> Result<(
            broadcast::Sender<tod::Info>,
            broadcast::Sender<solar::Info>,
            task::JoinHandle<Result<bool>>,
            oneshot::Sender<()>,
        )> {
            // Create the common channels used by DrMem.

            let (tx_req, mut c_recv) = mpsc::channel(100);
            let (tx_tod, _) = broadcast::channel(100);
            let (tx_solar, _) = broadcast::channel(100);

            let barrier = Arc::new(Barrier::new(1));

            // Start the logic block with the proper communciation
            // channels and configuration.

            let node = Node::start(
                client::RequestChan::new(tx_req),
                tx_tod.subscribe(),
                tx_solar.subscribe(),
                cfg,
                barrier,
            )
            .await;

            // Create the 'stop' channel.

            let (tx_stop, rx_stop) = oneshot::channel();

            let emu = task::spawn(async move {
                // The first responsibility is to handle the
                // initialization of the node. This loop iterates
                // through and satisfies the requests made by the
                // node.

                loop {
                    // Did we get a request message? Handle it.

                    if let Some(message) = c_recv.recv().await {
                        match message {
                            Request::GetSettingChan {
                                name, rpy_chan, ..
                            } => {
                                let name = name.to_string();
                                let _ = rpy_chan.send(
                                    if let Some(tx) =
                                        self.outputs.remove(name.as_str())
                                    {
                                        Ok(tx)
                                    } else {
                                        Err(Error::NotFound)
                                    },
                                );
                            }
                            Request::QueryDeviceInfo { rpy_chan, .. } => {
                                let _ = rpy_chan.send(Err(
                                    Error::ProtocolError("bad request".into()),
                                ));
                            }
                            Request::SetDevice { rpy_chan, .. } => {
                                let _ = rpy_chan.send(Err(
                                    Error::ProtocolError("bad request".into()),
                                ));
                            }
                            Request::MonitorDevice {
                                name, rpy_chan, ..
                            } => {
                                let name = name.to_string();
                                let _ = rpy_chan.send(
                                    if let Some(rx) =
					self.inputs.remove(name.as_str())
                                    {
					let stream =
                                            Box::pin(ReceiverStream::new(rx).map(
						|v| device::Reading {
                                                    ts: std::time::SystemTime::now(
                                                    ),
                                                    value: v,
						},
                                            ));

					Ok(stream as device::DataStream<device::Reading,>)
                                    } else {
					Err(Error::NotFound)
                                    }
				);
                            }
                        }
                    }
                    // If the channel returned `None`, then the node
                    // dropped the channel sender (indicating its
                    // initialization is done.) If both hash maps
                    // aren't empty, then the node didn't ask for all
                    // the resources we provided (could be the
                    // configuration was incorrect.) In any case,
                    // return `false`.
                    else if !self.outputs.is_empty()
                        || !self.inputs.is_empty()
                    {
                        return Ok(false);
                    }
                    // All is good. Break out of the loop.
                    else {
                        break;
                    }
                }

                let ah = node.abort_handle();

                #[rustfmt::skip]
                tokio::select! {
		    // Look for the signal from the unit test to tell
		    // us to exit.

                    _ = rx_stop => (),

		    // If the Node exits, it's due to an error. Report
		    // the error.

                    v = node =>
			return match v {
                            Ok(result) => result.map(|_| false),
                            Err(e) => Err(Error::OperationError(
				format!("logic block panicked: {}", &e)
			    ))
			}
                }

                ah.abort();
                Ok(true)
            });

            Ok((tx_tod, tx_solar, emu, tx_stop))
        }
    }

    // Test sending a setting. The settings pass through an Output
    // channel and get debounced.

    #[tokio::test]
    async fn test_send() {
        let (tx, mut rx) = mpsc::channel(10);
        let mut o = super::Output::create(tx);
        let h = task::spawn(async move {
            assert_eq!(o.send(device::Value::Bool(true)).await, true);
            assert_eq!(o.send(device::Value::Bool(true)).await, true);
            assert_eq!(o.send(device::Value::Bool(false)).await, true);
        });

        let (v, tx) = rx.recv().await.unwrap();

        assert_eq!(v, device::Value::Bool(true));
        assert!(tx.send(Ok(v)).is_ok());

        let (v, tx) = rx.recv().await.unwrap();

        assert_eq!(v, device::Value::Bool(false));
        assert!(tx.send(Ok(v)).is_ok());

        h.await.unwrap();
    }

    // Builds a future that will create a node. When awaiting on this
    // future, another task needs to handle potential requests
    // initiated by the node, over the `mpsc_rx` channel. These
    // requests can be monitoring requests for other devices or
    // requests for a setting channel to a device.

    fn init_node(
        cfg: config::Logic,
    ) -> (
        impl Future<Output = Result<Node>>,
        mpsc::Receiver<client::Request>,
        broadcast::Sender<tod::Info>,
        broadcast::Sender<solar::Info>,
    ) {
        let (mpsc_tx, mpsc_rx) = mpsc::channel(10);
        let c_req = client::RequestChan::new(mpsc_tx);
        let (tod_tx, c_time) = broadcast::channel(10);
        let (sol_tx, c_solar) = broadcast::channel(10);
        let node_fut = Node::init(c_req, c_time, c_solar, cfg);

        (node_fut, mpsc_rx, tod_tx, sol_tx)
    }

    // Builds a `config::Logic` type using arrays of config
    // parameters. This is much cleaner than doing it inline and
    // trying to get the final collection types.

    fn build_config(
        inputs: &[(&str, &str)],
        outputs: &[(&str, &str)],
        defs: &[(&str, &str)],
        exprs: &[&str],
    ) -> config::Logic {
        config::Logic {
            name: "test".into(),
            summary: None,
            inputs: inputs
                .iter()
                .map(|&(a, b)| (a.into(), device::Name::create(b).unwrap()))
                .collect(),
            outputs: outputs
                .iter()
                .map(|&(a, b)| (a.into(), device::Name::create(b).unwrap()))
                .collect(),
            defs: defs.iter().map(|&(a, b)| (a.into(), b.into())).collect(),
            exprs: exprs.iter().map(|&a| a.into()).collect(),
        }
    }

    // This tests the initialization of an empty configuration. The
    // main tests are to see if the two broadcast receivers are
    // dropped.

    #[tokio::test]
    async fn test_bad_config() {
        // Test that we reject an empty configuration (mainly because
        // if there are no expressions, there is nothing to do.)

        {
            let cfg = build_config(&[], &[], &[], &[]);
            let (node, _, tod_tx, sol_tx) = init_node(cfg);

            tokio::pin!(node);

            // `await` on the future. This should return immediately
            // as an error because there are no expressions to
            // process.

            assert!(matches!(node.as_mut().await, Err(Error::ConfigError(_))));

            // With no config, the TOD and solar channel handles
            // should have been dropped.

            assert_eq!(tod_tx.receiver_count(), 0);
            assert_eq!(sol_tx.receiver_count(), 0);

            // This call allows us to keep ownership of the node so
            // we're sure the Node dropped the broadcast receivers and
            // not from an early drop of `node` itself.

            std::mem::drop(node);
        }

        // Test that we reject two inputs with the same device.

        {
            let cfg = build_config(
                &[("in", "device:in"), ("in2", "device:in")],
                &[("out", "device:out")],
                &[],
                &["{in} -> {out}"],
            );
            let (node, _, _, _) = init_node(cfg);

            // `await` on the future. This should return immediately
            // as an error because there are no expressions to
            // process.

            assert!(matches!(node.await, Err(Error::ConfigError(_))));
        }

        // Test that we reject an input and a def with the same name.

        {
            let cfg = build_config(
                &[("in", "device:in")],
                &[("out", "device:out")],
                &[("in", "{in}")],
                &["{in} -> {out}"],
            );
            let (node, _, _, _) = init_node(cfg);

            // `await` on the future. This should return immediately
            // as an error because there are no expressions to
            // process.

            assert!(matches!(node.await, Err(Error::ConfigError(_))));
        }

        // Test that we reject two outputs with the same device.

        {
            let cfg = build_config(
                &[("in", "device:in")],
                &[("out", "device:out"), ("out2", "device:out")],
                &[],
                &["{in} -> {out}"],
            );
            let (node, _, _, _) = init_node(cfg);

            // `await` on the future. This should return immediately
            // as an error because there are no expressions to
            // process.

            assert!(matches!(node.await, Err(Error::ConfigError(_))));
        }
    }

    // Test a basic logic block in which an input device's value is
    // forwarded to an output device.

    #[tokio::test]
    async fn test_basic_node() {
        let cfg = build_config(
            &[("in", "device:in")],
            &[("out", "device:out")],
            &[],
            &["{in} -> {out}"],
        );
        let (tx_in, rx_in) = mpsc::channel(100);
        let (tx_out, mut rx_out) = mpsc::channel(100);

        let (_, _, emu, tx_stop) = Emulator::start(
            vec![("device:in".into(), rx_in)],
            vec![("device:out".into(), tx_out)],
            cfg,
        )
        .await
        .unwrap();

        // Send a value and see if it was forwarded.

        assert!(tx_in.send(device::Value::Int(1)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Int(1));

        // Send the same value and see that it wasn't forwarded.

        assert!(tx_in.send(device::Value::Int(1)).await.is_ok());
        assert!(time::timeout(Duration::from_millis(100), rx_out.recv())
            .await
            .is_err());

        // Send a different value and see if it was forwarded.

        assert!(tx_in.send(device::Value::Int(9)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Int(9));

        // Stop the emulator and see that its return status is good.

        let _ = tx_stop.send(());

        assert_eq!(emu.await.unwrap(), Ok(true));
    }

    // Test a basic logic block in which an input device's value is
    // used in a calculation and then forwarded to an output device.

    #[tokio::test]
    async fn test_basic_calc_node() {
        let cfg = build_config(
            &[("in", "device:in")],
            &[("out", "device:out")],
            &[],
            &["{in} > 5 -> {out}"],
        );
        let (tx_in, rx_in) = mpsc::channel(100);
        let (tx_out, mut rx_out) = mpsc::channel(100);

        let (_, _, emu, tx_stop) = Emulator::start(
            vec![("device:in".into(), rx_in)],
            vec![("device:out".into(), tx_out)],
            cfg,
        )
        .await
        .unwrap();

        // Send a value and see if it was forwarded.

        assert!(tx_in.send(device::Value::Int(10)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Bool(true));

        // Send a different value that doesn't change the result and
        // see that it doesn't get forwarded.

        assert!(tx_in.send(device::Value::Int(9)).await.is_ok());
        assert!(time::timeout(Duration::from_millis(100), rx_out.recv())
            .await
            .is_err());

        // Send a different value and see if it was forwarded.

        assert!(tx_in.send(device::Value::Int(2)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Bool(false));

        // Stop the emulator and see that its return status is good.

        let _ = tx_stop.send(());

        assert_eq!(emu.await.unwrap(), Ok(true));
    }

    // Test a basic logic block in which a def expression can possibly
    // not return a value and whether that condition is passed onto
    // the controlling expression.

    #[tokio::test]
    async fn test_forwarding_none() {
        let cfg = build_config(
            &[("in", "device:in")],
            &[("out", "device:out")],
            &[("maybe", "if {in} <> 5 then {in} end")],
            &["{maybe} -> {out}"],
        );
        let (tx_in, rx_in) = mpsc::channel(100);
        let (tx_out, mut rx_out) = mpsc::channel(100);

        let (_, _, emu, tx_stop) = Emulator::start(
            vec![("device:in".into(), rx_in)],
            vec![("device:out".into(), tx_out)],
            cfg,
        )
        .await
        .unwrap();

        // Send a value and see if it was forwarded.

        assert!(tx_in.send(device::Value::Int(4)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Int(4));

        // Send a value that results in `def` not generating a value.
        // The shouldn't be any change in the output.

        assert!(tx_in.send(device::Value::Int(5)).await.is_ok());
        assert!(time::timeout(Duration::from_millis(100), rx_out.recv())
            .await
            .is_err());

        assert!(tx_in.send(device::Value::Int(6)).await.is_ok());

        let (value, rpy) = rx_out.recv().await.unwrap();
        let _ = rpy.send(Ok(value.clone()));

        assert_eq!(value, device::Value::Int(6));

        // Stop the emulator and see that its return status is good.

        let _ = tx_stop.send(());

        assert_eq!(emu.await.unwrap(), Ok(true));
    }

    // Test a basic logic block in which forwards a solar parameter to
    // a memory device.

    #[tokio::test]
    async fn test_basic_solar_node() {
        const OUT1: &str = "device:out1";
        const OUT2: &str = "device:out2";
        let cfg = build_config(
            &[],
            &[("alt", OUT1), ("dec", OUT2)],
            &[],
            &["{solar:alt} -> {alt}", "{solar:dec} -> {dec}"],
        );
        let (tx_out1, mut rx_out1) = mpsc::channel(100);
        let (tx_out2, mut rx_out2) = mpsc::channel(100);

        let (_, tx_solar, emu, tx_stop) = Emulator::start(
            vec![],
            vec![(OUT1.into(), tx_out1), (OUT2.into(), tx_out2)],
            cfg,
        )
        .await
        .unwrap();

        // Send a value and see if it was forwarded.

        assert!(tx_solar
            .send(Arc::new(solar::SolarInfo {
                elevation: 1.0,
                azimuth: 2.0,
                right_ascension: 3.0,
                declination: 4.0
            }))
            .is_ok());

        {
            let (value, rpy) = rx_out1.recv().await.unwrap();
            let _ = rpy.send(Ok(value.clone()));

            assert_eq!(value, device::Value::Flt(1.0));
        }

        {
            let (value, rpy) = rx_out2.recv().await.unwrap();
            let _ = rpy.send(Ok(value.clone()));

            assert_eq!(value, device::Value::Flt(4.0));
        }

        // Stop the emulator and see that its return status is good.

        let _ = tx_stop.send(());

        assert_eq!(emu.await.unwrap(), Ok(true));
    }

    // Test a logic block with two outputs. Make sure they are sent
    // "in parallel".

    #[tokio::test]
    async fn test_node_concurrency() {
        const IN1: &str = "device:in";
        const OUT1: &str = "device:out1";
        const OUT2: &str = "device:out2";

        // This section sets the output expressions in out1 -> out2
        // order. It computes a different value that is sent to the
        // outputs and verifies the correct value is sent to the
        // correct device.

        {
            let cfg = build_config(
                &[("in", IN1)],
                &[("out1", OUT1), ("out2", OUT2)],
                &[],
                &["{in} -> {out1}", "{in} * 2 -> {out2}"],
            );
            let (tx_in, rx_in) = mpsc::channel(100);
            let (tx_out1, mut rx_out1) = mpsc::channel(100);
            let (tx_out2, mut rx_out2) = mpsc::channel(100);

            let (_, _, emu, tx_stop) = Emulator::start(
                vec![(IN1.into(), rx_in)],
                vec![(OUT1.into(), tx_out1), (OUT2.into(), tx_out2)],
                cfg,
            )
            .await
            .unwrap();

            // Send a value and see if it was forwarded to both
            // channels. We hold off replying until we verify both
            // channels have content.

            assert!(tx_in.send(device::Value::Int(10)).await.is_ok());

            let (value1, rpy1) =
                time::timeout(Duration::from_millis(100), rx_out1.recv())
                    .await
                    .unwrap()
                    .unwrap();
            let (value2, rpy2) =
                time::timeout(Duration::from_millis(100), rx_out2.recv())
                    .await
                    .unwrap()
                    .unwrap();

            assert_eq!(value1, device::Value::Int(10));
            assert_eq!(value2, device::Value::Int(20));

            let _ = rpy1.send(Ok(value1.clone()));
            let _ = rpy2.send(Ok(value2.clone()));

            // Stop the emulator and see that its return status is good.

            let _ = tx_stop.send(());

            assert_eq!(emu.await.unwrap(), Ok(true));
        }

        // This section sets the output expressions in out2 -> out1
        // order. It computes a different value that is sent to the
        // outputs and verifies the correct value is sent to the
        // correct device.

        {
            let cfg = build_config(
                &[("in", IN1)],
                &[("out1", OUT1), ("out2", OUT2)],
                &[],
                &["{in} * 2 -> {out2}", "{in} -> {out1}"],
            );
            let (tx_in, rx_in) = mpsc::channel(100);
            let (tx_out1, mut rx_out1) = mpsc::channel(100);
            let (tx_out2, mut rx_out2) = mpsc::channel(100);

            let (_, _, emu, tx_stop) = Emulator::start(
                vec![(IN1.into(), rx_in)],
                vec![(OUT1.into(), tx_out1), (OUT2.into(), tx_out2)],
                cfg,
            )
            .await
            .unwrap();

            // Send a value and see if it was forwarded to both
            // channels. We hold off replying until we verify both
            // channels have content.

            assert!(tx_in.send(device::Value::Int(10)).await.is_ok());

            let (value1, rpy1) =
                time::timeout(Duration::from_millis(100), rx_out1.recv())
                    .await
                    .unwrap()
                    .unwrap();
            let (value2, rpy2) =
                time::timeout(Duration::from_millis(100), rx_out2.recv())
                    .await
                    .unwrap()
                    .unwrap();

            assert_eq!(value1, device::Value::Int(10));
            assert_eq!(value2, device::Value::Int(20));

            let _ = rpy1.send(Ok(value1.clone()));
            let _ = rpy2.send(Ok(value2.clone()));

            // Stop the emulator and see that its return status is good.

            let _ = tx_stop.send(());

            assert_eq!(emu.await.unwrap(), Ok(true));
        }

        // This section sets the output expressions in out2 -> out1
        // order. It computes a different value that is sent to the
        // outputs and verifies the correct value is sent to the
        // correct device. The expression uses some expression in the
        // `defs` section.

        {
            let cfg = build_config(
                &[("in", IN1)],
                &[("out1", OUT1), ("out2", OUT2)],
                &[("def1", "{in} * 10"), ("def2", "{in} * 100")],
                &[
                    "{def1} * 2 + {def2} + {in} -> {out2}",
                    "{def1} + {def2} * 2 + {in} * 3 -> {out1}",
                ],
            );
            let (tx_in, rx_in) = mpsc::channel(100);
            let (tx_out1, mut rx_out1) = mpsc::channel(100);
            let (tx_out2, mut rx_out2) = mpsc::channel(100);

            let (_, _, emu, tx_stop) = Emulator::start(
                vec![(IN1.into(), rx_in)],
                vec![(OUT1.into(), tx_out1), (OUT2.into(), tx_out2)],
                cfg,
            )
            .await
            .unwrap();

            // Send a value and see if it was forwarded to both
            // channels. We hold off replying until we verify both
            // channels have content.

            assert!(tx_in.send(device::Value::Int(4)).await.is_ok());

            let (value1, rpy1) =
                time::timeout(Duration::from_millis(100), rx_out1.recv())
                    .await
                    .unwrap()
                    .unwrap();
            let (value2, rpy2) =
                time::timeout(Duration::from_millis(100), rx_out2.recv())
                    .await
                    .unwrap()
                    .unwrap();

            assert_eq!(value1, device::Value::Int(852));
            assert_eq!(value2, device::Value::Int(484));

            let _ = rpy1.send(Ok(value1.clone()));
            let _ = rpy2.send(Ok(value2.clone()));

            // Stop the emulator and see that its return status is good.

            let _ = tx_stop.send(());

            assert_eq!(emu.await.unwrap(), Ok(true));
        }
    }
}

---
FILE: drmemd/src/logic/solar.rs
// The fomulas found in this module were obtained from
//
//	https://www.sciencedirect.com/science/article/pii/S0960148121004031
//
// in late Feb of 2024.

use chrono::{Datelike, Timelike};
use std::sync::Arc;
use tokio::{
    sync::{broadcast, Barrier},
    time,
};
use tracing::{debug, info, info_span, warn, Instrument};

pub struct SolarInfo {
    pub elevation: f64,
    pub azimuth: f64,
    pub right_ascension: f64,
    pub declination: f64,
}

pub type Info = Arc<SolarInfo>;

// Compute the sun's position information based on the latitude
// (degrees), longitude (degrees), and time-of-day. The formulas used
// in this function were obtained from a paper linked from the
// Wikipedia page. The paper included FORTRAN code to perform the
// calculations.  That code was used as a reference to build this
// function.

fn get_solar_position(
    lat: f64,
    long: f64,
    time: &chrono::DateTime<chrono::Utc>,
) -> Arc<SolarInfo> {
    // Convert time-of-day to a floating point value in the range 0.0
    // through 23.999.

    let gmtime: f64 = time.hour() as f64
        + ((time.minute() * 60 + time.second()) as f64 / 3600.0);

    // Calculate the number of days since the "base date" used by
    // these formulas (Jan 1st, 2000 UTC). The number of leap years
    // will be correct until 2100.

    let n_ly: f64 = ((time.year() - 2000) / 4 + 1) as f64;
    let n: f64 = n_ly
        + (time.year() - 2000) as f64 * 365.0
        + time.ordinal0() as f64
        + gmtime / 24.0
        - 1.5;

    // Calculate "mean longitude" for the sun.

    let l: f64 = (280.466 + 0.9856474 * n).rem_euclid(360.0);

    // Calculate "mean anomaly".

    let g: f64 = (357.528 + 0.9856003 * n).rem_euclid(360.0).to_radians();

    // Calculate "eliptic longitude".

    let lambda: (f64, f64) =
        (l + 1.915 * f64::sin(g) + 0.020 * f64::sin(2.0 * g))
            .rem_euclid(360.0)
            .to_radians()
            .sin_cos();

    // Calculate the "obliquity of ecliptic".

    let epsilon: (f64, f64) = (23.440 - 0.0000004 * n).to_radians().sin_cos();

    // Compute the right ascension.

    let alpha: f64 = f64::atan2(epsilon.1 * lambda.0, lambda.1)
        .to_degrees()
        .rem_euclid(360.0);

    // Compute the declination.

    let sunlat: f64 = f64::asin(epsilon.0 * lambda.0);
    let delta: f64 = sunlat.to_degrees();
    let sunlat_sc: (f64, f64) = sunlat.sin_cos();

    // Compute the "equation of time".

    let eot: f64 = (l - alpha + 180.0).rem_euclid(360.0) - 180.0;

    let sunlon: f64 = -15.0 * (gmtime - 12.0 + eot / 15.0);

    let lon_delta: (f64, f64) = (sunlon - long).to_radians().sin_cos();
    let lat_sc: (f64, f64) = lat.to_radians().sin_cos();

    let sx: f64 = sunlat_sc.1 * lon_delta.0;
    let sy: f64 = lat_sc.1 * sunlat_sc.0 - lat_sc.0 * sunlat_sc.1 * lon_delta.1;
    let sz: f64 = lat_sc.0 * sunlat_sc.0 + lat_sc.1 * sunlat_sc.1 * lon_delta.1;

    let elevation: f64 = f64::asin(sz).to_degrees();
    let azimuth: f64 =
        (f64::atan2(-sx, -sy).to_degrees() + 180.0).rem_euclid(360.0);

    debug!(
        "alt: {:.2}, az: {:.2}, ra: {:.2}, dec: {:.2}",
        round(elevation, 0.02),
        round(azimuth, 0.1),
        round(alpha, 0.1),
        round(delta, 0.1)
    );

    Arc::new(SolarInfo {
        elevation: round(elevation, 0.02),
        azimuth: round(azimuth, 0.1),
        right_ascension: round(alpha, 0.1),
        declination: round(delta, 0.1),
    })
}

fn round(v: f64, prec: f64) -> f64 {
    (v / prec).round() * prec
}

async fn run(tx: broadcast::Sender<Info>, lat: f64, long: f64) {
    let mut interval = time::interval(time::Duration::from_secs(15));

    while tx
        .send(get_solar_position(lat, long, &chrono::Utc::now()))
        .is_ok()
    {
        let _ = interval.tick().await;
    }
    warn!("no remaining clients ... terminating");
}

pub fn create_task(
    lat: f64,
    long: f64,
    barrier: Arc<Barrier>,
) -> (broadcast::Sender<Info>, broadcast::Receiver<Info>) {
    let (tx, rx) = broadcast::channel(10);
    let tx_copy = tx.clone();

    tokio::spawn(
        async move {
            info!("waiting for clients to register");
            barrier.wait().await;

            info!("running");
            run(tx_copy, lat, long).await
        }
        .instrument(info_span!("solar")),
    );

    (tx, rx)
}

#[cfg(test)]
mod tests {
    use super::get_solar_position;
    use chrono::TimeZone;

    fn close_enough(a: f64, b: f64, delta: f64) -> bool {
        (a - b).abs() <= delta
    }

    struct TestData {
        year: i32,
        month: u32,
        day: u32,
        hour: u32,
        minute: u32,
        second: u32,
        lat: f64,
        long: f64,
        elev: f64,
        az: f64,
        decl: f64,
    }

    #[test]
    fn test_solar() {
        // The calculated values were obtained from
        // https://gml.noaa.gov/grad/solcalc/

        const TEST_DATA: &[TestData] = &[
            // This first group verifies noon, Jan 1st, 2000 at
            // latitudes 45, 0, and -45 with longtitudes 0, 90, 180,
            // and -90.
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 12,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: 0.0,
                elev: 22.0,
                az: 179.18,
                decl: -23.03,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 12,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: 0.0,
                elev: 66.96,
                az: 178.06,
                decl: -23.03,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 12,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: 0.0,
                elev: 68.03,
                az: 2.03,
                decl: -23.03,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 18,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: -90.0,
                elev: 22.02,
                az: 179.15,
                decl: -23.01,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 18,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: -90.0,
                elev: 66.98,
                az: 177.99,
                decl: -23.01,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 18,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: -90.0,
                elev: 68.01,
                az: 2.1,
                decl: -23.01,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 0,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: -180.0,
                elev: 21.96,
                az: 179.24,
                decl: -23.07,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 0,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: -180.0,
                elev: 66.92,
                az: 178.2,
                decl: -23.07,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 0,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: -180.0,
                elev: 68.07,
                az: 1.89,
                decl: -23.07,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 6,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: 90.0,
                elev: 21.98,
                az: 179.21,
                decl: -23.05,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 6,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: 90.0,
                elev: 66.94,
                az: 178.13,
                decl: -23.05,
            },
            TestData {
                year: 2000,
                month: 1,
                day: 1,
                hour: 6,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: 90.0,
                elev: 68.05,
                az: 1.96,
                decl: -23.05,
            },
            // This next set tests two hours before and after noon for
            // longitude 0 and latitudes 45, 0, and -45.
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 10,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: 0.0,
                elev: 56.65,
                az: 120.65,
                decl: 23.1,
            },
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 10,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: 0.0,
                elev: 52.09,
                az: 50.33,
                decl: 23.1,
            },
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 10,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: 0.0,
                elev: 16.34,
                az: 29.53,
                decl: 23.1,
            },
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 14,
                minute: 0,
                second: 0,
                lat: 45.0,
                long: 0.0,
                elev: 57.79,
                az: 236.87,
                decl: 23.09,
            },
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 14,
                minute: 0,
                second: 0,
                lat: 0.0,
                long: 0.0,
                elev: 53.55,
                az: 311.29,
                decl: 23.09,
            },
            TestData {
                year: 2010,
                month: 7,
                day: 1,
                hour: 14,
                minute: 0,
                second: 0,
                lat: -45.0,
                long: 0.0,
                elev: 17.0,
                az: 332.18,
                decl: 23.09,
            },
        ];

        for data in TEST_DATA {
            let time = chrono::Utc
                .with_ymd_and_hms(
                    data.year,
                    data.month,
                    data.day,
                    data.hour,
                    data.minute,
                    data.second,
                )
                .single()
                .unwrap();
            let pos = get_solar_position(data.lat, data.long, &time);

            assert!(
                close_enough(pos.elevation, data.elev, 0.2),
                "elevation: {} <> {}",
                pos.elevation,
                data.elev
            );
            assert!(
                close_enough(pos.azimuth, data.az, 0.2),
                "azimuth: {} <> {}",
                pos.azimuth,
                data.az
            );
            assert!(
                close_enough(pos.declination, data.decl, 0.2),
                "declination: {} <> {}",
                pos.declination,
                data.decl
            );
        }
    }
}

---
FILE: drmemd/src/logic/tod.rs
use chrono::{Datelike, Timelike};
use core::pin::Pin;
use core::task::{Context, Poll};
use std::sync::Arc;
use tokio::{
    sync::{broadcast, Barrier},
    time,
};
use tokio_stream::{wrappers::BroadcastStream, Stream};
use tracing::{info, info_span, warn, Instrument};

// Information related to time-of-day. We keep both UTC and local time
// so clients don't have to convert between the time zones. It is
// stored in an `Arc` so it can be cheaply sent and received over a
// broadcast channel.

pub type Info = Arc<(
    chrono::DateTime<chrono::Utc>,
    chrono::DateTime<chrono::Local>,
)>;

// Each variant of this enumeration selects a field of a Date/Time
// type. They are defined in order of shortest time span to largest so
// they can be compared. This enumeration is used as an optimization
// in the state of a logic block, for instance, to select which time
// field should be checked for changes. Doing so prevents the task
// from recalculating all its expressions every second when it really
// only needed to do it once an hour.

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum TimeField {
    Second,
    Minute,
    Hour,
    Day,
    Month,
    Year,
}

pub struct TimeFilter {
    field: TimeField,
    prev: Option<Info>,
    inner: BroadcastStream<Info>,
}

impl TimeFilter {
    fn changed(&self, curr: &Info) -> bool {
        if let Some(ref v) = self.prev {
            match self.field {
                TimeField::Second => {
                    v.0.second() != curr.0.second()
                        || v.1.second() != curr.1.second()
                }
                TimeField::Minute => {
                    v.0.minute() != curr.0.minute()
                        || v.1.minute() != curr.1.minute()
                }
                TimeField::Hour => {
                    v.0.hour() != curr.0.hour() || v.1.hour() != curr.1.hour()
                }
                TimeField::Day => {
                    v.0.day() != curr.0.day() || v.1.day() != curr.1.day()
                }
                TimeField::Month => {
                    v.0.month() != curr.0.month()
                        || v.1.month() != curr.1.month()
                }
                TimeField::Year => {
                    v.0.year() != curr.0.year() || v.1.year() != curr.1.year()
                }
            }
        } else {
            true
        }
    }
}

// Make TimeFilter able to be used as a BroadcastStream wrapper.

impl Stream for TimeFilter {
    type Item = Info;

    fn poll_next(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>> {
        loop {
            match Pin::new(&mut self.inner).poll_next(cx) {
                // If the stream is done, or doesn't have a new value,
                // pass the return value to the caller.
                Poll::Pending => return Poll::Pending,
                Poll::Ready(None) => return Poll::Ready(None),

                // If we got a value, check to see if it has changed
                // enough from the previous value to return it. If
                // not, loop for the next value.
                Poll::Ready(Some(Ok(tod))) => {
                    if self.changed(&tod) {
                        self.prev = Some(tod.clone());
                        return Poll::Ready(Some(tod));
                    }
                }

                // The only error we can get is that we haven't read
                // the stream fast enough and that elements have been
                // dropped. In this case, we clear out the previous
                // value so that the next value always gets returned.
                Poll::Ready(Some(Err(_))) => self.prev = None,
            }
        }
    }
}

pub fn time_filter(
    stream: BroadcastStream<Info>,
    field: TimeField,
) -> TimeFilter {
    TimeFilter {
        inner: stream,
        field,
        prev: None,
    }
}

fn initial_delay() -> u64 {
    let now = chrono::Utc::now();
    let extra = now.timestamp_subsec_millis();

    ((10020 - extra) % 1000) as u64
}

async fn run(tx: broadcast::Sender<Info>) {
    let mut interval = time::interval_at(
        time::Instant::now() + time::Duration::from_millis(initial_delay()),
        time::Duration::from_secs(1),
    );

    while tx
        .send(Arc::new((chrono::Utc::now(), chrono::Local::now())))
        .is_ok()
    {
        let _ = interval.tick().await;
    }
    warn!("no remaining clients ... terminating");
}

pub fn create_task(
    barrier: Arc<Barrier>,
) -> (broadcast::Sender<Info>, broadcast::Receiver<Info>) {
    let (tx, rx) = broadcast::channel(1);
    let tx_copy = tx.clone();

    tokio::spawn(
        async move {
            info!("waiting for clients to register");
            barrier.wait().await;

            info!("running");
            run(tx_copy).await
        }
        .instrument(info_span!("tod")),
    );

    (tx, rx)
}

#[cfg(test)]
mod tests {
    use super::{time_filter, Info, TimeField};
    use chrono::{Local, TimeZone, Utc};
    use core::pin::Pin;
    use futures::future::poll_fn;
    use std::sync::Arc;
    use tokio::sync::broadcast;
    use tokio_stream::{wrappers::BroadcastStream, Stream};

    fn mk_info(yr: i32, mo: u32, da: u32, hr: u32, mn: u32, se: u32) -> Info {
        Arc::new((
            Utc::with_ymd_and_hms(&Utc, yr, mo, da, hr, mn, se)
                .single()
                .unwrap(),
            Local::with_ymd_and_hms(&Local, yr, mo, da, hr, mn, se)
                .single()
                .unwrap(),
        ))
    }

    async fn test_one_filter(
        inputs: &[Info],
        outputs: &[Option<Info>],
        field: TimeField,
    ) {
        let (tx, rx) = broadcast::channel::<Info>(inputs.len());
        let mut strm = time_filter(BroadcastStream::new(rx), field.clone());

        for input in inputs {
            assert!(tx.send(input.clone()).is_ok());
        }

        for output in outputs {
            let fut = poll_fn(|cx| Pin::new(&mut strm).poll_next(cx));

            assert_eq!(fut.await, *output, "error in {:?} test", field);
        }
    }

    #[tokio::test]
    async fn test_stream() {
        // This checks that all changes in the seconds field results
        // in a value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2001, 2, 2, 1, 1, 1);
            let t3: Info = mk_info(2000, 1, 1, 0, 0, 2);

            test_one_filter(
                &[t1.clone(), t2.clone(), t3.clone()],
                &[Some(t1.clone()), Some(t3.clone())],
                TimeField::Second,
            )
            .await
        }

        // This checks that all changes in the minutes field results
        // in a value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2000, 1, 1, 0, 0, 2);
            let t3: Info = mk_info(2000, 1, 1, 0, 1, 0);
            let t4: Info = mk_info(2001, 2, 2, 1, 1, 1);
            let t5: Info = mk_info(2000, 1, 1, 0, 2, 0);

            test_one_filter(
                &[t1.clone(), t2.clone(), t3.clone(), t4.clone(), t5.clone()],
                &[Some(t1.clone()), Some(t3.clone()), Some(t5.clone())],
                TimeField::Minute,
            )
            .await
        }

        // This checks that all changes in the hours field results in
        // a value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2000, 1, 1, 0, 0, 2);
            let t3: Info = mk_info(2000, 1, 1, 0, 1, 0);
            let t4: Info = mk_info(2000, 1, 1, 1, 0, 0);
            let t5: Info = mk_info(2001, 2, 3, 1, 2, 0);
            let t6: Info = mk_info(2000, 1, 1, 2, 2, 0);

            test_one_filter(
                &[
                    t1.clone(),
                    t2.clone(),
                    t3.clone(),
                    t4.clone(),
                    t5.clone(),
                    t6.clone(),
                ],
                &[Some(t1.clone()), Some(t4.clone()), Some(t6.clone())],
                TimeField::Hour,
            )
            .await
        }

        // This checks that all changes in the days field results in a
        // value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2002, 2, 1, 2, 2, 2);
            let t3: Info = mk_info(2000, 1, 2, 0, 1, 0);

            test_one_filter(
                &[t1.clone(), t2.clone(), t3.clone()],
                &[Some(t1.clone()), Some(t3.clone())],
                TimeField::Day,
            )
            .await
        }

        // This checks that all changes in the months field results in
        // a value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2002, 1, 2, 2, 2, 2);
            let t3: Info = mk_info(2000, 2, 2, 0, 1, 0);

            test_one_filter(
                &[t1.clone(), t2.clone(), t3.clone()],
                &[Some(t1.clone()), Some(t3.clone())],
                TimeField::Month,
            )
            .await
        }

        // This checks that all changes in the years field results in
        // a value returned from the stream.

        {
            let t1: Info = mk_info(2000, 1, 1, 0, 0, 1);
            let t2: Info = mk_info(2000, 2, 2, 2, 2, 2);
            let t3: Info = mk_info(2002, 2, 2, 0, 1, 0);

            test_one_filter(
                &[t1.clone(), t2.clone(), t3.clone()],
                &[Some(t1.clone()), Some(t3.clone())],
                TimeField::Year,
            )
            .await
        }
    }
}

---
FILE: drmemd/src/main.rs
#![deny(unsafe_code)]

#[cfg(feature = "graphql")]
#[macro_use]
extern crate lazy_static;

use drmem_api::{driver::RequestChan, Error, Result};
use futures::future;
use std::{convert::Infallible, sync::Arc};
use tokio::{sync::Barrier, task::JoinHandle};
use tracing::{error, info, info_span, warn, Instrument};

mod config;
mod core;
mod driver;
mod logic;

pub mod backends;

// If the user specifies the 'graphql' feature, then pull in the module
// that defines the GraphQL server.

#[cfg(feature = "graphql")]
mod graphql;

// Initializes the `drmemd` application. It determines the
// configuration and sets up the logger. It returns `Some(Config)`
// with the found configuration, if the applications is to run. It
// returns `None` if the program should exit (because a command line
// option asked for a "usage" message, for instance.)

async fn init_app() -> Option<config::Config> {
    // If a configuration is returned, set up the logger.

    if let Some(cfg) = config::get().await {
        // Initialize the log system. The max log level is determined
        // by the user (either through the config file or the command
        // line.)

        let subscriber = tracing_subscriber::fmt()
            .with_max_level(cfg.get_log_level())
            .with_target(false)
            .finish();

        tracing::subscriber::set_global_default(subscriber)
            .expect("Unable to set global default subscriber");
        Some(cfg)
    } else {
        None
    }
}

async fn wrap_task(
    handle: JoinHandle<Result<Infallible>>,
) -> Result<Infallible> {
    match handle.await {
        Err(e) if e.is_panic() => {
            error!("terminated due to panic");
            Err(Error::OperationError("task panicked".to_owned()))
        }

        Err(_) => {
            error!("terminated due to cancellation");
            Err(Error::OperationError("task was canceled".to_owned()))
        }

        Ok(Ok(_)) => unreachable!(),

        Ok(Err(e)) => {
            error!("task returned error -- {}", &e);
            Err(e)
        }
    }
}

// Runs the main body of the application. This top-level task reads
// the config, starts the drivers and logic node, and monitors their
// health.

async fn run() -> Result<()> {
    if let Some(cfg) = init_app().await {
        let drv_tbl = driver::DriverDb::<
            <backends::Instance as backends::Store>::Reporter,
        >::create();

        // Start the core task. It returns a handle to a channel with
        // which to make requests. It also returns the task handle.

        let (tx_drv_req, tx_clnt_req, core_task) = core::start(&cfg).await?;

        // Build initial vector of required tasks. Crate features will
        // enable more required tasks.

        let mut tasks = vec![wrap_task(core_task)];

        // Iterate through the list of drivers specified in the
        // configuration file.

        info!("starting drivers");

        for driver in cfg.driver {
            let driver_name: drmem_api::driver::Name =
                driver.name.clone().into();

            // If the driver exists in the driver table, an instance
            // can be started. If it doesn't exist, report an error
            // and exit.

            if let Some(driver_info) = drv_tbl.get_driver(&driver_name) {
                let chan = RequestChan::new(
                    driver_name.clone(),
                    &driver.prefix,
                    &tx_drv_req,
                );
                let barrier = Arc::new(Barrier::new(2));

                // Call the function that manages instances of this
                // driver. If it returns `Ok()`, the value is a Future
                // that implements the driver. If `Err()` is returned,
                // then the devices couldn't be registered or some
                // other serious error occurred.

                let instance = (driver_info.2)(
                    driver.cfg.unwrap_or_default().clone().into(),
                    chan,
                    driver.max_history,
                    barrier.clone(),
                );

                // Push the driver instance at the end of the vector.

                tasks.push(wrap_task(tokio::spawn(instance.instrument(
                    info_span!(
                        "driver",
                        name = driver_name.as_ref(),
                        prefix = driver.prefix.to_string()
                    ),
                ))));

                let _ = barrier.wait().await;
            } else {
                error!("no driver named {}", driver.name);
                return Err(Error::NotFound);
            }
        }

        // Create a nested scope so that the tod and solar handles are
        // freed up.

        {
            let barrier = Arc::new(Barrier::new(3 + cfg.logic.len()));

            // Start the time-of-day task. This needs to be done
            // *before* any logic blocks are started because logic
            // blocks *may* have an expression that uses the
            // time-of-day.

            let (tx_tod, _) = logic::tod::create_task(barrier.clone());

            // Start the solar task. This, too, needs to be done
            // before any logic blocks are started.

            let (tx_solar, _) = logic::solar::create_task(
                cfg.latitude,
                cfg.longitude,
                barrier.clone(),
            );

            info!("starting logic blocks");

            // Iterate through the [[logic]] sections of the config.

            for logic in cfg.logic.iter() {
                let node_task = logic::Node::start(
                    tx_clnt_req.clone(),
                    tx_tod.subscribe(),
                    tx_solar.subscribe(),
                    logic.clone(),
                    barrier.clone(),
                )
                .await;

                tasks.push(wrap_task(node_task));
            }

            // Now that all the logic blocks have initialized, we
            // start the tasks blocked by the Barrier.

            let _ = barrier.wait().await;
        }

        // If the "graphql" feature is specified, start up the web
        // server which accepts GraphQL queries. We do this last so
        // that all the queries will have access to all the
        // drivers/blocks/devices that were created above.

        #[cfg(feature = "graphql")]
        {
            use futures::FutureExt;

            info!("starting GraphQL");

            // This server should never exit. If it does, report an
            // `OperationError`,

            let f = graphql::server(
                &cfg.graphql,
                &cfg.logic,
                drv_tbl.clone(),
                tx_clnt_req.clone(),
            )
            .instrument(info_span!("gql"))
            .then(|_| async {
                Err(Error::OperationError("graphql server exited".to_owned()))
            });

            tasks.push(wrap_task(tokio::spawn(f)));
        }

        // Now run all the tasks.

        let _ = future::join_all(tasks).await;

        warn!("shutting down")
    }
    Ok(())
}

#[tokio::main]
async fn main() {
    if let Err(e) = run().await {
        eprintln!("ERROR: {e:?}")
    }
}

---
