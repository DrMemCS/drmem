# Driver API

Drivers in `drmem` are implemented as Rust `async` functions and will
be spawned as background tasks in `tokio`. In each driver task, there
will be some resource set-up followed by a main loop. The main loop
will acquire data from hardware and then write it to the store.

Each device has a "natural" event rate (i.e. a rate that makes the
most sense for the device.) Each iteration of the main loop in the
driver happens when the event fires. Right now, there are three event
types provided by the framework: periodic events that can't exceed 20
Hz, events which occur when a setting is received, and "command"
requests from the framework. A driver may have other events that wake
it up (data from the network, for instance.) A setting event contains
incoming settings from a client. The driver should apply the setting
value to the hardware (and then also write it back to the database.)

So the basic structure of a driver is:

- Initialize hardware resources
- Create event generator(s)
- For each event:
    - If event is periodic or specific to the driver:
        - Get newest value(s) from hardware
        - Write value(s) to database
    - Else if event is a setting:
        - Set the appropriate hardware
        - Write value to database
    - Else if event is a command:
        - Return appropriate reply

A driver writes to the backend storage through an interface. The
interface enforces how keys are generated and how the data is saved in
the backend. This interface is also where the newest reading is
compared to the alarm limits and reported as in alarm.

## Architecture

Driver modules will provide a registration function which provides the
name of the driver and a factory function to make new instances. This
factory function will take driver-specific parameters (which provide
addressing information in accessing its hardware.) If the function
succeeds, it'll return an async function that takes an object which is
used to communicate with the framework. A supervisor task handles this
set-up and start-up, monitors the driver and restarts it, if it
panics.

### Incoming Events

The driver task will respond to "events". There are several sources of
events which are received when the driver `await`s for them. The
events are:

- Timer events. The driver can use `tokio`'s interval generator to
  create a stream of evenly spaced timer events. It's up to the driver
  if it needs this event.
- Hardware events. This event source is completely specific to the
  driver. It could be generated by a local, kernel device driver or
  it could be driven by data arriving on a socket.
- Setting events. If the driver has devices that can be set by
  external sources, it registers the device as settable and will
  receive a handle which will receive setting requests.
- Framework events. This is the only event type that drivers are
  required to handle. Drivers will receive a handle that receives
  query requests from the framework. The driver should respond to them
  in a timely fashion.

### Data Flow

For read-only devices:

- [ ] Driver registers device (name, type, etc.), as read-only, with
      framework. Receives a handle to send readings.
- [ ] The handle delivers readings directly to the storage backend.

For settable devices:

- [ ] Driver registers device (name, type, etc.), as settable, with
      framework. Receives a handle to send readings and a handle to
      receive settings.
- [ ] The send handle delivers readings directly to the storage
      backend.
- [ ] The setting handle will return incoming settings.

To read a device:

- [ ] Client requests from storage backend device name and time range
      and receives a handle which delivers values as they update.

### Sync-ing timestamps

Some devices update "simultaneously" (two devices might return
different scaling for the same hardware; Fahrenheit and Celsius for a
temperature sensor, for instance.) We want those readings to have the
same timestamp which isn't guaranteed if each reading is sent
separately.

When registering, the value can be a n-tuple representing `n`
devices. Anytime one of the devices needs to be updated, all of them
have to have values. The backend *must* guarantee that all device
readings are stored with the same timestamp.

### Alarms

Each reading that is sent to the backend needs to be compared to alarm
limits and reported, if necessary.

## Scratchpad For Ideas

Create a typed-template:

```
let devt: DeviceTemplate<bool> =
    DeviceTemplate::<bool>::new("name", "summary", "units", 1000);
```

Driver will receive a connection to the framework. The templates can
be used to define devices in the framework:

```
let dev: impl ReadableDevice = fwork.register_device(devt);

let (dev, rx_set): (impl WritableDevice, mpsc::Receiver<*>) =
    fwork.register_settable_device(devt);
```

(Do we need `DeviceTemplate`? Maybe the register methods can take the
parameters directly.)

Should be able to group the readable devices that are logcally
connected. The grouping should create a function that takes n
arguments for n devices.

Maybe there isn't a `WriteableDevice` trait? Registering it as
writable returns the `ReadableDevice` trait along with a channel that
receives settings. So `ReadableDevice` needs to be renamed?

```
let dev1: Device<bool> = ...
let dev2: Device<f64> = ...

let update_fn: async fn(bool, f64) -> Result<> =
    fwork.group(dev1, dev2);
```
